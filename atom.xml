<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Seth的小站</title>
  
  
  <link href="https://lx02918.github.io/atom.xml" rel="self"/>
  
  <link href="https://lx02918.github.io/"/>
  <updated>2024-09-07T07:10:43.292Z</updated>
  <id>https://lx02918.github.io/</id>
  
  <author>
    <name>Seth</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>陌陌笔试——推荐算法-计算智能算法笔试</title>
    <link href="https://lx02918.github.io/2024/09/06/%E9%99%8C%E9%99%8C%E7%AC%94%E8%AF%95/"/>
    <id>https://lx02918.github.io/2024/09/06/%E9%99%8C%E9%99%8C%E7%AC%94%E8%AF%95/</id>
    <published>2024-09-06T13:04:27.000Z</published>
    <updated>2024-09-07T07:10:43.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说实话，陌陌这次的笔试真的真的让人感觉到了原来我真的会点东西啊，废话不多说，直接上题目（朋友发我的，考前有个预览试卷他拍照了！谴责他！不过要不是他我还拿不到这么全的题目呢）</p><p>对了，前提需要说一下，代码为核心代码模式，且需要将结果设为result，最终函数返回1，后续会人工判卷（有一说一我自己是觉得人工判卷相对来说会比系统自动要好一些，最起码有主观看法）。</p><h1 id="寻找支配点"><a href="#寻找支配点" class="headerlink" title="寻找支配点"></a>寻找支配点</h1><p>P为给定的二维平面整数点集。定义P中某点x，如果x满足P中任意点都不在x的右上方区域内（横纵坐标都大于x），则称其为一个支配点。</p><p>如下图所示，蓝色点位该点集中的支配点集合</p><figure>  <img src="/2024/09/06/%E9%99%8C%E9%99%8C%E7%AC%94%E8%AF%95/IMG_7685.png" class="" title="寻找支配点">  <figcaption>寻找支配点</figcaption></figure><p>请实现代码，找到给定的人以及和P中的所有支配点并输出。（所有点的横纵坐标不重复）</p><p>输入：二维数组，表示点集P</p><p>输出：二维数组，n个支配点的点集Q</p><p>示例：</p><p>输入 P&#x3D;[[1, 2], [5, 3], [4, 6], [7, 5], [9, 0]]</p><p>输出 [[4, 6], [7, 5], [9, 0]]</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">self , P: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        P.sort(key = <span class="hljs-keyword">lambda</span> p: (-p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>]))<br>        result = []<br>        max_y = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> P:<br>            <span class="hljs-keyword">if</span> y &gt; max_y:<br>                result.append([x, y])<br>        <span class="hljs-variable language_">self</span>.result = result<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="非极大值抑制"><a href="#非极大值抑制" class="headerlink" title="非极大值抑制"></a>非极大值抑制</h1><p>非极大值抑制（Non-Maximum Suppression，NMS）是一种用于目标检测的算法，旨在从多个重叠的候选框中选择出最优的框。其基本思想是抑制那些不是局部最大值的元素，从而减少冗余的检测结果。</p><h2 id="NMS的工作原理"><a href="#NMS的工作原理" class="headerlink" title="NMS的工作原理"></a>NMS的工作原理</h2><ol><li><strong>局部最大搜索</strong>：NMS算法通过对候选框的得分进行排序，选择得分最高的框作为参考框。</li><li><strong>计算重叠度</strong>：对于其他候选框，计算它们与当前参考框的重叠度（交并比，IoU）。如果某个候选框的IoU大于设定的阈值（通常在0.3到0.5之间），则认为它与参考框指向同一目标，因而将其剔除。</li><li><strong>重复过程</strong>：从剩余的候选框中再次选择得分最高的框，重复上述步骤，直到没有候选框可以被剔除为止。</li></ol><p>NMS在计算机视觉领域的应用非常广泛，包括视频目标跟踪、数据挖掘、3D重建和目标识别等</p><p>(以上资料来源于网络)</p><p>输入：</p><p>boxes为二维数组，其中每个元素是一维数组[x1, y1, x2, y2]，分别表示框的左上角和右下角坐标。scores是一个一维数组，每个元素表示每个框的置信度。两个的元素个数是相互对应的，iou_threshold表示用于移除重叠框的交并比阈值。</p><p>输出：</p><p>一个一维数组，表示所有留下框在原始列表中的下表，按照从小到大排序。</p><p>提示：</p><p>框面积计算公式为（y2 - y1) * (x2 - x1)</p><p>交并比的计算公式为：两框的交集面积除以并集面积</p><p>示例：</p><p>输入：</p><p>boxes &#x3D; [[x11, y11, x21, y21], [x12, y12, x22, y22], [x13, y13, x23, y23]], scores &#x3D; [0.75, 0.7, 0.8], iou_threshold &#x3D; 0.7</p><p>输出：</p><p>[0, 2]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">self, boxes: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], sorces: <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>], iou_threshold: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_iou</span>(<span class="hljs-params">box1, box2</span>):<br>            x1 = <span class="hljs-built_in">max</span>(box1[<span class="hljs-number">0</span>], box2[<span class="hljs-number">0</span>])<br>            y1 = <span class="hljs-built_in">max</span>(box1[<span class="hljs-number">1</span>], box2[<span class="hljs-number">1</span>])<br>            x2 = <span class="hljs-built_in">min</span>(box1[<span class="hljs-number">2</span>], box2[<span class="hljs-number">2</span>])<br>            y2 = <span class="hljs-built_in">min</span>(box1[<span class="hljs-number">3</span>], box2[<span class="hljs-number">3</span>])<br>            <br>            intersection = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, x2 - x1) * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, y2 - y1)<br>            area1 = (box1[<span class="hljs-number">2</span>] - box1[<span class="hljs-number">0</span>]) * (box1[<span class="hljs-number">3</span>] - box1[<span class="hljs-number">1</span>])<br>            area2 = (box2[<span class="hljs-number">2</span>] - box2[<span class="hljs-number">0</span>]) * (box2[<span class="hljs-number">3</span>] - box2[<span class="hljs-number">1</span>])<br>            union = area1 + area2 - intersection<br>            <br>            <span class="hljs-keyword">return</span> intersection / union <span class="hljs-keyword">if</span> union &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(boxes)<br>        indices = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(n))<br>        indices.sort(key = <span class="hljs-keyword">lambda</span> i: sorces[i], reverse = <span class="hljs-literal">True</span>)<br>        <br>        result = []<br>        <span class="hljs-keyword">while</span> indices:<br>            idx = indices[<span class="hljs-number">0</span>]<br>            result.append(idx)<br>            indices = indices[<span class="hljs-number">1</span>:]<br>            <br>            indices = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> indices <span class="hljs-keyword">if</span> calculate_iou(boxes[idx], boxes[<span class="hljs-number">0</span>]) &lt;= iou_threshold]<br>            <br>            result.sort()<br>            result = result<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="序列置换"><a href="#序列置换" class="headerlink" title="序列置换"></a>序列置换</h1><p>给一个长度为N（N&lt;1000）的正整数序列（1~N），我们称之为A。将上述序列随机重新排列后的序列称之为B序列。使用B序列作为一个置换，来对A序列进行操作。置换是指将A序列中的第B[i]个元素，挪到第i个位置。请实现一个函数，输入将A序列置换K次之后的序列。注意K可能会非常大($K &lt; 10^8$)</p><p>输入：A序列、B序列以及K</p><p>输出：置换后序列</p><p>示例：</p><p>输入：</p><p>A &#x3D; [1, 2, 3], B &#x3D; [3, 1, 2], k &#x3D; 2</p><p>输出：[2, 3, 1]</p><p>说明：</p><p>A序列经过B序列置换后变为312，再经过231</p><p>Q1：请简述算法思路和时间空间复杂度</p><p>Q2：编程实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">self, A: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], B: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(A)<br>        result = [<span class="hljs-number">0</span>] * n<br>        visited = [<span class="hljs-literal">False</span>] * n<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:<br>                cycle = []<br>                j = i<br>                <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> visited[j]:<br>                    visited[j] = <span class="hljs-literal">True</span><br>                    cycle.append(j)<br>                    j = B[j] - <span class="hljs-number">1</span><br>                cycle_length = <span class="hljs-built_in">len</span>(cycle)<br>                <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cycle_length):<br>                    result[cycle[(m + K) % cycle_length]] = A[cycle[m]]<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>构建循环：遍历A的每个元素，使用i作为索引如果没有被访问则从这里开始，沿着B数组定义的置换元素构建一个置换循环。使用cycle记录循环中给所有元素的索引</li><li>处理置换循环：遍历cycle，记长度为cycle_length，对每个元素都置换到新位置，位置是计算得出的</li></ol><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这次的题相对来说其实属于easy和medium范畴了。但是由于没有设定结果所以也没办法看自己最终能够通过多少，不过我的思路应该是大差不差的，如果有什么问题还请大家在评论里指出，啾咪💞</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;说实话，陌陌这次的笔试真的真的让人感觉到了原来我真的会点东西啊，废话不多说，直接上题目（朋友发我的，考前有个预览试卷他拍照了！谴责他！不过要</summary>
      
    
    
    
    <category term="笔试记录" scheme="https://lx02918.github.io/categories/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="笔试" scheme="https://lx02918.github.io/tags/%E7%AC%94%E8%AF%95/"/>
    
    <category term="算法题" scheme="https://lx02918.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题记录——Kadane算法</title>
    <link href="https://lx02918.github.io/2024/09/04/leetcode-Kadane%E7%AE%97%E6%B3%95/"/>
    <id>https://lx02918.github.io/2024/09/04/leetcode-Kadane%E7%AE%97%E6%B3%95/</id>
    <published>2024-09-04T08:10:40.000Z</published>
    <updated>2024-09-04T10:59:08.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="53-最大子数组和-Medium"><a href="#53-最大子数组和-Medium" class="headerlink" title="53 最大子数组和 Medium"></a>53 <a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a> <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong></p><p>是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[5,4,-1,7,8]</span><br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接动态规划，记录每个位置的最大子数组和，进而推导出全局最大子数组和</p><p>状态转移方程$dp[i] &#x3D; max(nums[i], nums[i] + dp[i - 1])$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [<span class="hljs-number">0</span>] * n<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            dp[i] = <span class="hljs-built_in">max</span>(nums[i], nums[i] + dp[i - <span class="hljs-number">1</span>])<br>        res = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            res = <span class="hljs-built_in">max</span>(res, dp[i])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="918-环形子数组的最大和-Medium"><a href="#918-环形子数组的最大和-Medium" class="headerlink" title="918 环形子数组的最大和 Medium"></a>918 <a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">环形子数组的最大和</a> <font color=#ff7f50 size=4>Medium</font></h1><p>给定一个长度为 <code>n</code> 的<strong>环形整数数组</strong> <code>nums</code> ，返回 <em><code>nums</code> 的非空 <strong>子数组</strong> 的最大可能和</em> 。</p><p><strong>环形数组</strong> 意味着数组的末端将会与开头相连呈环状。形式上， <code>nums[i]</code> 的下一个元素是 <code>nums[(i + 1) % n]</code> ， <code>nums[i]</code> 的前一个元素是 <code>nums[(i - 1 + n) % n]</code> 。</p><p><strong>子数组</strong> 最多只能包含固定缓冲区 <code>nums</code> 中的每个元素一次。形式上，对于子数组 <code>nums[i], nums[i + 1], ..., nums[j]</code> ，不存在 <code>i &lt;= k1, k2 &lt;= j</code> 其中 <code>k1 % n == k2 % n</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,-2,3,-2]</span><br>输出：3<br>解释：从子数组 <span class="hljs-comment">[3]</span> 得到最大和 3<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,-3,5]</span><br>输出：10<br>解释：从子数组 <span class="hljs-comment">[5,5]</span> 得到最大和 5 + 5 = 10<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,-2,2,-3]</span><br>输出：3<br>解释：从子数组 <span class="hljs-comment">[3]</span> 和 <span class="hljs-comment">[3,-2,2]</span> 都可以得到最大和 3<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 3 * 104</code></li><li><code>-3 * 104 &lt;= nums[i] &lt;= 3 * 104</code></li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这题还是用<code>Kadane</code>算法去计算子数组的最大和，但需要注意几个问题。</p><p>首先我们在第一个的基础上额外用两个变量去存储当前位置的前一个位置的和（最大或最小）</p><p>其次我们还需要注意<code>nums</code>可能全为负</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubarraySumCircular</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        <span class="hljs-comment"># 使用Kadane算法找到非环形子数组的最大和</span><br>        max_sum = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)<br>        current_max = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            current_max = <span class="hljs-built_in">max</span>(num, current_max + num)<br>            max_sum = <span class="hljs-built_in">max</span>(max_sum, current_max)<br>        <br>        <span class="hljs-comment"># 找到非环形子数组的最小和</span><br>        min_sum = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        current_min = <span class="hljs-number">0</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            res += num<br>            current_min = <span class="hljs-built_in">min</span>(num, current_min + num)<br>            min_sum = <span class="hljs-built_in">min</span>(min_sum, current_min)<br>        <br>        <span class="hljs-comment"># 如果最大和大于0，则比较非环形最大和与环形最大和（总和减去最小和）</span><br>        <span class="hljs-keyword">if</span> max_sum &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(max_sum, res - min_sum)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果所有数都是负数，则返回非环形最大和</span><br>            <span class="hljs-keyword">return</span> max_sum<br><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(1)，执行时间171ms，消耗内存20.4MB</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;53-最大子数组和-Medium&quot;&gt;&lt;a href=&quot;#53-最大子数组和-Medium&quot; class=&quot;headerlink&quot; title=&quot;53 最大子数组和 Medium&quot;&gt;&lt;/a&gt;53 &lt;a href=&quot;https://leetcode.cn/proble</summary>
      
    
    
    
    <category term="刷题记录" scheme="https://lx02918.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Leetcode" scheme="https://lx02918.github.io/tags/Leetcode/"/>
    
    <category term="刷题" scheme="https://lx02918.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="Kadane算法" scheme="https://lx02918.github.io/tags/Kadane%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题记录——分治</title>
    <link href="https://lx02918.github.io/2024/09/03/leetcode-%E5%88%86%E6%B2%BB/"/>
    <id>https://lx02918.github.io/2024/09/03/leetcode-%E5%88%86%E6%B2%BB/</id>
    <published>2024-09-03T07:03:46.000Z</published>
    <updated>2024-09-04T07:33:54.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="108-将有序数组转换为二叉搜索树-Easy"><a href="#108-将有序数组转换为二叉搜索树-Easy" class="headerlink" title="108 将有序数组转换为二叉搜索树 Easy"></a>108 <a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a> <font color=#7fffd4 size=4>Easy</font></h1><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 </p><p>平衡</p><p> 二叉搜索树。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-10</span>,<span class="hljs-string">-3</span>,0,5,9]<br>输出：[0,<span class="hljs-string">-3</span>,9,<span class="hljs-string">-10</span>,null,5]<br>解释：[0,<span class="hljs-string">-10</span>,5,null,<span class="hljs-string">-3</span>,null,9] 也将被视为正确答案：<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3]</span><br>输出：<span class="hljs-comment">[3,1]</span><br>解释：<span class="hljs-comment">[1,null,3]</span> 和 <span class="hljs-comment">[3,1]</span> 都是高度平衡二叉搜索树。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里需要回顾下我们之前看过的二叉搜索树的概念，详细请见<a href="https://lx02918.github.io/2024/08/21/leetcode-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">leetcode刷题记录——二叉搜索树</a></p><p> 然后借助我们的概念，root节点就是整个nums的中间位置，然后递归就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedArrayToBST</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        mid = <span class="hljs-built_in">len</span>(nums) // <span class="hljs-number">2</span><br>        root = TreeNode(nums[mid])<br>        root.left = <span class="hljs-variable language_">self</span>.sortedArrayToBST(nums[:mid])<br>        root.right = <span class="hljs-variable language_">self</span>.sortedArrayToBST(nums[mid+<span class="hljs-number">1</span>:])<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(log n)，执行时间43ms，消耗内存17.7MB</p><h1 id="148-排序链表-Medium"><a href="#148-排序链表-Medium" class="headerlink" title="148 排序链表 Medium"></a>148 <a href="https://leetcode.cn/problems/sort-list/">排序链表</a> <font color=#ff7f50 size=4>Medium</font></h1><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">4,2,1,3</span>]<br>输出：[<span class="hljs-number">1,2,3,4</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [-<span class="hljs-number">1,5,3,4</span>,<span class="hljs-number">0</span>]<br>输出：[-<span class="hljs-number">1,0,3,4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先需要明确的一点是我们需要用到两个方法，一个将链表拆分为两部分，一个用来合并链表</p><p>拆分部分需要用到快慢指针，合并部分需要用到虚拟节点和尾节点</p><p>其余直接看代码，写了注释</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:<br>            <span class="hljs-keyword">return</span> head<br>        <span class="hljs-comment"># 使用快慢指针找到链表中间节点</span><br>        slow, fast = head, head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:<br>            slow = slow.<span class="hljs-built_in">next</span><br>            fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 将链表分为两部分</span><br>        second = slow.<span class="hljs-built_in">next</span><br>        slow.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 递归地对两部分链表进行排序</span><br>        left = <span class="hljs-variable language_">self</span>.sortList(head)<br>        right = <span class="hljs-variable language_">self</span>.sortList(second)<br>        <span class="hljs-comment"># 合并链表</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.merge(left, right)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, left, right</span>):<br>        dummy = tail = ListNode(<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 合并有序链表</span><br>        <span class="hljs-keyword">while</span> left <span class="hljs-keyword">and</span> right:<br>            <span class="hljs-keyword">if</span> left.val &lt; right.val:<br>                tail.<span class="hljs-built_in">next</span> = left<br>                left = left.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                tail.<span class="hljs-built_in">next</span> = right<br>                right = right.<span class="hljs-built_in">next</span><br>            tail = tail.<span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 剩余节点连接到合并后的尾部</span><br>        tail.<span class="hljs-built_in">next</span> = left <span class="hljs-keyword">if</span> left <span class="hljs-keyword">else</span> right<br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(nlog n)，空间复杂度O(log n)，执行时间294ms，消耗内存31.4MB</p><h1 id="427-建立四叉树-Medium"><a href="#427-建立四叉树-Medium" class="headerlink" title="427 建立四叉树 Medium"></a>427 <a href="https://leetcode.cn/problems/construct-quad-tree/">建立四叉树</a> <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个 <code>n * n</code> 矩阵 <code>grid</code> ，矩阵由若干 <code>0</code> 和 <code>1</code> 组成。请你用四叉树表示该矩阵 <code>grid</code> 。</p><p>你需要返回能表示矩阵 <code>grid</code> 的 四叉树 的根结点。</p><p>四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：</p><ul><li><code>val</code>：储存叶子结点所代表的区域的值。1 对应 <strong>True</strong>，0 对应 <strong>False</strong>。注意，当 <code>isLeaf</code> 为 <strong>False</strong> 时，你可以把 <strong>True</strong> 或者 <strong>False</strong> 赋值给节点，两种值都会被判题机制 <strong>接受</strong> 。</li><li><code>isLeaf</code>: 当这个节点是一个叶子结点时为 <strong>True</strong>，如果它有 4 个子节点则为 <strong>False</strong> 。</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">    public</span> boolean val;<br>    public boolean isLeaf;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">topLeft</span>;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">topRight</span>;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">bottomLeft</span>;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">bottomRight</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以按以下步骤为二维区域构建四叉树：</p><ol><li>如果当前网格的值相同（即，全为 <code>0</code> 或者全为 <code>1</code>），将 <code>isLeaf</code> 设为 True ，将 <code>val</code> 设为网格相应的值，并将四个子节点都设为 Null 然后停止。</li><li>如果当前网格的值不同，将 <code>isLeaf</code> 设为 False， 将 <code>val</code> 设为任意值，然后如下图所示，将当前网格划分为四个子网格。</li><li>使用适当的子网格递归每个子节点。</li></ol><p><img src="https://assets.leetcode.com/uploads/2020/02/11/new_top.png" alt="img"></p><p>如果你想了解更多关于四叉树的内容，可以参考 <a href="https://en.wikipedia.org/wiki/Quadtree">wiki</a> 。</p><p><strong>四叉树格式：</strong></p><p>你不需要阅读本节来解决这个问题。只有当你想了解输出格式时才会这样做。输出为使用层序遍历后四叉树的序列化形式，其中 <code>null</code> 表示路径终止符，其下面不存在节点。</p><p>它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 <code>[isLeaf, val]</code> 。</p><p>如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 True ，则表示它在列表 <code>[isLeaf, val]</code> 中的值为 <strong>1</strong> ；如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 False ，则表示值为 <strong>0</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/02/11/grid1.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[0,1],[1,0]]</span><br>输出：<span class="hljs-string">[[0,1],[1,0],[1,1],[1,1],[1,0]]</span><br>解释：此示例的解释如下：<br>请注意，在下面四叉树的图示中，<span class="hljs-number">0</span> 表示 <span class="hljs-literal">false</span>，<span class="hljs-number">1</span> 表示 True 。<br></code></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/02/12/e1tree.png" alt="img"></p><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/02/12/e2mat.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：grid = <span class="hljs-comment">[<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>,<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>,<span class="hljs-comment">[1,1,1,1,1,1,1,1]</span>,<span class="hljs-comment">[1,1,1,1,1,1,1,1]</span>,<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>,<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>,<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>,<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[1,0]</span>,null,null,null,null,<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[1,1]</span>]</span><br>解释：网格中的所有值都不相同。我们将网格划分为四个子网格。<br>topLeft，bottomLeft 和 bottomRight 均具有相同的值。<br>topRight 具有不同的值，因此我们将其再分为 4 个子网格，这样每个子网格都具有相同的值。<br>解释如下图所示：<br></code></pre></td></tr></table></figure><p> <img src="https://assets.leetcode.com/uploads/2020/02/12/e2tree.png" alt="img"></p><p><strong>提示：</strong></p><ol><li><code>n == grid.length == grid[i].length</code></li><li><code>n == 2x</code> 其中 <code>0 &lt;= x &lt;= 6</code></li></ol><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>主要用到两个函数，<code>same</code>和<code>dfs</code>。<code>same</code>函数用于检查二维数组中所有元素是否相同，<code>dfs</code>函数用于递归构建四叉树，所用到的四个参数主要用于处理当前矩阵区域的起始行结束行起始列结束列。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">construct</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-string">&#x27;Node&#x27;</span>:<br>        <span class="hljs-comment"># 辅助函数：检查从 (a, c) 到 (b, d) 的矩形区域内的所有元素是否相同</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">same</span>(<span class="hljs-params">a, b, c, d</span>):<br>            cur = grid[a][c]  <span class="hljs-comment"># 获取区域左上角的值</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(a, b):<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c, d):<br>                    <span class="hljs-keyword">if</span> grid[i][j] != cur:  <span class="hljs-comment"># 如果发现不同值，返回 False</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <span class="hljs-comment"># 区域内所有元素相同，返回 True</span><br>        <br>        <span class="hljs-comment"># 深度优先搜索函数：递归构建四叉树</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">rs, re, ls, le</span>):<br>            <span class="hljs-keyword">if</span> same(rs, re, ls, le):  <span class="hljs-comment"># 如果当前区域内的所有元素相同</span><br>                node = Node(grid[rs][ls], <span class="hljs-literal">True</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>)  <span class="hljs-comment"># 创建叶子节点</span><br>            <span class="hljs-keyword">else</span>:<br>                node = Node(grid[rs][ls], <span class="hljs-literal">False</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>)  <span class="hljs-comment"># 创建非叶子节点</span><br>                row_middle = (rs + re) // <span class="hljs-number">2</span>  <span class="hljs-comment"># 计算中间行索引</span><br>                col_middle = (ls + le) // <span class="hljs-number">2</span>  <span class="hljs-comment"># 计算中间列索引</span><br>                <span class="hljs-comment"># 递归构建四个子节点</span><br>                node.topLeft = dfs(rs, row_middle, ls, col_middle)<br>                node.topRight = dfs(rs, row_middle, col_middle, le)<br>                node.bottomLeft = dfs(row_middle, re, ls, col_middle)<br>                node.bottomRight = dfs(row_middle, re, col_middle, le)<br>            <span class="hljs-keyword">return</span> node  <span class="hljs-comment"># 返回当前构建的节点</span><br>        <br>        l = <span class="hljs-built_in">len</span>(grid)  <span class="hljs-comment"># 获取输入二维数组的长度</span><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, l, <span class="hljs-number">0</span>, l)  <span class="hljs-comment"># 从整个矩阵的左上角到右下角开始递归构建四叉树</span><br><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度$O(n^2logn)$，空间复杂度$O(logn)$，执行时间89ms，消耗内存17.35MB</p><h1 id="23-合并-K-个升序链表-Hard"><a href="#23-合并-K-个升序链表-Hard" class="headerlink" title="23 合并 K 个升序链表 Hard"></a>23 <a href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并 K 个升序链表</a> <font color=#ff0000 size=4>Hard</font></h1><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：lists = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：lists = <span class="hljs-string">[[]]</span><br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>整体思路上借助最小堆的特性来做，堆中的元素需要包含节点的值，节点的唯一标识，节点本身</p><p>关于最小堆的特性：</p><ul><li>最小堆是一种完全二叉树，这意味着除了最后一层外，其他层都是满的，并且最后一层的节点都尽量靠左排列。</li><li>对于任意节点 <code>i</code>，其左子节点 <code>2*i + 1</code> 和右子节点 <code>2*i + 2</code> 的值都大于或等于节点 <code>i</code> 的值。</li></ul><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params">self, lists: <span class="hljs-type">List</span>[<span class="hljs-type">Optional</span>[ListNode]]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        p = dummy<br>        pq = []<br>        <br>        <span class="hljs-comment"># 将每个链表的头节点压入堆中</span><br>        <span class="hljs-keyword">for</span> head <span class="hljs-keyword">in</span> lists:<br>            <span class="hljs-keyword">if</span> head:<br>                heapq.heappush(pq, (head.val, <span class="hljs-built_in">id</span>(head), head))<br>        <br>        <span class="hljs-comment"># 当堆不为空时，执行以下操作</span><br>        <span class="hljs-keyword">while</span> pq:<br>            <span class="hljs-comment"># 从堆中弹出值最小的节点</span><br>            node = heapq.heappop(pq)[<span class="hljs-number">2</span>]<br>            p.<span class="hljs-built_in">next</span> = node<br>            <br>            <span class="hljs-comment"># 如果该节点有下一个节点，则将下一个节点压入堆中</span><br>            <span class="hljs-keyword">if</span> node.<span class="hljs-built_in">next</span>:<br>                heapq.heappush(pq, (node.<span class="hljs-built_in">next</span>.val, <span class="hljs-built_in">id</span>(node.<span class="hljs-built_in">next</span>), node.<span class="hljs-built_in">next</span>))<br>            <br>            p = p.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度$O(nlogk)$，空间复杂度O(n + k)，执行时间49ms，消耗内存18.8MB</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;108-将有序数组转换为二叉搜索树-Easy&quot;&gt;&lt;a href=&quot;#108-将有序数组转换为二叉搜索树-Easy&quot; class=&quot;headerlink&quot; title=&quot;108 将有序数组转换为二叉搜索树 Easy&quot;&gt;&lt;/a&gt;108 &lt;a href=&quot;https:/</summary>
      
    
    
    
    <category term="刷题记录" scheme="https://lx02918.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Leetcode" scheme="https://lx02918.github.io/tags/Leetcode/"/>
    
    <category term="刷题" scheme="https://lx02918.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="分治" scheme="https://lx02918.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题记录——回溯</title>
    <link href="https://lx02918.github.io/2024/08/29/leetcode-%E5%9B%9E%E6%BA%AF/"/>
    <id>https://lx02918.github.io/2024/08/29/leetcode-%E5%9B%9E%E6%BA%AF/</id>
    <published>2024-08-29T08:16:01.000Z</published>
    <updated>2024-09-04T08:19:41.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="17-电话号码的字母组合-Medium"><a href="#17-电话号码的字母组合-Medium" class="headerlink" title="17 电话号码的字母组合 Medium"></a>17 电话号码的字母组合 <font color=#ff7f50 size=4>Medium</font></h1><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：digits <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;2&quot;</span><br>输出：[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先建立好映射，初始化我们需要存储的数组一个存储结果一个辅助我们的过程</p><p>后续使用回溯算法进行递归就OK了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-built_in">dict</span> = [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>, <span class="hljs-string">&#x27;ghi&#x27;</span>, <span class="hljs-string">&#x27;jkl&#x27;</span>, <span class="hljs-string">&#x27;mno&#x27;</span>, <span class="hljs-string">&#x27;pqrs&#x27;</span>, <span class="hljs-string">&#x27;tuv&#x27;</span>, <span class="hljs-string">&#x27;wxyz&#x27;</span>]<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.total = []<br>        <span class="hljs-variable language_">self</span>.res = []<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCombinations</span>(<span class="hljs-params">self, digits: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> digits:<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.total<br>        <span class="hljs-comment"># 从第一个数字开始  </span><br>        <span class="hljs-variable language_">self</span>.backtrack(digits, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.total<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, digits: <span class="hljs-built_in">str</span>, start: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.res) == <span class="hljs-built_in">len</span>(digits):<br>            <span class="hljs-comment"># 到达回溯树底部</span><br>            <span class="hljs-variable language_">self</span>.total.append(<span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-variable language_">self</span>.res))<br>            <span class="hljs-keyword">return</span><br>        digit = <span class="hljs-built_in">ord</span>(digits[start]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;0&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">dict</span>[digit]:<br>            <span class="hljs-comment"># 做选择</span><br>            <span class="hljs-variable language_">self</span>.res.append(i)<br>            <span class="hljs-comment"># 递归下一层</span><br>            <span class="hljs-variable language_">self</span>.backtrack(digits, start + <span class="hljs-number">1</span>)<br>            <span class="hljs-comment"># 撤销选择</span><br>            <span class="hljs-variable language_">self</span>.res.pop()<br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度$O(4 ^n)$，空间复杂度$O(n * 4 ^ n)$，执行时间24ms，消耗内存16.4MB</p><h1 id="77-组合-Medium"><a href="#77-组合-Medium" class="headerlink" title="77 组合 Medium"></a>77 组合 <font color=#ff7f50 size=4>Medium</font></h1><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 4, k = 2<br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>依旧是模板题，不过要注意的是，起始位置为1，存储为list</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        res = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">first = <span class="hljs-number">1</span>, curr = []</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(curr) == k:<br>                res.append(curr[:])<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(first, n + <span class="hljs-number">1</span>):<br>                curr.append(i)<br>                backtrack(i + <span class="hljs-number">1</span>, curr)<br>                curr.pop()<br>        backtrack(<span class="hljs-number">1</span>, [])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(k * C(n, k))，空间复杂度O(k * C(n, k))，执行时间190ms，消耗内存57.4MB</p><p>这里的C(n, k)涉及到组合公式（说实话我都不太会算了，高中学完，大学学完概率论就不咋用了，隐隐约约记得高中那会还总结了一个快速算法，排列问题也有一个）</p><p>公式为 $C(n, k) &#x3D; \frac{n!}{k!(n - k)!}$</p><h1 id="46-全排列-Medium"><a href="#46-全排列-Medium" class="headerlink" title="46 全排列 Medium"></a>46 全排列 <font color=#ff7f50 size=4>Medium</font></h1><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>还是模板，只不过这里在回溯部分需要改为换位置</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        res = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">first = <span class="hljs-number">0</span></span>):<br>            <span class="hljs-keyword">if</span> first == <span class="hljs-built_in">len</span>(nums):<br>                res.append(nums[:])<br>                <span class="hljs-keyword">return</span> <br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(first, <span class="hljs-built_in">len</span>(nums)):<br>                nums[first], nums[i] = nums[i], nums[first]<br>                backtrack(first + <span class="hljs-number">1</span>)<br>                nums[first], nums[i] = nums[i], nums[first]<br>                <br>        backtrack()<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n * n!)，空间复杂度O(n * n!)，执行时间27ms，消耗内存16.7MB</p><h1 id="组合总和-Medium"><a href="#组合总和-Medium" class="headerlink" title="组合总和 Medium"></a>组合总和 <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和<span class="hljs-number"> 3 </span>可以形成一组候选，2 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。注意<span class="hljs-number"> 2 </span>可以使用多次。<br>7 也是一个候选，<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 7 </span>。<br>仅有这两种组合。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[2,3,5]</span>, target = 8<br>输出: <span class="hljs-comment">[<span class="hljs-comment">[2,2,2,2]</span>,<span class="hljs-comment">[2,3,3]</span>,<span class="hljs-comment">[3,5]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[2]</span>, target = 1<br>输出: <span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>还是模板题，这里需要注意的是，我们的 <code>backtrack</code> 函数需要涉及到四个东西，数组 <code>candidates</code> 结果 <code>target</code> 起始点 <code>first</code> 加和 <code>sum</code></p><p>别的其实和第一题如出一辙</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.res = []<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params">self, candidates: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> candidates:<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.res<br>        <span class="hljs-variable language_">self</span>.backtrack(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.res<br>    track = []<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, candidates: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span>, first: <span class="hljs-built_in">int</span>, <span class="hljs-built_in">sum</span>: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> == target:<br>            <span class="hljs-variable language_">self</span>.res.append(<span class="hljs-variable language_">self</span>.track.copy())<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> &gt; target:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(first, <span class="hljs-built_in">len</span>(candidates)):<br>            <span class="hljs-variable language_">self</span>.track.append(candidates[i])<br>            <span class="hljs-built_in">sum</span> += candidates[i]<br>            <span class="hljs-variable language_">self</span>.backtrack(candidates, target, i, <span class="hljs-built_in">sum</span>)<br>            <span class="hljs-built_in">sum</span> -= candidates[i]<br>            <span class="hljs-variable language_">self</span>.track.pop()<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n^(target&#x2F;min(candidates)))，空间复杂度O(target&#x2F;min(candidates))，执行时间62ms，消耗内存16.6MB</p><h1 id="52-N-皇后-II-Hard"><a href="#52-N-皇后-II-Hard" class="headerlink" title="52 N 皇后 II Hard"></a>52 N 皇后 II <font color=#ff0000 size=4>Hard</font></h1><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n × n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回 <strong>n 皇后问题</strong> 不同的解决方案的数量。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>输出：<span class="hljs-number">2</span><br>解释：如上图所示，<span class="hljs-number">4</span> 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这道题唯一需要注意的就是在该位置能不能放皇后，由于我们遍历过程中左下右下并未涉及到，所以我们只需要看右上左上有没有皇后就可以</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">totalNQueens</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        board = [<span class="hljs-string">&#x27;.&#x27;</span> * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-variable language_">self</span>.backtrack(board, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.res<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, board, row</span>):<br>        <span class="hljs-keyword">if</span> row == <span class="hljs-built_in">len</span>(board):<br>            <span class="hljs-variable language_">self</span>.res += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span><br>        n = <span class="hljs-built_in">len</span>(board[row])<br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.isValid(board, row, col):<br>                <span class="hljs-keyword">continue</span><br>            board[row] = board[row][:col] + <span class="hljs-string">&#x27;Q&#x27;</span> + board[row][col + <span class="hljs-number">1</span>:]<br>            <span class="hljs-variable language_">self</span>.backtrack(board, row + <span class="hljs-number">1</span>)<br>            board[row] = board[row][:col] + <span class="hljs-string">&#x27;.&#x27;</span> + board[row][col + <span class="hljs-number">1</span>:]<br>            <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, board, row, col</span>):<br>        n = <span class="hljs-built_in">len</span>(board)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, row + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> board[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> i, j, <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<span class="hljs-built_in">range</span>(row - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), <span class="hljs-built_in">range</span>(col + <span class="hljs-number">1</span>, n)):<br>            <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<span class="hljs-built_in">range</span>(row - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), <span class="hljs-built_in">range</span>(col - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)):<br>            <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(N!)，空间复杂度O(N)，执行时间101ms，消耗内存16.4MB</p><h1 id="22-括号生成-Medium"><a href="#22-括号生成-Medium" class="headerlink" title="22 括号生成 Medium"></a>22 括号生成 <font color=#ff7f50 size=4>Medium</font></h1><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：[<span class="hljs-string">&quot;()&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>没啥好说的，就是套模板，直接看代码</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateParenthesis</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        res = []<br>        <span class="hljs-variable language_">self</span>.dfs(n, n, <span class="hljs-string">&#x27;&#x27;</span>, res)<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">self, left, right, path, res</span>):<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> right == <span class="hljs-number">0</span>:<br>            res.append(path)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> left &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.dfs(left - <span class="hljs-number">1</span>, right, path + <span class="hljs-string">&#x27;(&#x27;</span>, res)<br>        <span class="hljs-keyword">if</span> right &gt; left:<br>            <span class="hljs-variable language_">self</span>.dfs(left, right - <span class="hljs-number">1</span>, path + <span class="hljs-string">&#x27;)&#x27;</span>, res)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度$(O(4^n &#x2F; \sqrt{n})$，空间复杂度O(n)，执行时间44ms，消耗内存16.6MB</p><h1 id="79-单词搜索-Medium"><a href="#79-单词搜索-Medium" class="headerlink" title="79 单词搜索 Medium"></a>79 单词搜索 <font color=#ff7f50 size=4>Medium</font></h1><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;SEE&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCB&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li></ul><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>注意需要寻找四个方向看有没有，然后注意需要借助一个符号标记已经遍历过</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.found = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">exist</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]], word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        row, col = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(col):<br>                <span class="hljs-variable language_">self</span>.dfs(board, i, j, word, <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.found:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">self, board, i, j, word, k</span>):<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-built_in">len</span>(word):<br>            <span class="hljs-variable language_">self</span>.found = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">return</span> <br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.found:<br>            <span class="hljs-keyword">return</span> <br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= <span class="hljs-built_in">len</span>(board) <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &gt;= <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>]) <span class="hljs-keyword">or</span> word[k] != board[i][j]:<br>            <span class="hljs-keyword">return</span><br>        tmp = board[i][j]<br>        board[i][j] = <span class="hljs-string">&#x27;#&#x27;</span><br>        <span class="hljs-variable language_">self</span>.dfs(board, i + <span class="hljs-number">1</span>, j, word, k + <span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">self</span>.dfs(board, i - <span class="hljs-number">1</span>, j, word, k + <span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">self</span>.dfs(board, i, j + <span class="hljs-number">1</span>, word, k + <span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">self</span>.dfs(board, i, j - <span class="hljs-number">1</span>, word, k + <span class="hljs-number">1</span>)<br>        board[i][j] = tmp<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度$ O(m * n * 4^L)$，空间复杂度O(L)，执行时间3876ms，消耗内存16.4MB</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">result = []<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">路径, 选择列表</span>):<br>    <span class="hljs-keyword">if</span> 满足结束条件:<br>        result.add(路径)<br>        <span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>        做选择<br>        backtrack(路径, 选择列表)<br>        撤销选择<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;17-电话号码的字母组合-Medium&quot;&gt;&lt;a href=&quot;#17-电话号码的字母组合-Medium&quot; class=&quot;headerlink&quot; title=&quot;17 电话号码的字母组合 Medium&quot;&gt;&lt;/a&gt;17 电话号码的字母组合 &lt;font color=#ff7</summary>
      
    
    
    
    <category term="刷题记录" scheme="https://lx02918.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Leetcode" scheme="https://lx02918.github.io/tags/Leetcode/"/>
    
    <category term="刷题" scheme="https://lx02918.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="回溯" scheme="https://lx02918.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题记录——字典树</title>
    <link href="https://lx02918.github.io/2024/08/28/leetcode-%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <id>https://lx02918.github.io/2024/08/28/leetcode-%E5%AD%97%E5%85%B8%E6%A0%91/</id>
    <published>2024-08-28T08:58:13.000Z</published>
    <updated>2024-08-29T08:31:51.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="208-实现-Tire（前缀树）-Medium"><a href="#208-实现-Tire（前缀树）-Medium" class="headerlink" title="208 实现 Tire（前缀树） Medium"></a>208 实现 Tire（前缀树） <font color=#ff7f50 size=4>Medium</font></h1><p>**<a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a>**（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>示例：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">输入<br>[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]<br>[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]<br>输出<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>]<br><br>解释<br>Trie trie = <span class="hljs-built_in">new</span> Trie();<br>trie.<span class="hljs-keyword">insert</span>(&quot;apple&quot;);<br>trie.<span class="hljs-keyword">search</span>(&quot;apple&quot;);   // 返回 <span class="hljs-keyword">True</span><br>trie.<span class="hljs-keyword">search</span>(&quot;app&quot;);     // 返回 <span class="hljs-keyword">False</span><br>trie.startsWith(&quot;app&quot;); // 返回 <span class="hljs-keyword">True</span><br>trie.<span class="hljs-keyword">insert</span>(&quot;app&quot;);<br>trie.<span class="hljs-keyword">search</span>(&quot;app&quot;);     // 返回 <span class="hljs-keyword">True</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li><li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 104</code> 次</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先需要解释下什么是Tire结构，该结构的每个几点存储了对其子节点的链接，每个节点代表一个字符。根节点不包含字符，除根节点外的每个节点都与一个字符相关联。除此之外，节点通常还包含一个标志，表示该结点是否是某个字符串的结束。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>使用字典去存储，并用一个bool型变量去标记是否是单词的结尾</p><h3 id="插入字符"><a href="#插入字符" class="headerlink" title="插入字符"></a>插入字符</h3><p>从根节点开始遍历，如果不存在就创建一个新的子节点。遍历完成后标记最后一个节点为字符串的结束。</p><h3 id="搜索字符串"><a href="#搜索字符串" class="headerlink" title="搜索字符串"></a>搜索字符串</h3><p>这里和前面一样，只不过存在返回一个True不存在返回False，但需要保证最后一个节点被标记为字符串的结束</p><h3 id="前缀搜索"><a href="#前缀搜索" class="headerlink" title="前缀搜索"></a>前缀搜索</h3><p>能够完整遍历，但不需要检查最后一个节点是否被标记为结束</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.children = &#123;&#125;<br>        <span class="hljs-variable language_">self</span>.is_end_of_word = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        current = <span class="hljs-variable language_">self</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                current.children[char] = Trie()<br>            current = current.children[char]<br>        current.is_end_of_word = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        current = <span class="hljs-variable language_">self</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            current = current.children[char]<br>        <span class="hljs-keyword">return</span> current.is_end_of_word<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">startsWith</span>(<span class="hljs-params">self, prefix: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        current = <span class="hljs-variable language_">self</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> prefix:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            current = current.children[char]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度均为O(n)，空间复杂度为O(m * n)，执行时间133ms，消耗内存31.3MB</p><h1 id="211-添加与搜索单词-数据结构设计-Medium"><a href="#211-添加与搜索单词-数据结构设计-Medium" class="headerlink" title="211 添加与搜索单词 - 数据结构设计 Medium"></a>211 添加与搜索单词 - 数据结构设计 <font color=#ff7f50 size=4>Medium</font></h1><p>请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。</p><p>实现词典类 <code>WordDictionary</code> ：</p><ul><li><code>WordDictionary()</code> 初始化词典对象</li><li><code>void addWord(word)</code> 将 <code>word</code> 添加到数据结构中，之后可以对它进行匹配</li><li><code>bool search(word)</code> 如果数据结构中存在字符串与 <code>word</code> 匹配，则返回 <code>true</code> ；否则，返回 <code>false</code> 。<code>word</code> 中可能包含一些 <code>&#39;.&#39;</code> ，每个 <code>.</code> 都可以表示任何一个字母。</li></ul><p><strong>示例：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">输入：<br>[&quot;WordDictionary&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;]<br>[[],[&quot;bad&quot;],[&quot;dad&quot;],[&quot;mad&quot;],[&quot;pad&quot;],[&quot;bad&quot;],[&quot;.ad&quot;],[&quot;b..&quot;]]<br>输出：<br>[<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>]<br><br>解释：<br>WordDictionary wordDictionary = <span class="hljs-built_in">new</span> WordDictionary();<br>wordDictionary.addWord(&quot;bad&quot;);<br>wordDictionary.addWord(&quot;dad&quot;);<br>wordDictionary.addWord(&quot;mad&quot;);<br>wordDictionary.<span class="hljs-keyword">search</span>(&quot;pad&quot;); // 返回 <span class="hljs-keyword">False</span><br>wordDictionary.<span class="hljs-keyword">search</span>(&quot;bad&quot;); // 返回 <span class="hljs-keyword">True</span><br>wordDictionary.<span class="hljs-keyword">search</span>(&quot;.ad&quot;); // 返回 <span class="hljs-keyword">True</span><br>wordDictionary.<span class="hljs-keyword">search</span>(&quot;b..&quot;); // 返回 <span class="hljs-keyword">True</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word.length &lt;= 25</code></li><li><code>addWord</code> 中的 <code>word</code> 由小写英文字母组成</li><li><code>search</code> 中的 <code>word</code> 由 ‘.’ 或小写英文字母组成</li><li>最多调用 <code>104</code> 次 <code>addWord</code> 和 <code>search</code></li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>和前一题的思路基本上一致，但由于在 <code>search</code> 中我们需要分辨含有 <code>.</code> 的特殊节点，所以我们采用dfs去做，如果我们能够匹配到就返回，不能满足就下一个，所有都不满足就False</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.children = [<span class="hljs-literal">None</span>] * <span class="hljs-number">26</span><br>        <span class="hljs-variable language_">self</span>.isEnd = <span class="hljs-literal">False</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WordDictionary</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.root = Node()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addWord</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        node = <span class="hljs-variable language_">self</span>.root<br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>            index = <span class="hljs-built_in">ord</span>(char) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.children[index]:<br>                node.children[index] = Node()<br>            node = node.children[index]<br>        node.isEnd = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">word, index, root</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(word): <span class="hljs-keyword">return</span> root.isEnd<br>            <span class="hljs-keyword">if</span> word[index]  != <span class="hljs-string">&#x27;.&#x27;</span>:<br>                i = <span class="hljs-built_in">ord</span>(word[index]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>                <span class="hljs-keyword">return</span> dfs(word, index + <span class="hljs-number">1</span>, root.children[i])<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> root.children:<br>                    <span class="hljs-keyword">if</span> dfs(word, index + <span class="hljs-number">1</span>, child):<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> dfs(word, <span class="hljs-number">0</span>, <span class="hljs-variable language_">self</span>.root)<br><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度 <code>addWord</code> 为O(n)，<code>search</code> 最坏是O(n * 26)，最好是O(n)，执行时间为1916ms，消耗内存75.7MB</p><h1 id="212-单词搜索-II-Hard"><a href="#212-单词搜索-II-Hard" class="headerlink" title="212 单词搜索 II Hard"></a>212 单词搜索 II <font color=#ff0000 size=4>Hard</font></h1><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个单词（字符串）列表 <code>words</code>， <em>返回所有二维网格上的单词</em> 。</p><p>单词必须按照字母顺序，通过 <strong>相邻的单元格</strong> 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" alt="212.1"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>],[<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;t&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>],[<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>],[<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;v&quot;</span>]], words = [<span class="hljs-string">&quot;oath&quot;</span>,<span class="hljs-string">&quot;pea&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;rain&quot;</span>]<br>输出：[<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;oath&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg" alt="212.2"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>]], words = [<span class="hljs-string">&quot;abcb&quot;</span>]<br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 12</code></li><li><code>board[i][j]</code> 是一个小写英文字母</li><li><code>1 &lt;= words.length &lt;= 3 * 104</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>words[i]</code> 由小写英文字母组成</li><li><code>words</code> 中的所有字符串互不相同</li></ul><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>首先建立一个 TrieNode，再构建一个 Trie 树</p><p>再构建一个DFS，遍历当前节点的四个方位，并存储到结果集中，最终转换为列表返回</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TireNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.children = &#123;&#125; <span class="hljs-comment"># 存储 TireNode 的子节点</span><br>        <span class="hljs-variable language_">self</span>.is_end_of_word = <span class="hljs-literal">False</span> <span class="hljs-comment"># 是否是结尾</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findWords</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]], words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        <span class="hljs-comment"># 创建 Tire</span><br>        trie = TireNode()<br>        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>            node = trie<br>            <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>                <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> node.children:<br>                    node.children[char] = TireNode()<br>                node = node.children[char]<br>            node.is_end_of_word = <span class="hljs-literal">True</span><br>            <br>        result = <span class="hljs-built_in">set</span>() <span class="hljs-comment"># 存储搜索到的单词</span><br>        rows, cols = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">row, col, node, path</span>):<br>            <span class="hljs-comment"># 检查边界条件和当前字符是否已被访问</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (<span class="hljs-number">0</span> &lt;= row &lt; rows <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= col &lt; cols) <span class="hljs-keyword">or</span> board[row][col] == <span class="hljs-string">&#x27;#&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <br>            char = board[row][col]<br>            <span class="hljs-comment"># 如果当前字符不在子节点中,直接返回</span><br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> node.children:<br>                <span class="hljs-keyword">return</span> <br>            <span class="hljs-comment"># 获取当前字符对应的字 TireNode</span><br>            child = node.children[char]<br>            <span class="hljs-comment"># 是结尾就加入结果集</span><br>            <span class="hljs-keyword">if</span> child.is_end_of_word:<br>                result.add(path + char)<br>                <span class="hljs-comment"># 如果没有子节点，直接返回</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> child.children:<br>                    <span class="hljs-keyword">return</span> <br>            <span class="hljs-comment"># 标记当前字符为已访问字符    </span><br>            board[row][col] = <span class="hljs-string">&#x27;#&#x27;</span><br>            <span class="hljs-comment"># 上下左右依次DFS</span><br>            dfs(row + <span class="hljs-number">1</span>, col, child, path + char)<br>            dfs(row - <span class="hljs-number">1</span>, col, child, path + char)<br>            dfs(row, col + <span class="hljs-number">1</span>, child, path + char)<br>            dfs(row, col - <span class="hljs-number">1</span>, child, path + char)<br>            <span class="hljs-comment"># 恢复原字符</span><br>            board[row][col] = char<br>        <br>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows):<br>            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols):<br>                dfs(row, col, trie, <span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(result)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(N * L + M * N * 4^L)，空间复杂度O(N * L + L + K)，<code>N</code> 是单词数量，<code>L</code> 是单词的平均长度，<code>M</code> 和 <code>N</code> 是字符网格的行数和列数，<code>K</code> 是找到的单词数量。执行时间2852ms，消耗内存18.6MB</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这三道题我是推荐以第三题为主，因为他的整个流程更加全面，能够很好的对此类题构建出一个模板来，所以我这里也更推荐采用第三题作为主力研究对象。</p><p>我自己大致总结了一下做题的模板和方法：</p><h2 id="操作实现方法"><a href="#操作实现方法" class="headerlink" title="操作实现方法"></a>操作实现方法</h2><p><strong>初始化</strong>：</p><ul><li>使用一个字典来存储子节点。</li><li>用一个布尔变量 <code>is_end_of_word</code> 标记当前节点是否是单词的结束节点。</li></ul><p><strong>插入操作</strong>：</p><ul><li>从根节点开始，逐字符检查字典树中是否存在对应的子节点。</li><li>如果不存在，则创建一个新节点；遍历完所有字符后，将最后一个节点标记为单词结束。</li></ul><p><strong>搜索操作</strong>：</p><ul><li>从根节点逐字符遍历字典树。如果找到对应节点且最终节点被标记为单词结束，则返回 <code>True</code>；否则返回 <code>False</code>。</li></ul><p><strong>前缀搜索操作</strong>：</p><ul><li>从根节点逐字符遍历字典树，只要能成功遍历完整个前缀即可返回 <code>True</code>，无需检查最终节点是否为单词结束。</li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.children = &#123;&#125;<br>        <span class="hljs-variable language_">self</span>.is_end_of_word = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        current = <span class="hljs-variable language_">self</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                current.children[char] = Trie()<br>            current = current.children[char]<br>        current.is_end_of_word = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        current = <span class="hljs-variable language_">self</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            current = current.children[char]<br>        <span class="hljs-keyword">return</span> current.is_end_of_word<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">startsWith</span>(<span class="hljs-params">self, prefix: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        current = <span class="hljs-variable language_">self</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> prefix:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            current = current.children[char]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>整体上来看，都是基于字典树的基本结构，操作上主要是通过遍历和检查节点是否存在来完成插入、查找和前缀匹配的功能。</p><p>同时可以看到核心代码几乎完全复用，体现了字典树操作的模块化与通用性。</p><p>在这里还需要补充一个点，<code>ord</code>函数。该函数的作用是将单个字符转换为其对应的Unicode整数表示。这个函数的功能可以概括如下：</p><ol><li>字符到整数的转换：<code>ord()</code>函数接受一个单个字符作为输入，并返回该字符的Unicode码点（整数值）</li><li>Unicode支持：<code>ord()</code>函数可以处理任何Unicode字符，不仅限于ASCII字符</li><li>单字符输入：<code>ord()</code>函数只接受单个字符作为参数。如果尝试传入多个字符，会导致错误</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;208-实现-Tire（前缀树）-Medium&quot;&gt;&lt;a href=&quot;#208-实现-Tire（前缀树）-Medium&quot; class=&quot;headerlink&quot; title=&quot;208 实现 Tire（前缀树） Medium&quot;&gt;&lt;/a&gt;208 实现 Tire（前缀树） </summary>
      
    
    
    
    <category term="刷题记录" scheme="https://lx02918.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Leetcode" scheme="https://lx02918.github.io/tags/Leetcode/"/>
    
    <category term="刷题" scheme="https://lx02918.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="字典树" scheme="https://lx02918.github.io/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题记录——图的广度优先遍历</title>
    <link href="https://lx02918.github.io/2024/08/27/leetcode-%E5%9B%BE-BFS/"/>
    <id>https://lx02918.github.io/2024/08/27/leetcode-%E5%9B%BE-BFS/</id>
    <published>2024-08-27T02:17:49.000Z</published>
    <updated>2024-08-29T06:49:22.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="909-蛇形棋-Medium"><a href="#909-蛇形棋-Medium" class="headerlink" title="909 蛇形棋 Medium"></a>909 蛇形棋 <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>board</code> ，方格按从 <code>1</code> 到 <code>n2</code> 编号，编号遵循 <a href="https://baike.baidu.com/item/%E7%89%9B%E8%80%95%E5%BC%8F%E8%BD%AC%E8%A1%8C%E4%B9%A6%E5%86%99%E6%B3%95/**17195786**">转行交替方式</a> ，从左下角开始 （即，从 <code>board[n - 1][0]</code> 开始）每一行交替方向。</p><p>玩家从棋盘上的方格 <code>1</code> （总是在最后一行、第一列）开始出发。</p><p>每一回合，玩家需要从当前方格 <code>curr</code> 开始出发，按下述要求前进：</p><p>选定目标方格 <code>next</code> ，目标方格的编号符合范围 <code>[curr + 1, min(curr + 6, n_2)]</code> 。</p><p>该选择模拟了掷 <strong>六面体骰子</strong> 的情景，无论棋盘大小如何，玩家最多只能有 <code>6</code> 个目的地。</p><p>传送玩家：如果目标方格 <code>next</code> 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 <code>next</code> 。 </p><p>当玩家到达编号 $n_2$ 的方格时，游戏结束。</p><p><code>r</code> 行 <code>c</code> 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 <code>board[r][c] != -1</code>，那个蛇或梯子的目的地将会是 <code>board[r][c]</code>。编号为 <code>1</code> 和 $n_2$ 的方格不是任何蛇或梯子的起点。</p><p>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 <strong>不能</strong> 继续移动。</p><p>举个例子，假设棋盘是 <code>[[-1,4],[-1,3]]</code> ，第一次移动，玩家的目标方格是 <code>2</code> 。那么这个玩家将会顺着梯子到达方格 <code>3</code> ，但 <strong>不能</strong> 顺着方格 3 上的梯子前往方格 <code>4</code> 。<br>返回达到编号为 $n_2$ 的方格所需的最少移动次数，如果不可能，则返回 <code>-1</code>。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2018/09/23/snakes.png" alt="909.1"></p><pre><code class="hljs">输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]输出：4解释：首先，从方格 1 [第 5 行，第 0 列] 开始。 先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 最后决定移动到方格 36 , 游戏结束。 可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。 </code></pre><p>示例 2：</p><pre><code class="hljs">输入：board = [[-1,-1],[-1,3]]输出：1</code></pre><p>提示：</p><p><code>n == board.length == board[i].length</code></p><p><code>2 &lt;= n &lt;= 20</code></p><p><code>board[i][j]</code> 的值是 <code>-1</code> 或在范围 <code>[1, n2]</code> 内</p><p>编号为 <code>1</code> 和 $n_2$ 的方格上没有蛇或梯子</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里我的想法是先对棋盘进行处理，后续就不用管奇偶行怎么变化了。</p><p>然后用一个 <code>snake</code> 参数来存储棋盘中有效位置和其映射，这个主要是用于对梯子和蛇进行标记。</p><p>循环部分符合BFS的模板就不多说了，直接看代码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">snakesAndLadders</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        snt = []<br>        <span class="hljs-keyword">for</span> j, bd <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(board[::-<span class="hljs-number">1</span>]):<br>            snt.append(bd <span class="hljs-keyword">if</span> j % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> bd[::-<span class="hljs-number">1</span>])<br>        snake = &#123;&#125;<br>        n = <span class="hljs-built_in">len</span>(board)<br>        <br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                cur = n * x + y + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> snt[x][y] != -<span class="hljs-number">1</span>:<br>                    snake[cur] = snt[x][y]<br>        start = &#123;<span class="hljs-number">1</span>&#125;<br>        visited = &#123;<span class="hljs-number">1</span>&#125;<br>        step = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> start:<br>            <span class="hljs-built_in">next</span> = <span class="hljs-built_in">set</span>()<br>            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> start:<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>):<br>                    newnum = num + j<br>                    <span class="hljs-keyword">if</span> newnum <span class="hljs-keyword">in</span> snake:<br>                        newnum = snake[newnum]<br>                    <span class="hljs-keyword">if</span> newnum == n * n:<br>                        <span class="hljs-keyword">return</span> step<br>                    <span class="hljs-keyword">if</span> newnum <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>                        <span class="hljs-built_in">next</span>.add(newnum)<br>                        visited.add(newnum)<br>            step += <span class="hljs-number">1</span><br>            start = <span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n²)，空间复杂度O(n²)，执行时间65ms，消耗内存16.6MB</p><h1 id="433-最小基因变化-Medium"><a href="#433-最小基因变化-Medium" class="headerlink" title="433 最小基因变化 Medium"></a>433 最小基因变化 <font color=#ff7f50 size=4>Medium</font></h1><p>基因序列可以表示为一条由 <code>8</code> 个字符组成的字符串，其中每个字符都是 <code>&#39;A&#39;</code>、<code>&#39;C&#39;</code>、<code>&#39;G&#39;</code> 和 <code>&#39;T&#39;</code> 之一。</p><p>假设我们需要调查从基因序列 <code>start</code> 变为 <code>end</code> 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。</p><p>例如，<code>&quot;AACCGGTT&quot; --&gt; &quot;AACCGGTA&quot;</code> 就是一次基因变化。<br>另有一个基因库 <code>bank</code> 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 <code>bank</code> 中）</p><p>给你两个基因序列 <code>start</code> 和 <code>end</code> ，以及一个基因库 <code>bank</code> ，请你找出并返回能够使 <code>start</code> 变化为 <code>end</code> 所需的最少变化次数。如果无法完成此基因变化，返回 <code>-1</code> 。</p><p>注意：起始基因序列 <code>start</code> 默认是有效的，但是它并不一定会出现在基因库中。</p><p>示例 1：</p><pre><code class="hljs">输入：start = &quot;AACCGGTT&quot;, end = &quot;AACCGGTA&quot;, bank = [&quot;AACCGGTA&quot;]输出：1</code></pre><p>示例 2：</p><pre><code class="hljs">输入：start = &quot;AACCGGTT&quot;, end = &quot;AAACGGTA&quot;, bank = [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]输出：2</code></pre><p>示例 3：</p><pre><code class="hljs">输入：start = &quot;AAAAACCC&quot;, end = &quot;AACCCCCC&quot;, bank = [&quot;AAAACCCC&quot;,&quot;AAACCCCC&quot;,&quot;AACCCCCC&quot;]输出：3</code></pre><p>提示：</p><p><code>start.length == 8</code></p><p><code>end.length == 8</code></p><p><code>0 &lt;= bank.length &lt;= 10</code></p><p><code>bank[i].length == 8</code></p><p><code>start</code>、<code>end</code> 和 <code>bank[i]</code> 仅由字符 <code>[&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;]</code> 组成</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先排除我们 <code>end</code> 和 <code>bank</code> 不匹配的情况。然后后续我们进行匹配，只需要ACGT里面匹配到就可以构建新的 <code>gene</code> 同时我们需要判断 <code>gene</code> 是否在 <code>bank</code> 中，只要在里面就一个添加一个删除。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minMutation</span>(<span class="hljs-params">self, startGene: <span class="hljs-built_in">str</span>, endGene: <span class="hljs-built_in">str</span>, bank: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> endGene <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> bank:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        bank = <span class="hljs-built_in">set</span>(bank)<br>        queue = deque([startGene])<br>        step = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> queue:<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                gene = queue.popleft()<br>                <span class="hljs-keyword">if</span> gene == endGene:<br>                    <span class="hljs-keyword">return</span> step<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(gene)):<br>                    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;ACGT&#x27;</span>:<br>                        <span class="hljs-keyword">if</span> c == gene[i]:<br>                            <span class="hljs-keyword">continue</span><br>                        new_gene = gene[ : i] + c + gene[i + <span class="hljs-number">1</span>:]<br>                        <span class="hljs-keyword">if</span> new_gene <span class="hljs-keyword">in</span> bank:<br>                            queue.append(new_gene)<br>                            bank.remove(new_gene)<br>            step += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n²)，空间复杂度O(n²)，执行时间41ms，消耗内存16.5MB</p><h1 id="127-单词接龙-Hard"><a href="#127-单词接龙-Hard" class="headerlink" title="127 单词接龙 Hard"></a>127 单词接龙 <font color=#ff0000 size=4>Hard</font></h1><p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列 <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code>：</p><p>每一对相邻的单词只差一个字母。</p><p> 对于 <code>1 &lt;= i &lt;= k</code> 时，每个 <code>si</code> 都在 <code>wordList</code> 中。注意， <code>beginWord</code> 不需要在 <code>wordList</code> 中。</p><p><code>sk == endWord</code></p><p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> 和一个字典 <code>wordList</code> ，返回 从 <code>beginWord</code> 到 endWord 的 <em><strong>最短转换序列</strong></em> 中的 <em><strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回 <code>0</code> 。</p><p>示例 1：</p><pre><code class="hljs">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]输出：5解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</code></pre><p>示例 2：</p><pre><code class="hljs">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]输出：0解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</code></pre><p>提示：</p><p><code>1 &lt;= beginWord.length &lt;= 10</code></p><p><code>endWord.length == beginWord.length</code></p><p><code>1 &lt;= wordList.length &lt;= 5000</code></p><p><code>wordList[i].length == beginWord.length</code></p><p><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</p><p><code>beginWord != endWord</code></p><p><code>wordList</code> 中的所有字符串 <strong>互不相同</strong></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>和上一题几乎一模一样，把元素从ACGT改为26个字母，step初始化为1（因为步数在计算的时候是不包括最开始的变量本身，所以初始化为1）。最后把没匹配到的从-1改为0，搞定。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">ladderLength</span>(<span class="hljs-params">self, beginWord: <span class="hljs-built_in">str</span>, endWord: <span class="hljs-built_in">str</span>, wordList: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> endWord <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> wordList:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        word = <span class="hljs-built_in">set</span>(wordList)<br>        queue = deque([beginWord])<br>        step = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> queue:<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                gene = queue.popleft()<br>                <span class="hljs-keyword">if</span> gene == endWord:<br>                    <span class="hljs-keyword">return</span> step<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(gene)):<br>                    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>:<br>                        <span class="hljs-keyword">if</span> c == gene[i]:<br>                            <span class="hljs-keyword">continue</span><br>                        new_gene = gene[ : i] + c + gene[i + <span class="hljs-number">1</span>:]<br>                        <span class="hljs-keyword">if</span> new_gene <span class="hljs-keyword">in</span> word:<br>                            queue.append(new_gene)<br>                            word.remove(new_gene)<br>            step += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n²)，空间复杂度O(n²)，执行时间373ms，消耗内存17.1MB</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;909-蛇形棋-Medium&quot;&gt;&lt;a href=&quot;#909-蛇形棋-Medium&quot; class=&quot;headerlink&quot; title=&quot;909 蛇形棋 Medium&quot;&gt;&lt;/a&gt;909 蛇形棋 &lt;font color=#ff7f50 size=4&gt;Medium&lt;/f</summary>
      
    
    
    
    <category term="刷题记录" scheme="https://lx02918.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Leetcode" scheme="https://lx02918.github.io/tags/Leetcode/"/>
    
    <category term="刷题" scheme="https://lx02918.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="图" scheme="https://lx02918.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>京东笔试——算法工程师第三批</title>
    <link href="https://lx02918.github.io/2024/08/26/%E4%BA%AC%E4%B8%9C%E7%AC%94%E8%AF%95/"/>
    <id>https://lx02918.github.io/2024/08/26/%E4%BA%AC%E4%B8%9C%E7%AC%94%E8%AF%95/</id>
    <published>2024-08-26T07:58:44.000Z</published>
    <updated>2024-08-26T09:18:41.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><p>给你一个整数，请你判断0 ~ N之间有多少个数是100的正整数倍。</p><p><strong>输入描述</strong>：</p><p>输入的第一行给出一个整数N 输出描述：输出0~N之间有多少个数是100的整数倍。</p><p><strong>输出描述</strong>：</p><p>输出0 ~ N之间有多少个数是100的整数倍。</p><p>示例1：</p><p>输入：2000</p><p>输出：20</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>签到题，直接用 <code>N</code> 去掉最后两位就可以，能够避免出现负数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_multiples_of_100</span>(<span class="hljs-params">N</span>):<br>    N = <span class="hljs-built_in">int</span>(N)<br>    <br>    <span class="hljs-keyword">if</span> N &lt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <br>    N_str = <span class="hljs-built_in">str</span>(N)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(N_str) &lt; <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    result = <span class="hljs-built_in">int</span>(N_str[:-<span class="hljs-number">2</span>])<br>    <br>    <span class="hljs-keyword">return</span> result<br><br>N = <span class="hljs-built_in">input</span>().strip()<br><span class="hljs-built_in">print</span>(count_multiples_of_100(N))<br></code></pre></td></tr></table></figure><h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><p>给定一个大小为 <code>n * m</code> 的网格板，网格板是由 <code>n * m</code> 个 <code>1 * 1</code> 的单元格组成，最初所有单元格都是 <strong>白色</strong> 的；现在给出K个操作：</p><p>$c x y$ 将位置为$(x, y)$ 的单元格涂成黑色</p><p>$l x y$ 将位置为 $(x, y)$ 的单元格向左寻找第一个白色单元格，将其涂成黑色</p><p>$r x y$ 将位置为 $(x, y)$ 的单元格向右寻找第一个白色单元格，将其涂成黑色</p><p>$u x y$ 将位置为 $(x, y)$ 的单元格向上寻找第一个白色单元格，将其涂成黑色</p><p>$d x y$ 将位置为 $(x, y)$ 的单元格向下寻找第一个白色单元格，将其涂成黑色</p><p>注意：网格板左上角的单元格是 $(1, 1)$</p><p><strong>输入描述</strong>：<br>第一行给定 <code>n, m, k</code> 分别代表网格板大小和操作次数</p><p>后续给出为每次操作的命令 $s_i, x_i, y_i$</p><p>1 &lt;&#x3D; n, m &lt;&#x3D; 100</p><p>1 &lt;&#x3D; k &lt;&#x3D; $10^4$<br>1 &lt;&#x3D; $x_i, y_i$ &lt;&#x3D; $n, m$</p><p><strong>输出描述</strong>：</p><p>对于以 <code>l, r, u, d</code> 为操作的给出对应的坐标。没有坐标输出 <code>-1</code>。</p><p>示例1：</p><p>输入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">5</span> <span class="hljs-number">5</span> <span class="hljs-number">20</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">r</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">u</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">l</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">u</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">r</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">d</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">d</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1</span><br>3 2<br>4 3<br><span class="hljs-deletion">-1</span><br>1 2<br>4 3<br>5 4<br></code></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>初始化网格之后我们需要将所有元素初始化为False。</p><p>定义一个函数 <code>find</code> ，借助这个函数对x， y进行操作。需要使用到两个方向增量 d1, d2。</p><p>跳出条件为到达边界或找到未占位的我位置。</p><p>操作上按照四个方向进行操作，同时遇到 <code>c</code> 直接变为 True</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [[<span class="hljs-literal">False</span>] * <span class="hljs-number">105</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">105</span>)]<br><br>n, m, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x, y, d1, d2</span>):<br>    x += d1<br>    y += d2<br>    <span class="hljs-keyword">while</span> y &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> y &lt;= m <span class="hljs-keyword">and</span> x &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> x &lt;= m:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> a[x][y]:<br>            <span class="hljs-built_in">print</span>(x, y)<br>            <span class="hljs-keyword">return</span><br>        x += d1<br>        y += d2<br>    <span class="hljs-built_in">print</span>(-<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>    op, x, y = <span class="hljs-built_in">input</span>().split()<br>    x, y = <span class="hljs-built_in">int</span>(x), <span class="hljs-built_in">int</span>(y)<br>    d1, d2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;c&#x27;</span>:<br>        a[x][y] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;l&#x27;</span>:<br>        d2 = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;r&#x27;</span>:<br>        d2 = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;u&#x27;</span>:<br>        d1 = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;d&#x27;</span>:<br>        d1 = <span class="hljs-number">1</span><br>    find(x, y, d1, d2)<br></code></pre></td></tr></table></figure><h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><p>有 <code>n</code> 根木棍排成一列，第 <code>i</code> 根木棍的长度为 $a_i$ 。</p><p>请你从中选出一个最长的子区间，使得区间内任意三根木棍都能构成一个三角形。只需要输出选中的区间端点即可。</p><p><strong>输入描述</strong>：</p><p>第一行整数 <code>n</code> ，表示木棍的数量</p><p>第二行n个整数 第 $i$ 个整数 $a_i$ ，表示第 $i$ 根木棍的长度</p><p><strong>输出描述</strong>：<br>输出两个整数，表示最长的满足条件的区间的两个端点，如果有多个满足条件的，输出左端点最小的区间。</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>区间直接考虑到我们的滑动窗口。</p><p>首先固定好我们滑动窗口的两个边界，然后不断进行遍历，更新最大长度。滑动窗口内需要在 最小值 + 次小值 &lt;&#x3D; 最大时对右侧边界进行操作。这里我们获取最小值和次小值的方法是借助了 <code>SortedList()</code>。在更新后记录边界，最后输出即可。</p><p>这题的关键点就在于滑动窗口和有序集合，有序集合可以大大减少我们的代码量。</p><p>这里举我自己的反例，我当时由于太紧张，直接考虑到指针了，虽然考虑到 <code>sort()</code> 去排序，但是我后续的思路错了，结果这道题就失误了。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sortedcontainers <span class="hljs-keyword">import</span> SortedList<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_longest_subarray</span>(<span class="hljs-params">n, sticks</span>):<br>    S = SortedList()<br>    r = n<br>    ansl, ansr = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><br>    <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> r &lt; ansr - ansl:<br>            <span class="hljs-keyword">break</span><br><br>        S.add(sticks[l - <span class="hljs-number">1</span>])<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(S) &lt; <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">continue</span><br><br>        min1 = S[<span class="hljs-number">0</span>]<br>        min2 = S[<span class="hljs-number">1</span>]<br>        maxx = S[-<span class="hljs-number">1</span>]<br><br>        <span class="hljs-keyword">while</span> min1 + min2 &lt;= maxx:<br>            S.remove(sticks[r - <span class="hljs-number">1</span>])<br>            r -= <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(S) &lt; <span class="hljs-number">3</span>:<br>                <span class="hljs-keyword">break</span><br><br>            min1 = S[<span class="hljs-number">0</span>]<br>            min2 = S[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> sticks[r] == maxx:<br>                maxx = S[-<span class="hljs-number">1</span>]<br><br>        <span class="hljs-keyword">if</span> r - l &gt;= ansr - ansl:<br>            ansl, ansr = l, r<br><br>    <span class="hljs-built_in">print</span>(ansl, ansr)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>().strip())<br>    sticks = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split()))<br>    find_longest_subarray(n, sticks)<br></code></pre></td></tr></table></figure><p>这里还是想说我自己刷题数量还是太少了，还得努力啊，到现在这么些场有些思路上再后来反思时是对的，但复看自己的代码会发现在实现上还是存在问题。不过也没有出现暑期实习的时候输入输出出问题的低级错误了🤣当时因为输入输出好几次明明核心部分都是对的结果过不去，还是那句话，菜就多练🤣</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h1&gt;&lt;p&gt;给你一个整数，请你判断0 ~ N之间有多少个数是100的正整数倍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入描述&lt;/strong&gt;：&lt;/p</summary>
      
    
    
    
    <category term="笔试记录" scheme="https://lx02918.github.io/categories/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="笔试" scheme="https://lx02918.github.io/tags/%E7%AC%94%E8%AF%95/"/>
    
    <category term="算法题" scheme="https://lx02918.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题记录——图</title>
    <link href="https://lx02918.github.io/2024/08/22/leetcode-%E5%9B%BE/"/>
    <id>https://lx02918.github.io/2024/08/22/leetcode-%E5%9B%BE/</id>
    <published>2024-08-22T01:59:38.000Z</published>
    <updated>2024-08-29T06:48:49.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="200-岛屿数量-Medium"><a href="#200-岛屿数量-Medium" class="headerlink" title="200 岛屿数量 Medium"></a>200 岛屿数量 <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1：</p><pre><code class="hljs">输入：grid = [[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]]输出：1</code></pre><p>示例 2：</p><pre><code class="hljs">输入：grid = [[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]输出：3</code></pre><p>提示：</p><p><code>m == grid.length</code></p><p><code>n == grid[i].length</code></p><p><code>1 &lt;= m, n &lt;= 300</code></p><p><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>解决矩阵搜索问题通常直接使用DFS去做。</p><p>这道题的通用思路就是对整个矩阵进行遍历，当遇到 <code>grid[i][j]</code> 的时候开始DFS，将周围所有的 <code>1</code> 都置为 <code>0</code>，这样就能找到所有的岛屿。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numIslands</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> grid: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        m, n = <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, j</span>):<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= m <span class="hljs-keyword">or</span> j &gt;= n <span class="hljs-keyword">or</span> grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <br>            grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span><br>            <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> (i+<span class="hljs-number">1</span>,j),(i-<span class="hljs-number">1</span>,j),(i,j+<span class="hljs-number">1</span>),(i,j-<span class="hljs-number">1</span>):<br>                dfs(x, y)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                    dfs(i, j)<br>                    res += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(m * n)，空间复杂度O(m * n)，执行时间248ms，消耗内存18.6MB</p><h1 id="130-被围绕的区域-Medium"><a href="#130-被围绕的区域-Medium" class="headerlink" title="130 被围绕的区域 Medium"></a>130 被围绕的区域 <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> 组成，捕获 <strong>所有</strong> 被围绕的区域：</p><p><strong>连接</strong>：一个单元格与水平或垂直方向上相邻的单元格连接。</p><p><strong>区域</strong>：连接所有 <code>&#39;O&#39;</code> 的单元格来形成一个区域。</p><p><strong>围绕</strong>：如果您可以用 <code>&#39;X&#39;</code> 单元格 连接这个区域，并且区域中没有任何单元格位于 board<br>边缘，则该区域被 <code>&#39;X&#39;</code> 单元格围绕。</p><p>通过将输入矩阵 <code>board</code> 中的所有 <code>&#39;O&#39;</code> 替换为 <code>&#39;X&#39;</code> 来 捕获被围绕的区域。</p><p>示例 1：</p><pre><code class="hljs">输入：board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]输出：[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</code></pre><p>解释：</p><figure>  <img src="/2024/08/22/leetcode-%E5%9B%BE/130_1.png" class="" title="130.1">  <figcaption>130.1</figcaption></figure><p>在上图中，底部的区域没有被捕获，因为它在 board 的边缘并且不能被围绕。</p><p>示例 2：</p><pre><code class="hljs">输入：board = [[&quot;X&quot;]]输出：[[&quot;X&quot;]]</code></pre><p>提示：</p><p><code>m == board.length</code></p><p><code>n == board[i].length</code></p><p><code>1 &lt;= m, n &lt;= 200</code></p><p><code>board[i][j]</code> 为 <code>&#39;X&#39;</code> 或 <code>&#39;O&#39;</code>   </p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>核心思路和前一题一样，都是先对整个矩阵进行遍历，遇到我们符合条件的先将其进行标记。</p><p>这里需要注意的是，我们是将周围没有 <code>O</code> 的标记为 <code>?</code>，而后面将剩余的<code>O</code>全部标记为 <code>X</code>。同时也要注意我们是先标记为 <code>X</code> 后将 <code>?</code> 还原为 <code>O</code>，不然会导致结果错误。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>这里给出两个版本的代码，思路是一样的，一个是我之前写的，一个是我现在写的。</p><p>第一版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board:<span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, j</span>):<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= m <span class="hljs-keyword">or</span> j &gt;= n <span class="hljs-keyword">or</span> board[i][j] != <span class="hljs-string">&#x27;O&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <br>            board[i][j] = <span class="hljs-string">&#x27;B&#x27;</span><br>            <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> (i + <span class="hljs-number">1</span>), (i - <span class="hljs-number">1</span>), (i, j + <span class="hljs-number">1</span>), (i, j - <span class="hljs-number">1</span>):<br>                dfs(x, y)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">if</span> board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                dfs(i, <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> board[i][n - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                dfs(i, n - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> board[<span class="hljs-number">0</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                dfs(<span class="hljs-number">0</span>, j)<br>            <span class="hljs-keyword">if</span> board[m - <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                dfs(m - <span class="hljs-number">1</span>, j)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span><br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;B&#x27;</span>:<br>                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span><br></code></pre></td></tr></table></figure><p>第二版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">board, i, j</span>):<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= m <span class="hljs-keyword">or</span> j &gt;= n <span class="hljs-keyword">or</span> board[i][j] != <span class="hljs-string">&#x27;O&#x27;</span>:<br>                <span class="hljs-keyword">return</span><br>            board[i][j] = <span class="hljs-string">&#x27;?&#x27;</span><br>            dfs(board, i + <span class="hljs-number">1</span>, j)<br>            dfs(board, i - <span class="hljs-number">1</span>, j)<br>            dfs(board, i, j + <span class="hljs-number">1</span>)<br>            dfs(board, i, j - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i == m - <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> j == n - <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                        dfs(board, i, j)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span><br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;?&#x27;</span>:<br>                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>第一版时间复杂度O(m * n)，空间复杂度O(min(m, n))，执行时间40ms，消耗内存20.3MB<br>第二版时间复杂度O(m * n)，空间复杂度O(min(m, n))，执行时间54ms，消耗内存20.3MB</p><h1 id="133-克隆图-Medium"><a href="#133-克隆图-Medium" class="headerlink" title="133 克隆图 Medium"></a>133 克隆图 <font color=#ff7f50 size=4>Medium</font></h1><p>给你无向 <a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995?fr=aladdin">连通</a> 图中一个节点的引用，请你返回该图的 <a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a>（克隆）。</p><p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    public <span class="hljs-keyword">int</span> val;<br>    public List&lt;Node&gt; neighbors;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试用例格式：</p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p><p>邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。</p><p>示例 1：</p><figure>  <img src="/2024/08/22/leetcode-%E5%9B%BE/133_1.png" class="" title="133.1">  <figcaption>133.1</figcaption></figure><pre><code class="hljs">输入：adjList = [[2,4],[1,3],[2,4],[1,3]]输出：[[2,4],[1,3],[2,4],[1,3]]解释：图中有 4 个节点。节点 1 的值是 1，它有两个邻居：节点 2 和 4 。节点 2 的值是 2，它有两个邻居：节点 1 和 3 。节点 3 的值是 3，它有两个邻居：节点 2 和 4 。节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/22/leetcode-%E5%9B%BE/133_2.png" class="" title="133.2">  <figcaption>133.2</figcaption></figure><pre><code class="hljs">输入：adjList = [[]]输出：[[]]解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</code></pre><p>示例 3：</p><pre><code class="hljs">输入：adjList = []输出：[]解释：这个图是空的，它不含任何节点。</code></pre><p>提示：</p><p>这张图中的节点数在 <code>[0, 100]</code> 之间。</p><p><code>1 &lt;= Node.val &lt;= 100</code></p><p>每个节点值 <code>Node.val</code> 都是唯一的，</p><p>图中没有重复的边，也没有自环。</p><p>图是连通图，你可以从给定节点访问到所有节点。</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>简单来说就是使用一个 <code>DFS</code> 去遍历每个节点，然后将每个节点的值都拷贝过来。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cloneGraph</span>(<span class="hljs-params">self, node: <span class="hljs-type">Optional</span>[<span class="hljs-string">&#x27;Node&#x27;</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[<span class="hljs-string">&#x27;Node&#x27;</span>]:<br>        oldToNew = &#123;<span class="hljs-literal">None</span>: <span class="hljs-literal">None</span>&#125;<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">in</span> oldToNew:<br>                <span class="hljs-keyword">return</span> oldToNew[node]<br>            copy = Node(node.val)<br>            oldToNew[node] = copy<br>            <span class="hljs-keyword">for</span> nei <span class="hljs-keyword">in</span> node.neighbors:<br>                copy.neighbors.append(dfs(nei))<br>            <span class="hljs-keyword">return</span> copy<br>        <span class="hljs-keyword">return</span> dfs(node) <span class="hljs-keyword">if</span> node <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(V + E)，空间复杂度O(E)，执行时间44ms，消耗内存16.5MB</p><h1 id="399-除法求值-Medium"><a href="#399-除法求值-Medium" class="headerlink" title="399 除法求值 Medium"></a>399 除法求值 <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code> 共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或 <code>Bi</code> 是一个表示单个变量的字符串。</p><p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code> 的结果作为答案。</p><p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 <code>-1.0</code> 替代这个答案。</p><p>注意：输入总是有效的。你可以假设除法运算中不会出现除数为 <code>0</code> 的情况，且不存在任何矛盾的结果。</p><p>注意：未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。</p><p>示例 1：</p><pre><code class="hljs">输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]解释：条件：a / b = 2.0, b / c = 3.0问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]注意：x 是未定义的 =&gt; -1.0</code></pre><p>示例 2：</p><pre><code class="hljs">输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]输出：[3.75000,0.40000,5.00000,0.20000]示例 3：输入：equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]输出：[0.50000,2.00000,-1.00000,-1.00000]</code></pre><p>提示：</p><p><code>1 &lt;= equations.length &lt;= 20</code></p><p><code>equations[i].length == 2</code></p><p><code>1 &lt;= Ai.length, Bi.length &lt;= 5</code></p><p><code>values.length == equations.length</code></p><p><code>0.0 &lt; values[i] &lt;= 20.0</code></p><p><code>1 &lt;= queries.length &lt;= 20</code></p><p><code>queries[i].length == 2</code></p><p><code>1 &lt;= Cj.length, Dj.length &lt;= 5</code></p><p><code>Ai, Bi, Cj, Dj</code> 由小写英文字母与数字组成</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这题首先需要搞明白两个节点之间我们要怎么去算，按照数学逻辑来看我们已知 <code>a:b</code> <code>b:c</code>，我们相乘就可以得到 <code>a:c</code>。并且要得到自身到自身的值，也就是1.0。同时还需要得到当 <code>x</code> 不在我们输入的 <code>equations</code> 中的情况，所以我们的结果需要用 <code>-1.0</code> 直接填充。</p><p>明白了数理逻辑就可以直接开写，这里我们将直接转换为一个有向图，然后用BFS去做。构建图的部分直接看代码，我们重点说一下处理查询的部分。</p><p>对于我们的查询我们可以使用 <code>qx</code> and <code>qy</code> 去辅助完成，即找到 <code>qx</code> 到 <code>qy</code> 的路径并计算得到权值，如果找到了就会被添加到ans表中。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calcEquation</span>(<span class="hljs-params">self, equations: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]], values: <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>], queries: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>]:<br>        <span class="hljs-comment"># 图结构构建</span><br>        graph = &#123;&#125;<br>        <span class="hljs-keyword">for</span> (s, e), v <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(equations, values):<br>            <span class="hljs-keyword">if</span> s <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph:<br>                graph[s] = &#123;&#125; <span class="hljs-comment"># 存储neighbor的hash</span><br>            graph[s][e] = v<br>            <span class="hljs-keyword">if</span> e <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph:<br>                graph[e] = &#123;&#125;<br>            graph[e][s] = <span class="hljs-number">1</span> / v<br>            graph[s][s] = <span class="hljs-number">1.0</span><br>            graph[e][e] = <span class="hljs-number">1.0</span><br>        queue = [] <span class="hljs-comment"># BFS的队列</span><br>        n = <span class="hljs-built_in">len</span>(queries)<br>        ans = [-<span class="hljs-number">1.0</span>] * n<br>        <br>        <span class="hljs-comment"># 找最短路径</span><br>        <span class="hljs-keyword">for</span> i, (qx, qy) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(queries):<br>            <span class="hljs-keyword">if</span> qx <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph <span class="hljs-keyword">or</span> qy <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph: <span class="hljs-keyword">continue</span> <span class="hljs-comment"># x不在graph里面就跳过</span><br>            queue = [[qx, <span class="hljs-number">1.0</span>]] <span class="hljs-comment"># start</span><br>            visited = <span class="hljs-built_in">set</span>([qx]) <span class="hljs-comment"># 存储已经处理过的</span><br>            <span class="hljs-keyword">while</span> queue:<br>                node, mul = queue.pop(<span class="hljs-number">0</span>)<br>                <span class="hljs-comment"># 枚举并处理节点</span><br>                <span class="hljs-keyword">for</span> neighbor, weight <span class="hljs-keyword">in</span> graph[node].items():<br>                    <span class="hljs-keyword">if</span> neighbor == qy:<br>                        ans[i] = mul * weight<br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>                        visited.add(neighbor)<br>                        queue.append([neighbor, mul * weight])<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(V + E + Q)，空间复杂度O(V + E + Q)，执行时间42ms，消耗内存16.53</p><p>其中 <code>V</code> 表示节点数量， <code>E</code> 表示边的数量， <code>Q</code> 表示查询的数量。</p><h1 id="207-课程表-Medium"><a href="#207-课程表-Medium" class="headerlink" title="207 课程表 Medium"></a>207 课程表 <font color=#ff7f50 size=4>Medium</font></h1><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p><p>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>示例 1：</p><pre><code class="hljs">输入：numCourses = 2, prerequisites = [[1,0]]输出：true解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</code></pre><p>示例 2：</p><pre><code class="hljs">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]输出：false解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</code></pre><p>提示：</p><p><code>1 &lt;= numCourses &lt;= 2000</code></p><p><code>0 &lt;= prerequisites.length &lt;= 5000</code></p><p><code>prerequisites[i].length == 2</code></p><p><code>0 &lt;= ai, bi &lt; numCourses</code></p><p><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>我们使用一个入度数组和一个邻接表来完成这个题目。</p><p>首先完成入度数组和邻接表的遍历。接下来使用拓扑排序去完成排序，借助一个队列。</p><p>这里需要注意，我们的入度为0的时候就需要将其加入队列，最终如果没有数了，就表示我们这个图是没有环的，也就是课程表能够完成学习。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canFinish</span>(<span class="hljs-params">self, numCourses: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 初始化入度数组和邻接表</span><br>        in_degree = [<span class="hljs-number">0</span>] * numCourses<br>        adjacency = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses)]<br>        <br>        <span class="hljs-comment"># 构建邻接表和入度数组</span><br>        <span class="hljs-keyword">for</span> cur, pre <span class="hljs-keyword">in</span> prerequisites:<br>            adjacency[pre].append(cur)<br>            in_degree[cur] += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># 初始化队列，将所有入度为0的节点加入队列</span><br>        queue = deque()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>            <span class="hljs-keyword">if</span> in_degree[i] == <span class="hljs-number">0</span>:<br>                queue.append(i)<br>        <br>        <span class="hljs-comment"># 拓扑排序</span><br>        <span class="hljs-keyword">while</span> queue:<br>            node = queue.popleft()<br>            numCourses -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> adjacency[node]:<br>                in_degree[neighbor] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> in_degree[neighbor] == <span class="hljs-number">0</span>:<br>                    queue.append(neighbor)<br>        <br>        <span class="hljs-comment"># 如果所有节点都被访问过，说明没有环，可以完成所有课程</span><br>        <span class="hljs-keyword">return</span> numCourses == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(V + E)，空间复杂度O(V + E)，执行时间42ms，消耗内存17.5MB</p><h1 id="210-课程表-II-Medium"><a href="#210-课程表-II-Medium" class="headerlink" title="210 课程表 II Medium"></a>210 课程表 II <font color=#ff7f50 size=4>Medium</font></h1><p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code> 到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程 <code>ai</code> 前 <strong>必须</strong> 先选修 <code>bi</code> 。</p><p>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。<br>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p><p>示例 1：</p><pre><code class="hljs">输入：numCourses = 2, prerequisites = [[1,0]]输出：[0,1]解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</code></pre><p>示例 2：</p><pre><code class="hljs">输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]输出：[0,2,1,3]解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</code></pre><p>示例 3：</p><pre><code class="hljs">输入：numCourses = 1, prerequisites = []输出：[0]</code></pre><p>提示：</p><p><code>1 &lt;= numCourses &lt;= 2000</code></p><p><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></p><p><code>prerequisites[i].length == 2</code></p><p><code>0 &lt;= ai, bi &lt; numCourses</code></p><p><code>ai != bi</code></p><p>所有<code>[ai, bi]</code> <strong>互不相同</strong></p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>整体上和前一道题几乎一模一样，唯独需要一个 <code>res</code> 来装我们从 <code>queue</code> 里 <code>pop</code> 出来的变量。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findOrder</span>(<span class="hljs-params">self, numCourses: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        in_degree = [<span class="hljs-number">0</span>] * numCourses<br>        adjacency = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses)]<br>        <br>        <span class="hljs-keyword">for</span> cur, pre <span class="hljs-keyword">in</span> prerequisites:<br>            adjacency[pre].append(cur)<br>            in_degree[cur] += <span class="hljs-number">1</span><br>            <br>        queue = deque()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>            <span class="hljs-keyword">if</span> in_degree[i] == <span class="hljs-number">0</span>:<br>                queue.append(i)<br>        res = []<br>        <span class="hljs-keyword">while</span> queue:<br>            node = queue.popleft()<br>            res.append(node)<br>            <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> adjacency[node]:<br>                in_degree[neighbor] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> in_degree[neighbor] == <span class="hljs-number">0</span>:<br>                    queue.append(neighbor)<br>        <span class="hljs-keyword">return</span> res <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == numCourses <span class="hljs-keyword">else</span> []<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(V + E)，空间复杂度O(V + E)，执行时间38ms，消耗内存17.6MB</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;200-岛屿数量-Medium&quot;&gt;&lt;a href=&quot;#200-岛屿数量-Medium&quot; class=&quot;headerlink&quot; title=&quot;200 岛屿数量 Medium&quot;&gt;&lt;/a&gt;200 岛屿数量 &lt;font color=#ff7f50 size=4&gt;Mediu</summary>
      
    
    
    
    <category term="刷题记录" scheme="https://lx02918.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Leetcode" scheme="https://lx02918.github.io/tags/Leetcode/"/>
    
    <category term="刷题" scheme="https://lx02918.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="图" scheme="https://lx02918.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题记录——二叉搜索树</title>
    <link href="https://lx02918.github.io/2024/08/21/leetcode-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://lx02918.github.io/2024/08/21/leetcode-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2024-08-21T07:47:07.000Z</published>
    <updated>2024-09-03T04:02:47.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="530-二叉搜索树的最小绝对差-Easy"><a href="#530-二叉搜索树的最小绝对差-Easy" class="headerlink" title="530 二叉搜索树的最小绝对差 Easy"></a>530 二叉搜索树的最小绝对差 <font color=#7fffd4 size=4>Easy</font></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题我们需要使用到二叉搜索树（BST）的一个特性：在二叉搜索树中，任意一个节点其左子树所有节点的值都小于该节点的值，其右子树所有节点的值都大于该结点的值。利用这个特性可以使得中序遍历按照从小到大的顺序访问树中所有的节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMinimumDifference</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                <span class="hljs-keyword">return</span><br>            dfs(node.left)<br>            <span class="hljs-variable language_">self</span>.res = <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.res, node.val - <span class="hljs-variable language_">self</span>.pre)<br>            <span class="hljs-variable language_">self</span>.pre = node.val<br>            dfs(node.right)<br><br>        <span class="hljs-variable language_">self</span>.res = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>.pre = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)<br>        dfs(root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间48ms，消耗内存18.4MB</p><h1 id="230-二叉搜索树中第K小的元素-Medium"><a href="#230-二叉搜索树中第K小的元素-Medium" class="headerlink" title="230 二叉搜索树中第K小的元素 Medium"></a>230 二叉搜索树中第K小的元素 <font color=#ff7f50 size=4>Medium</font></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>和前一题一样，直接利用BST的特性去做，这题会更直观的展示BST的特性的用法。</p><p>这题我自己写的和我看到的解法我都写在下面，本质上都是一样的。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthSmallest</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        stack = []<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">while</span> root:<br>                stack.append(root)<br>                root = root.left<br>            root = stack.pop()<br>            k -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> k:<br>                <span class="hljs-keyword">return</span> root.val<br>            root = root.right<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthSmallest</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.k == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span><br>            dfs(node.left)<br>            <span class="hljs-variable language_">self</span>.k -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.k == <span class="hljs-number">0</span>:<br>                <span class="hljs-variable language_">self</span>.ans = node.val<br>                <span class="hljs-keyword">return</span><br>            dfs(node.right)<br>        <span class="hljs-variable language_">self</span>.k = k<br>        dfs(root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ans<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthSmallest</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span><br>            dfs(root.left)<br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.k == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span><br>            <span class="hljs-variable language_">self</span>.k -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.k == <span class="hljs-number">0</span>: <span class="hljs-variable language_">self</span>.res = root.val<br>            dfs(root.right)<br>            <br>        <span class="hljs-variable language_">self</span>.k = k<br>        dfs(root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间52ms，消耗内存19.8MB</p><p>时间复杂度O(n)，空间复杂度O(n)，执行时间67ms，消耗内存19.8MB</p><p>时间复杂度O(n)，空间复杂度O(n)，执行时间44ms，消耗内存19.8MB</p><h1 id="98-验证二叉搜索树-Medium"><a href="#98-验证二叉搜索树-Medium" class="headerlink" title="98 验证二叉搜索树 Medium"></a>98 验证二叉搜索树 <font color=#ff7f50 size=4>Medium</font></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这道题需要引入两个边界，用于检验当前节点是否满足二叉搜索树的定义，其余和前面的思路一样</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node, l = <span class="hljs-built_in">float</span>(<span class="hljs-params"><span class="hljs-string">&#x27;-inf&#x27;</span></span>), r = <span class="hljs-built_in">float</span>(<span class="hljs-params"><span class="hljs-string">&#x27;inf&#x27;</span></span>)</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            pre = node.val<br>            <span class="hljs-keyword">if</span> pre &lt;= l <span class="hljs-keyword">or</span> pre &gt;= r:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(node.left, l, pre):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(node.right, pre, r):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> dfs(root)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间44ms，消耗内存18.5MB</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这几道题都涉及到了二叉搜索树的特性，利用BST的特性可以更好的解决问题。</p><p>所以和前一篇一样，我们针对这类题型也总结了模板</p><ol><li><p>中序遍历，适用于解决第k小，最小差值的问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>        <span class="hljs-keyword">return</span><br>    dfs(node.left)<br>    <span class="hljs-comment"># 处理当前节点</span><br>    dfs(node.right)<br></code></pre></td></tr></table></figure></li><li><p>递归，适用于判断是否为BST</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node, l, r</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">if</span> node.val &lt;= l <span class="hljs-keyword">or</span> node.val &gt;= r:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> dfs(node.left, l, node.val) <span class="hljs-keyword">and</span> dfs(node.right, node.val, r)<br></code></pre></td></tr></table></figure></li><li><p>栈，用于通过栈模拟中序遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">kthSmallest</span>(<span class="hljs-params">root, k</span>):<br>    stack = []<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">while</span> root:<br>            stack.append(root)<br>            root = root.left<br>        root = stack.pop()<br>        k -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> k:<br>            <span class="hljs-keyword">return</span> root.val<br>        root = root.right<br></code></pre></td></tr></table></figure></li></ol><p>不管怎么变，实际上都需要借助二叉搜索树的特性，借助特性就可以直接解决问题了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;530-二叉搜索树的最小绝对差-Easy&quot;&gt;&lt;a href=&quot;#530-二叉搜索树的最小绝对差-Easy&quot; class=&quot;headerlink&quot; title=&quot;530 二叉搜索树的最小绝对差 Easy&quot;&gt;&lt;/a&gt;530 二叉搜索树的最小绝对差 &lt;font colo</summary>
      
    
    
    
    <category term="刷题记录" scheme="https://lx02918.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Leetcode" scheme="https://lx02918.github.io/tags/Leetcode/"/>
    
    <category term="刷题" scheme="https://lx02918.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://lx02918.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题记录——二叉树层次遍历</title>
    <link href="https://lx02918.github.io/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>https://lx02918.github.io/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</id>
    <published>2024-08-20T06:43:25.000Z</published>
    <updated>2024-08-29T06:47:43.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="199-二叉树的右视图-Medium"><a href="#199-二叉树的右视图-Medium" class="headerlink" title="199 二叉树的右视图 Medium"></a>199 二叉树的右视图 <font color=#ff7f50 size=4>Medium</font></h1><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>示例 1:</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/199_1.jpg" class="" title="199.1">  <figcaption>199.1</figcaption></figure><pre><code class="hljs">输入: [1,2,3,null,5,null,4]输出: [1,3,4]</code></pre><p>示例 2:</p><pre><code class="hljs">输入: [1,null,3]输出: [1,3]</code></pre><p>示例 3:</p><pre><code class="hljs">输入: []输出: []</code></pre><p>提示:</p><p>二叉树的节点个数的范围是 <code>[0,100]</code></p><p><code>-100 &lt;= Node.val &lt;= 100 </code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里按照标题直接用DFS去遍历，保证我们首先处理的是右子树，这样遇到的第一个节点就会被压入。而当我们的有一层没有右子树的时候，就会将其左子树压入栈中。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rightSideView</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        res = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node, depth</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">if</span> depth == <span class="hljs-built_in">len</span>(res):<br>                res.append(node.val)<br>            dfs(node.right, depth + <span class="hljs-number">1</span>)<br>            dfs(node.left, depth + <span class="hljs-number">1</span>)<br>        dfs(root, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间41ms，消耗内存16.5MB</p><h1 id="637-二叉树的层平均值-Easy"><a href="#637-二叉树的层平均值-Easy" class="headerlink" title="637 二叉树的层平均值 Easy"></a>637 二叉树的层平均值 <font color=#7fffd4 size=4>Easy</font></h1><p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 $10^5$ 以内的答案可以被接受。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/637_1.jpg" class="" title="637.1">  <figcaption>637.1</figcaption></figure><pre><code class="hljs">输入：root = [3,9,20,null,null,15,7]输出：[3.00000,14.50000,11.00000]解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。因此返回 [3, 14.5, 11] 。</code></pre><p>示例 2:</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/637_2.jpg" class="" title="637.2">  <figcaption>637.2</figcaption></figure><pre><code class="hljs">输入：root = [3,9,20,15,7]输出：[3.00000,14.50000,11.00000]</code></pre><p>提示：</p><p>树中节点数量在 <code>[1, 104]</code> 范围内</p><p><code>-231 &lt;= Node.val &lt;= 231 - 1 </code></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>实际上就是每一层都需要被遍历到，当我们遇到有子节点的就把子节点存入 <code>childNode</code> 中然后再去走接下来的本层节点。后面把 <code>childNode</code> 导入我们最开始的全局变量 <code>queue</code> 中继续运行。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">averageOfLevels</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        res = []<br>        queue = [root]<br>        <span class="hljs-keyword">while</span> queue:<br>            <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>            childNode = []<br>            cnt = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> queue:<br>                <span class="hljs-built_in">sum</span> += node.val<br>            res.append(<span class="hljs-built_in">sum</span>/cnt)<br>            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> queue:<br>                <span class="hljs-keyword">if</span> node.left:<br>                    childNode.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    childNode.append(node.right)<br>            queue = childNode<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>由于第一个代码中while循环又套了两个for循环，速度太慢，我就简化了一下，只采用一个while加一个for，思路上是一样的，但注意具体的细节差异</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">averageOfLevels</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        res = []<br>        queue = [root]<br>        <span class="hljs-keyword">while</span> queue:<br>            <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>            cnt = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cnt):<br>                node = queue.pop(<span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">sum</span> += node.val<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>            res.append(<span class="hljs-built_in">sum</span>/cnt)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>第一个算法<br>时间复杂度O(n)，空间复杂度O(n)，执行时间66ms，消耗内存18.6MB<br>第二个算法<br>时间复杂度O(n^2)，空间复杂度O(n) + O(h)，执行时间41ms，消耗内存18.6MB</p><h1 id="102-二叉树的层序遍历-Medium"><a href="#102-二叉树的层序遍历-Medium" class="headerlink" title="102 二叉树的层序遍历 Medium"></a>102 二叉树的层序遍历 <font color=#ff7f50 size=4>Medium</font></h1><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/102_1.jpg" class="" title="102.1">  <figcaption>102.1</figcaption></figure><pre><code class="hljs">输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：root = [1]输出：[[1]]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：root = []输出：[]</code></pre><p>提示：</p><p>树中节点数目在范围 <code>[0, 2000]</code> 内</p><p><code>-1000 &lt;= Node.val &lt;= 1000</code></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>和前一题一样，按照题意的顺序遍历即可，只需要去掉计算平均值这个步骤就可以，用前议题已经优化后的思路会比第一种的更快（leetcode上能超越97.73%的人）</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        res = []<br>        queue = [root]<br>        <span class="hljs-keyword">while</span> queue:<br>            res.append([])<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                node = queue.pop(<span class="hljs-number">0</span>)<br>                res[-<span class="hljs-number">1</span>].append(node.val)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间29ms，消耗内存17.1MB</p><h1 id="103-二叉树的锯齿形层次遍历-Medium"><a href="#103-二叉树的锯齿形层次遍历-Medium" class="headerlink" title="103 二叉树的锯齿形层次遍历 Medium"></a>103 二叉树的锯齿形层次遍历 <font color=#ff7f50 size=4>Medium</font></h1><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>示例 1：</p> <figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/103_1.jpg" class="" title="103.1">  <figcaption>103.1</figcaption></figure><pre><code class="hljs">输入：root = [3,9,20,null,null,15,7]输出：[[3],[20,9],[15,7]]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：root = [1]输出：[[1]]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：root = []输出：[]</code></pre><p>提示：</p><p>树中节点数目在范围 <code>[0, 2000]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这题和前一道题唯一一个不同就在于对奇偶层的不同操作。当我们在处理这个时一个取余就可与做到，当奇数层时将节点正常进行添加，当偶数层时对节点值进行倒序添加。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">zigzagLevelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        res = []<br>        queue = [root]<br>        <span class="hljs-keyword">while</span> queue:<br>            res.append([])<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                node = queue.pop(<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>                    res[-<span class="hljs-number">1</span>].append(node.val)<br>                <span class="hljs-keyword">else</span>:<br>                    res[-<span class="hljs-number">1</span>].insert(<span class="hljs-number">0</span>, node.val)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间40ms，消耗内存16.6MB</p><h1 id="总结——层次遍历BFS模板"><a href="#总结——层次遍历BFS模板" class="headerlink" title="总结——层次遍历BFS模板"></a>总结——层次遍历BFS模板</h1><p>这四道题可以看出基本上都是一套思路，虽然第一题不太一样。</p><p>但看其余三道题可以看出都是同一个思路去做，在细微差别上进行部分修改添加条件。</p><p>模板如下</p><p>二叉树层次遍历(BFS)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">traversalTemplate</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[数据类型]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        <br>        res = []<br>        queue = [root]<br>        <br>        <span class="hljs-keyword">while</span> queue:<br>            <span class="hljs-comment"># 初始化本层的结果存储</span><br>            level = []<br>            <br>            <span class="hljs-comment"># 遍历当前层的所有节点</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                node = queue.pop(<span class="hljs-number">0</span>)<br>                <br>                <span class="hljs-comment"># 处理节点的值（可根据题目要求自定义处理方式）</span><br>                level.append(node.val)<br>                <br>                <span class="hljs-comment"># 将下一层的节点加入队列</span><br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>            <br>            <span class="hljs-comment"># 处理层结果（如果有特殊要求，可在这里进行处理）</span><br>            res.append(level)<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;199-二叉树的右视图-Medium&quot;&gt;&lt;a href=&quot;#199-二叉树的右视图-Medium&quot; class=&quot;headerlink&quot; title=&quot;199 二叉树的右视图 Medium&quot;&gt;&lt;/a&gt;199 二叉树的右视图 &lt;font color=#ff7f50 </summary>
      
    
    
    
    <category term="刷题记录" scheme="https://lx02918.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Leetcode" scheme="https://lx02918.github.io/tags/Leetcode/"/>
    
    <category term="刷题" scheme="https://lx02918.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://lx02918.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题记录——二叉树</title>
    <link href="https://lx02918.github.io/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://lx02918.github.io/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2024-08-20T05:11:42.000Z</published>
    <updated>2024-08-28T08:59:30.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="104-二叉树的最大深度-Easy"><a href="#104-二叉树的最大深度-Easy" class="headerlink" title="104. 二叉树的最大深度 Easy"></a>104. 二叉树的最大深度 <font color=#7fffd4 size=4>Easy</font></h1><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/104_1.jpg" class="" title="104.1">  <figcaption>104.1</figcaption></figure><pre><code class="hljs">输入：root = [3,9,20,null,null,15,7]输出：3</code></pre><p>示例 2：</p><pre><code class="hljs">输入：root = [1,null,2]输出：2</code></pre><p>提示：</p><p>树中节点的数量在 <code>[0, 104]</code> 区间内。</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题基本上没啥好说的🤣，就是两个maxDepth最后加个1</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-variable language_">self</span>.maxDepth(root.left), <span class="hljs-variable language_">self</span>.maxDepth(root.right))<br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(h)，执行时间43ms，消耗内存17.7MB</p><h1 id="100-相同的树-Easy"><a href="#100-相同的树-Easy" class="headerlink" title="100 相同的树 Easy"></a>100 相同的树 <font color=#7fffd4 size=4>Easy</font></h1><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/100_1.jpg" class="" title="100.1">  <figcaption>100.1</figcaption></figure><pre><code class="hljs">输入：p = [1,2,3], q = [1,2,3]输出：true</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/100_2.jpg" class="" title="100.2">  <figcaption>100.2</figcaption></figure><pre><code class="hljs">输入：p = [1,2], q = [1,null,2]输出：false</code></pre><p>示例 3：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/100_3.jpg" class="" title="100.3">  <figcaption>100.3</figcaption></figure><pre><code class="hljs">输入：p = [1,2,1], q = [1,1,2]输出：false</code></pre><p>提示：</p><p>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</p><p><code>-104 &lt;= Node.val &lt;= 104</code></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这里也一样，没什么好说的。我这里条件写的有点复杂，我看好一点的两个判断语句搞定，有一个一个判断语句搞定。后面直接用isSameTree就搞定（简单题你还指望我干啥，造火箭吗）</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSameTree</span>(<span class="hljs-params">self, p: <span class="hljs-type">Optional</span>[TreeNode], q: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> q:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> q:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> p.val != q.val:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.isSameTree(p.left, q.left) <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.isSameTree(p.right, q.right)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(h)，执行时间48ms，消耗内存16，2MB</p><h1 id="226-翻转二叉树-Easy"><a href="#226-翻转二叉树-Easy" class="headerlink" title="226 翻转二叉树 Easy"></a>226 翻转二叉树 <font color=#7fffd4 size=4>Easy</font></h1><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/226_1.jpg" class="" title="226.1">  <figcaption>226.1</figcaption></figure><pre><code class="hljs">输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1]</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/226_2.jpg" class="" title="226.2">  <figcaption>226.2</figcaption></figure><pre><code class="hljs">输入：root = [2,1,3]输出：[2,3,1]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：root = []输出：[]</code></pre><p>提示：</p><p>树中节点数目范围在 <code>[0, 100]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>思路上没啥难的，但是！那个梗真的好好笑，我之前真的不知道这个梗。翻评论看到半天没反应过来咋回事，一搜才知道。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invertTree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        root.left, root.right = root.right, root.left<br>        <span class="hljs-variable language_">self</span>.invertTree(root.left)<br>        <span class="hljs-variable language_">self</span>.invertTree(root.right)<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间27ms，消耗内存16.2MB</p><h1 id="101-对称二叉树-Easy"><a href="#101-对称二叉树-Easy" class="headerlink" title="101 对称二叉树 Easy"></a>101 对称二叉树 <font color=#7fffd4 size=4>Easy</font></h1><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/101_1.png" class="" title="101.1">  <figcaption>101.1</figcaption></figure><pre><code class="hljs">输入：root = [1,2,2,3,4,4,3]输出：true</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/101_2.png" class="" title="101.2">  <figcaption>101.2</figcaption></figure><pre><code class="hljs">输入：root = [1,2,2,null,3,null,3]输出：false</code></pre><p>提示：</p><p>树中节点数目在范围 <code>[1, 1000]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>递归判断，如果左子树和右子树对称，那么左子树的左子树和右子树的右子树都是对称的，左子树的右子树和右子树的左子树都是对称的。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSymmetric</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">isMirror</span>(<span class="hljs-params">left, right</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> right:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> left <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> right <span class="hljs-keyword">or</span> left.val != right.val:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> isMirror(left.left, right.right) <span class="hljs-keyword">and</span> isMirror(left.right, right.left)<br>        <span class="hljs-keyword">return</span> isMirror(root.left, root.right)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间48ms，消耗内存16.4MB</p><h1 id="105-从前序与中序遍历序列构造二叉树-Medium"><a href="#105-从前序与中序遍历序列构造二叉树-Medium" class="headerlink" title="105 从前序与中序遍历序列构造二叉树 Medium"></a>105 从前序与中序遍历序列构造二叉树 <font color=#ff7f50 size=4>Medium</font></h1><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p>xxxxxxxxxx29 1class Solution:2    def traversalTemplate(self, root: Optional[TreeNode]) -&gt; List[数据类型]:3        if not root:4            return []5        6        res &#x3D; []7        queue &#x3D; [root]8        9        while queue:10            # 初始化本层的结果存储11            level &#x3D; []12            13            # 遍历当前层的所有节点14            for i in range(len(queue)):15                node &#x3D; queue.pop(0)16                17                # 处理节点的值（可根据题目要求自定义处理方式）18                level.append(node.val)19                20                # 将下一层的节点加入队列21                if node.left:22                    queue.append(node.left)23                if node.right:24                    queue.append(node.right)25            26            # 处理层结果（如果有特殊要求，可在这里进行处理）27            res.append(level)28        29        return respython</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/105_1.jpg" class="" title="105.1">  <figcaption>105.1</figcaption></figure><pre><code class="hljs">输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]输出: [3,9,20,null,null,15,7]</code></pre><p>示例 2:</p><pre><code class="hljs">输入: preorder = [-1], inorder = [-1]输出: [-1]</code></pre><p>提示:</p><p><code>1 &lt;= preorder.length &lt;= 3000</code></p><p><code>inorder.length == preorder.length</code></p><p><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></p><p><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</p><p><code>inorder</code> 均出现在 <code>preorder</code></p><p><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</p><p><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><ol><li>根据前序遍历可以得到根节点就是 <code>TreeNode[0]</code> ，再根据中序遍历可以得到根节点的左右子树，然后递归，继续求就可以了</li><li>注意边界条件，如果前序遍历为空或中序遍历为空，那么返回空</li></ol><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">self, preorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], inorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> preorder <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> inorder:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        root = TreeNode(preorder[<span class="hljs-number">0</span>])<br>        mid = inorder.index(preorder[<span class="hljs-number">0</span>])<br>        root.left = <span class="hljs-variable language_">self</span>.buildTree(preorder[<span class="hljs-number">1</span> : mid + <span class="hljs-number">1</span>], inorder[: mid])<br>        root.right = <span class="hljs-variable language_">self</span>.buildTree(preorder[mid + <span class="hljs-number">1</span> :], inorder[mid + <span class="hljs-number">1</span> :])<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间149ms，消耗内存86.4MB</p><h1 id="106-从中序与后序遍历序列构造二叉树-Medium"><a href="#106-从中序与后序遍历序列构造二叉树-Medium" class="headerlink" title="106 从中序与后序遍历序列构造二叉树 Medium"></a>106 从中序与后序遍历序列构造二叉树 <font color=#ff7f50 size=4>Medium</font></h1><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p>示例 1:</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/106_1.jpg" class="" title="106.1">  <figcaption>106.1</figcaption></figure><pre><code class="hljs">输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]输出：[3,9,20,null,null,15,7]</code></pre><p>示例 2:</p><pre><code class="hljs">输入：inorder = [-1], postorder = [-1]输出：[-1]</code></pre><p>提示:</p><p><code>1 &lt;= inorder.length &lt;= 3000</code></p><p><code>postorder.length == inorder.length</code></p><p><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></p><p><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</p><p><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</p><p><code>inorder</code> <strong>保证</strong>是树的中序遍历</p><p><code>postorder</code> <strong>保证</strong>是树的后序遍历</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>和105一样，通过后序遍历得到根节点（最后一个就是），然后通过中序遍历得到根节点的左右子树，然后递归，继续求就可以了</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">self, inorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], postorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inorder <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> postorder:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        root = TreeNode(postorder[-<span class="hljs-number">1</span>])<br>        mid = inorder.index(postorder[-<span class="hljs-number">1</span>])<br>        root.left = <span class="hljs-variable language_">self</span>.buildTree(inorder[: mid], postorder[: mid])<br>        root.right = <span class="hljs-variable language_">self</span>.buildTree(inorder[mid + <span class="hljs-number">1</span> : ], postorder[mid : -<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)执行时间143ms，消耗内存86.5MB</p><h1 id="117-填充每个节点的下一个右侧节点指针ⅡMedium"><a href="#117-填充每个节点的下一个右侧节点指针ⅡMedium" class="headerlink" title="117 填充每个节点的下一个右侧节点指针ⅡMedium"></a>117 填充每个节点的下一个右侧节点指针Ⅱ<font color=#ff7f50 size=4>Medium</font></h1><p>给定一个二叉树：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  int</span> val;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*left</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*right</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code> 。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code> 。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/117_1.png" class="" title="117.1">  <figcaption>117.1</figcaption></figure><pre><code class="hljs">输入：root = [1,2,3,4,5,null,7]输出：[1,#,2,3,#,4,5,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），&#39;#&#39; 表示每层的末尾。</code></pre><p>示例 2：</p><pre><code class="hljs">输入：root = []输出：[]</code></pre><p>提示：</p><p>树中的节点数在范围 <code>[0, 6000]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>这里直接考虑DFS或BFS。</p><p>我采用的是BFS，通过一个列表来存储最终结果，通过另一个列表来存储每一层的节点。</p><p>有当前节点的左右节点就加入到队列中，然后用一个循环进行遍历将每一次节点连接起来（仅本层）</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Node&#x27;</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> root<br>        queue = [root]<br>        <span class="hljs-keyword">while</span> queue:<br>            next_queue = []<br>            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> queue:<br>                <span class="hljs-keyword">if</span> node.left:<br>                    next_queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    next_queue.append(node.right)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue) - <span class="hljs-number">1</span>):<br>                queue[i].<span class="hljs-built_in">next</span> = queue[i + <span class="hljs-number">1</span>]<br>            queue = next_queue<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间46ms，消耗内存17.4MB</p><h1 id="114-二叉树展开为链表-Medium"><a href="#114-二叉树展开为链表-Medium" class="headerlink" title="114 二叉树展开为链表 Medium"></a>114 二叉树展开为链表 <font color=#ff7f50 size=4>Medium</font></h1><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</p><p>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin">先序遍历</a> 顺序相同。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/114_1.jpg" class="" title="114.1">  <figcaption>114.1</figcaption></figure><pre><code class="hljs">输入：root = [1,2,5,3,4,null,6]输出：[1,null,2,null,3,null,4,null,5,null,6]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：root = []输出：[]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：root = [0]输出：[0]</code></pre><p>提示：</p><p>树中结点数在范围 <code>[0, 2000]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>这里需要涉及到一个函数 <strong>flatten</strong>，该函数会自动将树拉直，所以我们分别让左右子树拉直然后右子树接在左子树后面就可以了</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-variable language_">self</span>.flatten(root.left)<br>        <span class="hljs-variable language_">self</span>.flatten(root.right)<br>        <br>        left = root.left<br>        right = root.right<br>        <br>        root.left = <span class="hljs-literal">None</span><br>        root.right = left<br>        <br>        p = root<br>        <span class="hljs-keyword">while</span> p.right:<br>            p = p.right<br>        p.right = right<br>            <br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间36ms，消耗内存16.7MB</p><h1 id="112-路径之和-Easy"><a href="#112-路径之和-Easy" class="headerlink" title="112 路径之和 Easy"></a>112 路径之和 <font color=#7fffd4 size=4>Easy</font></h1><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/112_1.jpg" class="" title="112.1">  <figcaption>112.1</figcaption></figure><pre><code class="hljs">输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22输出：true解释：等于目标和的根节点到叶节点路径如上图所示。</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/112_2.jpg" class="" title="112.2">  <figcaption>112.2</figcaption></figure><pre><code class="hljs">输入：root = [1,2,3], targetSum = 5输出：false解释：树中存在两条根节点到叶子节点的路径：(1 --&gt; 2): 和为 3(1 --&gt; 3): 和为 4不存在 sum = 5 的根节点到叶子节点的路径。</code></pre><p>示例 3：</p><pre><code class="hljs">输入：root = [], targetSum = 0输出：false解释：由于树是空的，所以不存在根节点到叶子节点的路径。</code></pre><p>提示：</p><p>树中节点的数目在范围 <code>[0, 5000]</code> 内</p><p><code>-1000 &lt;= Node.val &lt;= 1000</code></p><p><code>-1000 &lt;= targetSum &lt;= 1000</code></p><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>这题的核心在于使用一个函数hashPathSum，函数有两个参数（当前子树root，剩余目标sum），最终输出一个bool变量。</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], targetSum: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> root.right <span class="hljs-keyword">and</span> root.val == targetSum:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.hasPathSum(root.left, targetSum - root.val) <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.hasPathSum(root.right, targetSum - root.val)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间41ms，消耗内存17.5MB</p><h1 id="129-求根节点到叶子节点数字之和-Medium"><a href="#129-求根节点到叶子节点数字之和-Medium" class="headerlink" title="129 求根节点到叶子节点数字之和 Medium"></a>129 求根节点到叶子节点数字之和 <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p><p>每条从根节点到叶节点的路径都代表一个数字：</p><p>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。<br>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p><p><strong>叶节点</strong> 是指没有子节点的节点。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/129_1.jpg" class="" title="129.1">  <figcaption>129.1</figcaption></figure><pre><code class="hljs">输入：root = [1,2,3]输出：25解释：从根到叶子节点路径 1-&gt;2 代表数字 12从根到叶子节点路径 1-&gt;3 代表数字 13因此，数字总和 = 12 + 13 = 25</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/129_2.jpg" class="" title="129.2">  <figcaption>129.2</figcaption></figure><pre><code class="hljs">输入：root = [4,9,0,5,1]输出：1026解释：从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491从根到叶子节点路径 4-&gt;0 代表数字 40因此，数字总和 = 495 + 491 + 40 = 1026</code></pre><p>提示：</p><p>树中节点的数目在范围 <code>[1, 1000]</code> 内</p><p><code>0 &lt;= Node.val &lt;= 9</code></p><p>树的深度不超过 <code>10</code></p><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>用递归去解决，值就是原本的值*10加当前节点的值，处理方法还是很好理解的，然后分别对左右子树进行递归，搞定。</p><p>进入二叉树的条件是dfs(root, 0)</p><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumNumbers</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node, path</span>):<br>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br>            path = path * <span class="hljs-number">10</span> + node.val<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right:<br>                <span class="hljs-variable language_">self</span>.ans += path<br>            dfs(node.left, path)<br>            dfs(node.right, path)<br>                <br>        <span class="hljs-variable language_">self</span>.ans = <span class="hljs-number">0</span><br>        dfs(root, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ans<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间37ms，消耗内存16.4MB</p><h1 id="124-二叉树中的最大路径和-Hard"><a href="#124-二叉树中的最大路径和-Hard" class="headerlink" title="124 二叉树中的最大路径和 Hard"></a>124 二叉树中的最大路径和 <font color=#ff0000 size=4>Hard</font></h1><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/124_1.jpg" class="" title="124.1">  <figcaption>124.1</figcaption></figure><pre><code class="hljs">输入：root = [1,2,3]输出：6解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/124_2.jpg" class="" title="124.2">  <figcaption>124.2</figcaption></figure><pre><code class="hljs">输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</code></pre><p>提示：</p><p>树中节点数目范围是 <code>[1, 3 * 104]</code></p><p><code>-1000 &lt;= Node.val &lt;= 1000</code></p><h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>这里照样可以使用dfs的递归调用，不断更新最大值，最后返回最大值。</p><p>我的做法是直接使用类属性 <code>self.ans</code> 来记录最大值。这样作用域会更广，并且可以在其它类方法中使用。</p><p>不过相比于leetcode上大部分人所用的声明局部变量后通过 <code>nonlocal</code> 来转换为非局部变量，我的做法虽然可以在其它类中调用但是速度更慢一些。</p><h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-variable language_">self</span>.ans = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            left = <span class="hljs-built_in">max</span>(dfs(node.left), <span class="hljs-number">0</span>)<br>            right = <span class="hljs-built_in">max</span>(dfs(node.right), <span class="hljs-number">0</span>)<br>            <span class="hljs-variable language_">self</span>.ans = <span class="hljs-built_in">max</span>(<span class="hljs-variable language_">self</span>.ans, node.val + left + right)<br>            <span class="hljs-keyword">return</span> node.val + <span class="hljs-built_in">max</span>(left, right)<br>        dfs(root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ans<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间80ms，消耗内存21.6MB</p><h1 id="173-二叉搜索树递归器-Medium"><a href="#173-二叉搜索树递归器-Medium" class="headerlink" title="173 二叉搜索树递归器 Medium"></a>173 二叉搜索树递归器 <font color=#ff7f50 size=4>Medium</font></h1><p>实现一个二叉搜索树迭代器类<code>BSTIterator</code> ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p><p><code>BSTIterator(TreeNode root)</code> 初始化 <code>BSTIterator</code> 类的一个对象。BST 的根节点 <code>root</code> 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</p><p><code>boolean hasNext()</code> 如果向指针右侧遍历存在数字，则返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>int next()</code>将指针向右移动，然后返回指针处的数字。</p><p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 <code>next()</code> 的首次调用将返回 BST 中的最小元素。</p><p>你可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 的中序遍历中至少存在一个下一个数字。</p><p>示例：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/173_1.png" class="" title="173.1">  <figcaption>173.1</figcaption></figure><pre><code class="hljs">输入[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;][[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]输出[null, 3, 7, true, 9, true, 15, true, 20, false]解释BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);bSTIterator.next();    // 返回 3bSTIterator.next();    // 返回 7bSTIterator.hasNext(); // 返回 TruebSTIterator.next();    // 返回 9bSTIterator.hasNext(); // 返回 TruebSTIterator.next();    // 返回 15bSTIterator.hasNext(); // 返回 TruebSTIterator.next();    // 返回 20bSTIterator.hasNext(); // 返回 False</code></pre><p>提示：</p><p>树中节点的数目在范围 <code>[1, 105]</code> 内</p><p><code>0 &lt;= Node.val &lt;= 106</code></p><p>最多调用 $10^5$ 次 <code>hasNext</code> 和 <code>next</code> 操作</p><h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>首先我最开始的写法发现pushAll已经不支持了，立马改写法</p><p>然后我们看正确代码，思路上还是使用一个双端队列来存结果。额外创建一个函数——中序遍历，用这个来将二叉树的节点进行遍历，然后我们按照题目给的意思去写 <code>next</code> 和 <code>hashnext</code> 函数。</p><p>这里需要注意一点题目中所说的当前节点的下一个节点有数返回True，这个直接转化为长度存在就返回True，这样可以避免看到题目第一反应用指针去做。</p><h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><p>错误版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>):<br>        <span class="hljs-variable language_">self</span>.stack = []<br>        <span class="hljs-variable language_">self</span>.pushAll(root)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        node = <span class="hljs-variable language_">self</span>.stack.pop()<br>        <span class="hljs-variable language_">self</span>.pushAll(node.right)<br>        <span class="hljs-keyword">return</span> node.val<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasNext</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.stack) &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>):<br>        <span class="hljs-variable language_">self</span>.queue = collections.deque()<br>        <span class="hljs-variable language_">self</span>.inOrder(root)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inOrder</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> <br>        <span class="hljs-variable language_">self</span>.inOrder(root.left)<br>        <span class="hljs-variable language_">self</span>.queue.append(root.val)<br>        <span class="hljs-variable language_">self</span>.inOrder(root.right)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.queue.popleft()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasNext</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.queue) &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间74ms，消耗内存22.5MB</p><h1 id="222-完全二叉树的节点数-Easy"><a href="#222-完全二叉树的节点数-Easy" class="headerlink" title="222 完全二叉树的节点数 Easy"></a>222 完全二叉树的节点数 <font color=#7fffd4 size=4>Easy</font></h1><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 1~ $2^h$ 个节点。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/222_1.jpg" class="" title="222.1">  <figcaption>222.1</figcaption></figure><pre><code class="hljs">输入：root = [1,2,3,4,5,6]输出：6</code></pre><p>示例 2：</p><pre><code class="hljs">输入：root = []输出：0</code></pre><p>示例 3：</p><pre><code class="hljs">输入：root = [1]输出：1</code></pre><p>提示：</p><p>树中节点的数目范围是 <code>[0, 5 * 104]</code></p><p><code>0 &lt;= Node.val &lt;= 5 * 104</code></p><p>题目数据保证输入的树是 <strong>完全二叉树</strong></p><h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><p>直接调用countNode函数，记得分别对左右子树进行调用</p><h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countNodes</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-variable language_">self</span>.countNodes(root.left) + <span class="hljs-variable language_">self</span>.countNodes(root.right)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-12"><a href="#时间复杂度-12" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间65ms，消耗内存22MB</p><h1 id="236-二叉树的最近公共祖先-Medium"><a href="#236-二叉树的最近公共祖先-Medium" class="headerlink" title="236 二叉树的最近公共祖先 Medium"></a>236 二叉树的最近公共祖先 <font color=#ff7f50 size=4>Medium</font></h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大<strong>（一个节点也可以是它自己的祖先）</strong>。”</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/236_1.png" class="" title="236.1">  <figcaption>236.1</figcaption></figure><pre><code class="hljs">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出：3解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/236_2.png" class="" title="236.2">  <figcaption>236.2</figcaption></figure><pre><code class="hljs">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出：5解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p>示例 3：</p><pre><code class="hljs">输入：root = [1,2], p = 1, q = 2输出：1</code></pre><p>提示：</p><p>树中节点数目在范围 <code>[2, 105]</code> 内。</p><p><code>-109 &lt;= Node.val &lt;= 109</code></p><p>所有 <code>Node.val</code> <strong>互不相同</strong> 。</p><p><code>p != q</code></p><p><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</p><h2 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h2><p>这里直接用lowestCommonAncestor函数，传入两个节点，返回公共祖先。</p><h2 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, p: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, q: <span class="hljs-string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;TreeNode&#x27;</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root <span class="hljs-keyword">or</span> root == p <span class="hljs-keyword">or</span> root == q: <span class="hljs-keyword">return</span> root<br>        left = <span class="hljs-variable language_">self</span>.lowestCommonAncestor(root.left, p, q)<br>        right = <span class="hljs-variable language_">self</span>.lowestCommonAncestor(root.right, p, q)<br>        <span class="hljs-keyword">if</span> left <span class="hljs-keyword">and</span> right:<br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-keyword">return</span> left <span class="hljs-keyword">if</span> left <span class="hljs-keyword">else</span> right<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-13"><a href="#时间复杂度-13" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间47ms，消耗内存20.7MB</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;104-二叉树的最大深度-Easy&quot;&gt;&lt;a href=&quot;#104-二叉树的最大深度-Easy&quot; class=&quot;headerlink&quot; title=&quot;104. 二叉树的最大深度 Easy&quot;&gt;&lt;/a&gt;104. 二叉树的最大深度 &lt;font color=#7fffd4 </summary>
      
    
    
    
    <category term="刷题记录" scheme="https://lx02918.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Leetcode" scheme="https://lx02918.github.io/tags/Leetcode/"/>
    
    <category term="刷题" scheme="https://lx02918.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://lx02918.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>go学习记录——第七天</title>
    <link href="https://lx02918.github.io/2024/08/15/go-study-seventh-day/"/>
    <id>https://lx02918.github.io/2024/08/15/go-study-seventh-day/</id>
    <published>2024-08-15T01:15:24.000Z</published>
    <updated>2024-08-15T07:53:05.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Map的声明、初始化和make"><a href="#Map的声明、初始化和make" class="headerlink" title="Map的声明、初始化和make"></a>Map的声明、初始化和make</h1><p>这里的<code>map</code>相当于python中的字典，由key:value组成，无序集合。</p><p>声明格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> map1 <span class="hljs-keyword">map</span>[KeyType]ValueType<br><span class="hljs-keyword">var</span> map1 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>在声明时并不知道<code>map</code>长度，<code>map</code>是支持动态增长的。</p><p>未初始化的<code>map</code>默认值为<code>nil</code>。</p><p><code>key</code>支持使用<code>==</code> or <code>!=</code>进行比较类型，比如<code>string</code>, <code>int</code>, <code>float32</code>。所以数组、切片和结构体不能作为<code>key</code>，含数组、切片的结构体不能作为<code>key</code>，只包含内建类型的<code>struct</code>可以作为<code>key</code>，指针和接口类型可以作为<code>key</code>。</p><p>如果要用结构体作为<code>key</code>，必须满足以下条件：</p><ol><li>结构体的字段必须是可导出的。</li><li>结构体的字段必须是基本类型。</li><li>结构体不能是指针类型。</li></ol><p><code>value</code>可以是任意类型；通过使用空接口类型，我们可以存储任意类型的数据，但是使用这种类型的值需要先做一个类型断言。</p><p><code>map</code>传递给函数的代价很小，在查找值方面比较快，比线性查找快。但是相比于数组的切片中的索引还是较慢。</p><p><code>map</code>可以用函数做自己的值，这样可以使用分支结构（之前有，第二篇go的学习记录里），<code>key</code>来选择需要执行的函数。</p><p>如果<code>key1</code>是<code>map1</code>的key，那么就可以使用<code>map1[key1]</code>来获取<code>value</code>，和数组索引是一个样的。</p><p>如果<code>key1</code>是<code>map1</code>的key，那么就可以使用<code>map1[key1] = value</code>来修改<code>value</code>，和数组索引是一个样的。</p><p>同样<code>v := map1[key1]</code>也可以赋值给v，如果key1位置没有值则给值类型的空值。</p><p>同样<code>len(map1)</code>也可以获取map的长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> mapLit <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><span class="hljs-comment">//var mapCreated map[string]float32</span><br><span class="hljs-keyword">var</span> mapAssigned <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><br>mapLit = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;one&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span>: <span class="hljs-number">2</span>&#125;<br>mapCreated := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float32</span>)<br>mapAssigned = mapLit<br><br>mapCreated[<span class="hljs-string">&quot;key1&quot;</span>] = <span class="hljs-number">4.5</span><br>mapCreated[<span class="hljs-string">&quot;key2&quot;</span>] = <span class="hljs-number">3.14159</span><br>mapAssigned[<span class="hljs-string">&quot;two&quot;</span>] = <span class="hljs-number">3</span><br><br>fmt.Printf(<span class="hljs-string">&quot;Map literal at \&quot;one\&quot; is: %d\n&quot;</span>, mapLit[<span class="hljs-string">&quot;one&quot;</span>])<br>fmt.Printf(<span class="hljs-string">&quot;Map created at \&quot;key2\&quot; is: %f\n&quot;</span>, mapCreated[<span class="hljs-string">&quot;key2&quot;</span>])<br>fmt.Printf(<span class="hljs-string">&quot;Map assigned at \&quot;two\&quot; is: %d\n&quot;</span>, mapLit[<span class="hljs-string">&quot;two&quot;</span>])<br>fmt.Printf(<span class="hljs-string">&quot;Map literal at \&quot;ten\&quot; is: %d\n&quot;</span>, mapLit[<span class="hljs-string">&quot;ten&quot;</span>])<br>&#125;<br><br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">Map literal at &quot;one&quot; is: 1</span><br><span class="hljs-comment">Map created at &quot;key2&quot; is: 3.141590</span><br><span class="hljs-comment">Map assigned at &quot;two&quot; is: 3</span><br><span class="hljs-comment">Map literal at &quot;ten&quot; is: 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>mapLit</code>说明了 <code>map literals</code> 的使用方法：<code>map</code>可以用<code>&#123;key1 : value1, key2 : value2&#125;</code>的方式初始化。</p><p><code>map</code> 是引用类型的：内存用 <code>make()</code> 来分配。</p><p><code>map</code> 的初始化：<code>make(map[KeyType]ValueType)</code></p><p>简写为 <code>map1 := make(map[keytype]valuetype)</code></p><p><code>mapAssigned</code> 也是对 <code>mapLit</code> 的引用，对 <code>mapAssigned</code> 的修改会影响 <code>mapLit</code>。</p><p>绝对不要用 <code>new()</code> 来构造 <code>map</code>，因为使用了会获得一个空引用的指针，相当于声明了一个未初始化的变量并获取了地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">mapCreated := <span class="hljs-built_in">new</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float32</span>)<br><span class="hljs-comment">//调用 mapCreated[&quot;key1&quot;] = 4.5</span><br><span class="hljs-type">error</span>：invalid operation: mapCreated[<span class="hljs-string">&quot;key1&quot;</span>] (index of <span class="hljs-keyword">type</span> *<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float32</span>).<br></code></pre></td></tr></table></figure><h2 id="map容量"><a href="#map容量" class="headerlink" title="map容量"></a>map容量</h2><p>由于 <code>map</code> 是动态增长的，所以其不存在最大限制，但是在初始化时我们仍可以表明初始容量，<code>make(map[keytype]valuetype, cap)</code></p><p>当然在达到容量上限后继续增加，编译器会自动加1，但如果为了性能考虑，我们在已经提前知道大概容量的情况下，可以提前表明。</p><h2 id="用切片作为map的值"><a href="#用切片作为map的值" class="headerlink" title="用切片作为map的值"></a>用切片作为map的值</h2><p>既然一个key对应一个value，而value又是一个原始类型，那么如果一个key对应一个切片，那么它的value就是一个切片。举个例子，当我们在处理Unix系统上进程时，父进程是key，子进程是value，我们就可以将value定义为<code>[]int</code>类型或其他所有类型的切片，就可与解决。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> map1 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">int</span><br>map1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">int</span>)<br>map1[<span class="hljs-string">&quot;parent&quot;</span>] = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>map1[<span class="hljs-string">&quot;child&quot;</span>] = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>fmt.Println(map1)<br>&#125;<br><br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">map[parent:[1 2 3] child:[4 5 6]]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="测试键值对是否存在和删除元素"><a href="#测试键值对是否存在和删除元素" class="headerlink" title="测试键值对是否存在和删除元素"></a>测试键值对是否存在和删除元素</h1><p>这里我们可以用 <code>val1, isPresent = map1[key1]</code> 来判断元素是否存在。</p><p><code>isPresent</code> 是一个布尔值，<code>true</code>表示存在，<code>false</code>表示不存在。</p><p>如果只想知道这个值存不存在，不关心值是多少，可以这样写 <code>_, ok := map1[key1] // 如果key1存在则ok == true，否则ok为false</code></p><p>或者和 <code>if</code> 混合使用，<code>if _, ok := map1[key1]; ok &#123;     // ... &#125; </code><br>从 <code>map1</code> 中删除元素，可以这样写 <code>delete(map1, key1)</code>，该操作即使 <code>value1</code> 已经不存在也不会报错。</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> value <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> isPresent <span class="hljs-type">bool</span><br><br>map1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>map1[<span class="hljs-string">&quot;New Delhi&quot;</span>] = <span class="hljs-number">55</span><br>map1[<span class="hljs-string">&quot;Beijing&quot;</span>] = <span class="hljs-number">20</span><br>map1[<span class="hljs-string">&quot;Washington&quot;</span>] = <span class="hljs-number">25</span><br>value, isPresent = map1[<span class="hljs-string">&quot;Beijing&quot;</span>]<br><span class="hljs-keyword">if</span> isPresent &#123;<br>fmt.Printf(<span class="hljs-string">&quot;The value of \&quot;Beijing\&quot; in map1 is: %d\n&quot;</span>, value)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;map1 does not contain Beijing&quot;</span>)<br>&#125;<br><br>value, isPresent = map1[<span class="hljs-string">&quot;Paris&quot;</span>]<br>fmt.Printf(<span class="hljs-string">&quot;Is \&quot;Paris\&quot; in map1 ?: %t\n&quot;</span>, isPresent)<br>fmt.Printf(<span class="hljs-string">&quot;Value is: %d\n&quot;</span>, value)<br><br><span class="hljs-comment">// delete an item:</span><br><span class="hljs-built_in">delete</span>(map1, <span class="hljs-string">&quot;Washington&quot;</span>)<br>value, isPresent = map1[<span class="hljs-string">&quot;Washington&quot;</span>]<br><span class="hljs-keyword">if</span> isPresent &#123;<br>fmt.Printf(<span class="hljs-string">&quot;The value of \&quot;Washington\&quot; in map1 is: %d\n&quot;</span>, value)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;map1 does not contain Washington&quot;</span>)<br>&#125;<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">The value of &quot;Beijing&quot; in map1 is: 20</span><br><span class="hljs-comment">Is &quot;Paris&quot; in map1 ?: false</span><br><span class="hljs-comment">Value is: 0</span><br><span class="hljs-comment">map1 does not contain Washington</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="for-range用法"><a href="#for-range用法" class="headerlink" title="for-range用法"></a>for-range用法</h1><p>可以用 <code>for</code> 来读取 <code>map</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> map1 &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个返回值是key，第二个返回值是value。这里需要注意的是返回的均为在循环内可用的局部变量，key为可选值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> map1 &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只想获得key，可以这样写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> map1 &#123;<br>fmt.Printf(<span class="hljs-string">&quot;key is: %d\n&quot;</span>, key)<br>&#125;<br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>map1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">float32</span>)<br>map1[<span class="hljs-number">1</span>] = <span class="hljs-number">1.0</span><br>map1[<span class="hljs-number">2</span>] = <span class="hljs-number">2.0</span><br>map1[<span class="hljs-number">3</span>] = <span class="hljs-number">3.0</span><br>map1[<span class="hljs-number">4</span>] = <span class="hljs-number">4.0</span><br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> map1 &#123;<br>fmt.Printf(<span class="hljs-string">&quot;key is: %d - value is: %f\n&quot;</span>, key, value)<br>&#125;<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">key is: 3 - value is: 3.000000</span><br><span class="hljs-comment">key is: 1 - value is: 1.000000</span><br><span class="hljs-comment">key is: 4 - value is: 4.000000</span><br><span class="hljs-comment">key is: 2 - value is: 2.000000</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这里可以看到输出并不是按照顺序的，也就是说不是按照key or value进行排列。<code>map</code> 和数据结构中的hash，python中的dict一样，拿来计数就可以了，如果为了规则索引还是去用slice吧。（这里不免想到leetcode上很多题需要用一个hash或者dict来计数，那go在做题的时候直接用map就好咯）</p><h1 id="map类型的切片"><a href="#map类型的切片" class="headerlink" title="map类型的切片"></a>map类型的切片</h1><p>假设要获取一个 <code>map</code> 类型的切片，我们必须使用两次 <code>make()</code> 函数，第一次分配切片，第二次分配切片中的每个 <code>map</code> 元素。</p><p>实例（英文注释是原本的，中文注释是我使用AI去写的）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// main函数是程序的入口，演示了两种不同的方式来初始化和修改切片中的映射</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> <span class="hljs-comment">// Version A:</span><br> <span class="hljs-comment">// 创建一个包含5个映射的切片，并初始化每个映射</span><br> items := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br> <span class="hljs-keyword">for</span> i:= <span class="hljs-keyword">range</span> items &#123;<br>  items[i] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>  items[i][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br> &#125;<br> fmt.Printf(<span class="hljs-string">&quot;Version A: Value of items: %v\n&quot;</span>, items)<br><br> <span class="hljs-comment">// Version B: NOT GOOD!</span><br> <span class="hljs-comment">// 创建一个包含5个映射的切片，尝试初始化每个映射，但这种方式是错误的</span><br> items2 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br> <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items2 &#123;<br>  item = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// item is only a copy of the slice element.</span><br>  item[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span> <span class="hljs-comment">// This &#x27;item&#x27; will be lost on the next iteration.</span><br> &#125;<br> fmt.Printf(<span class="hljs-string">&quot;Version B: Value of items: %v\n&quot;</span>, items2)<br>&#125;<br><span class="hljs-comment">/*ooutput</span><br><span class="hljs-comment">Version A: Value of items: [map[1:2] map[1:2] map[1:2] map[1:2] map[1:2]]</span><br><span class="hljs-comment">Version B: Value of items: [map[] map[] map[] map[] map[]]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这里需要注意的是，A中所得到的是切片，而B中的仅仅是对切片目标元素进行了拷贝，并没有进行初始化。</p><h1 id="map的排序"><a href="#map的排序" class="headerlink" title="map的排序"></a>map的排序</h1><p>按照 <code>map</code> 的概念来看，<code>map</code> 是无序的，所以当需要对它进行排序时我们需要将key（或value）拷贝到一个切片，再对切片进行排序（使用 <code>sort</code> 包，前一篇blog有）</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// the telephone alphabet:</span><br><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>barVal = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;alpha&quot;</span>: <span class="hljs-number">34</span>, <span class="hljs-string">&quot;bravo&quot;</span>: <span class="hljs-number">56</span>, <span class="hljs-string">&quot;charlie&quot;</span>: <span class="hljs-number">23</span>,<br><span class="hljs-string">&quot;delta&quot;</span>: <span class="hljs-number">87</span>, <span class="hljs-string">&quot;echo&quot;</span>: <span class="hljs-number">56</span>, <span class="hljs-string">&quot;foxtrot&quot;</span>: <span class="hljs-number">12</span>,<br><span class="hljs-string">&quot;golf&quot;</span>: <span class="hljs-number">34</span>, <span class="hljs-string">&quot;hotel&quot;</span>: <span class="hljs-number">16</span>, <span class="hljs-string">&quot;indio&quot;</span>: <span class="hljs-number">87</span>,<br><span class="hljs-string">&quot;juliet&quot;</span>: <span class="hljs-number">65</span>, <span class="hljs-string">&quot;kili&quot;</span>: <span class="hljs-number">43</span>, <span class="hljs-string">&quot;lima&quot;</span>: <span class="hljs-number">98</span>&#125;<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;unsorted:&quot;</span>)<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> barVal &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Key: %v, Value: %v / &quot;</span>, k, v)<br>&#125;<br>keys := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-built_in">len</span>(barVal))<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> k, _ := <span class="hljs-keyword">range</span> barVal &#123;<br>keys[i] = k<br>i++<br>&#125;<br>sort.Strings(keys)<br>fmt.Println()<br>fmt.Println(<span class="hljs-string">&quot;sorted:&quot;</span>)<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> keys &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Key: %v, Value: %v / &quot;</span>, k, barVal[k])<br>&#125;<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">unsorted:</span><br><span class="hljs-comment">Key: bravo, Value: 56 / Key: echo, Value: 56 / Key: indio, Value: 87 / Key: juliet, Value: 65 / Key: alpha, Value: 34 / Key: charlie, Value: 23 / Key: delta, Value: 87 / Key: foxtrot, Value: 12 / Key: golf, Value: 34 / Key: hotel, Value: 16 / Key: kili, Value: 43 / Key: lima, Value: 98 /</span><br><span class="hljs-comment">sorted:</span><br><span class="hljs-comment">Key: alpha, Value: 34 / Key: bravo, Value: 56 / Key: charlie, Value: 23 / Key: delta, Value: 87 / Key: echo, Value: 56 / Key: foxtrot, Value: 12 / Key: golf, Value: 34 / Key: hotel, Value: 16 / Key: indio, Value: 87 / Key: juliet, Value: 65 / Key: kili, Value: 43 / Key: lima, Value: 98 /</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>如果想要一个排序的列表，那么最好用结构体切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> name <span class="hljs-keyword">struct</span> &#123;<br>key <span class="hljs-type">string</span><br>value <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="将map的键值对调"><a href="#将map的键值对调" class="headerlink" title="将map的键值对调"></a>将map的键值对调</h1><p>这里直接通过 <code>for-range</code> 循环遍历原始映射（map），并在循环中将原本的值设置为新的键，将原本的键设置为新的值，从而实现键值对的调换。</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 原始映射</span><br>original := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br><span class="hljs-string">&quot;apple&quot;</span>:  <span class="hljs-number">1</span>,<br><span class="hljs-string">&quot;banana&quot;</span>: <span class="hljs-number">2</span>,<br><span class="hljs-string">&quot;cherry&quot;</span>: <span class="hljs-number">3</span>,<br>&#125;<br><br><span class="hljs-comment">// 创建一个新的映射来存储调换后的键值对</span><br>swapped := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br><br><span class="hljs-comment">// 遍历原始映射并调换键值</span><br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> original &#123;<br>swapped[value] = key <span class="hljs-comment">// 将原本的值作为新键，原本的键作为新值</span><br>&#125;<br><br><span class="hljs-comment">// 输出调换后的映射</span><br>fmt.Println(<span class="hljs-string">&quot;原始映射:&quot;</span>, original)<br>fmt.Println(<span class="hljs-string">&quot;调换后的映射:&quot;</span>, swapped)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Map的声明、初始化和make&quot;&gt;&lt;a href=&quot;#Map的声明、初始化和make&quot; class=&quot;headerlink&quot; title=&quot;Map的声明、初始化和make&quot;&gt;&lt;/a&gt;Map的声明、初始化和make&lt;/h1&gt;&lt;p&gt;这里的&lt;code&gt;map&lt;/code</summary>
      
    
    
    
    <category term="学习记录" scheme="https://lx02918.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="go" scheme="https://lx02918.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/go/"/>
    
    
    <category term="学习记录" scheme="https://lx02918.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="go" scheme="https://lx02918.github.io/tags/go/"/>
    
    <category term="map" scheme="https://lx02918.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>go学习记录——第六天</title>
    <link href="https://lx02918.github.io/2024/08/14/go-study-sixth-day/"/>
    <id>https://lx02918.github.io/2024/08/14/go-study-sixth-day/</id>
    <published>2024-08-14T02:58:39.000Z</published>
    <updated>2024-08-29T08:16:41.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="For-range结构"><a href="#For-range结构" class="headerlink" title="For-range结构"></a>For-range结构</h1><p>这种构建方法可以应用于数组和切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> ix, value := <span class="hljs-keyword">range</span> slice1 &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个参数<code>ix</code>是数组或切片的索引，第二个参数<code>value</code>是该索引位置的值。他们均是仅在<code>for</code>循环内的局部变量，<code>value</code>只是<code>slice1</code>某个索引位置的值的一个拷贝，不能用来修改<code>slice1</code>该索引位置的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> slice1 []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">4</span>)<br><br>slice1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>slice1[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>slice1[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span><br>slice1[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span><br><br><span class="hljs-keyword">for</span> ix, value := <span class="hljs-keyword">range</span> slice1 &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Slice at %d is: %d\n&quot;</span>, ix, value)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">Slice at 0 is: 1</span><br><span class="hljs-comment">Slice at 1 is: 2</span><br><span class="hljs-comment">Slice at 2 is: 3</span><br><span class="hljs-comment">Slice at 3 is: 4</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>seasons := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Spring&quot;</span>, <span class="hljs-string">&quot;Summer&quot;</span>, <span class="hljs-string">&quot;Autumn&quot;</span>, <span class="hljs-string">&quot;Winter&quot;</span>&#125;<br><br><span class="hljs-keyword">for</span> ix, season := <span class="hljs-keyword">range</span> seasons &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Season %d is: %s\n&quot;</span>, ix, season)<br>&#125;<br><br><span class="hljs-keyword">var</span> season <span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> _, season = <span class="hljs-keyword">range</span> seasons &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, season)<br>&#125;<br><br><span class="hljs-keyword">for</span> ix := <span class="hljs-keyword">range</span> seasons &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, ix)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* output</span><br><span class="hljs-comment">Season 0 is: Spring</span><br><span class="hljs-comment">Season 1 is: Summer</span><br><span class="hljs-comment">Season 2 is: Autumn</span><br><span class="hljs-comment">Season 3 is: Winter</span><br><span class="hljs-comment">Spring</span><br><span class="hljs-comment">Summer</span><br><span class="hljs-comment">Autumn</span><br><span class="hljs-comment">Winter</span><br><span class="hljs-comment">0 1 2 3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>第二个例子中可以看到，使用<code>_</code>可以忽略索引。</p><p>如果只需要索引，也可以忽略第二个变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> ix := <span class="hljs-keyword">range</span> seasons &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>, ix)<br>&#125;<br><span class="hljs-comment">// Output: 0 1 2 3</span><br></code></pre></td></tr></table></figure><p>如果只需要修改<code>seasons[ix]</code>的值，也可以忽略第二个变量。</p><h2 id="多维切片下的for-range"><a href="#多维切片下的for-range" class="headerlink" title="多维切片下的for-range"></a>多维切片下的for-range</h2><p>通过计算行数和列数就可以对矩阵进行操作，和python的类似，和前面提到的多维数组一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> row := <span class="hljs-keyword">range</span> screen &#123;<br><span class="hljs-keyword">for</span> column := <span class="hljs-keyword">range</span> screen[row] &#123;<br>screen[row][column] = <span class="hljs-number">1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="切片重组（reslice）"><a href="#切片重组（reslice）" class="headerlink" title="切片重组（reslice）"></a>切片重组（reslice）</h1><p>我们首先创建一个普通的切片（比相关数组小）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">slice1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">type</span>, start_length, capacity)<br></code></pre></td></tr></table></figure><p><code>start_length</code>作为初始长度，<code>capacity</code>作为切片的容量。</p><p>然后我们就可以在切片达到容量上限后扩容，过程就是reslicing。做法就是<code>slice1 = slice1[0 : end]</code>，<code>end</code>就是新的切片的末尾索引。</p><p>将切片扩展1位可以这样做</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">sl = sl[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(sl)+<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>切片可以反复扩容操作直到占据整个数组。</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>)<br><span class="hljs-comment">// load the slice, cap(slice1) is 10:</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">cap</span>(slice1); i++ &#123;<br>slice1 = slice1[<span class="hljs-number">0</span>:i+<span class="hljs-number">1</span>]<br>slice1[i] = i<br>fmt.Printf(<span class="hljs-string">&quot;The length of slice is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1))<br>&#125;<br><br><span class="hljs-comment">// print the slice:</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice1); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Slice at %d is %d\n&quot;</span>, i, slice1[i])<br>&#125;<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">The length of slice is 1</span><br><span class="hljs-comment">The length of slice is 2</span><br><span class="hljs-comment">The length of slice is 3</span><br><span class="hljs-comment">The length of slice is 4</span><br><span class="hljs-comment">The length of slice is 5</span><br><span class="hljs-comment">The length of slice is 6</span><br><span class="hljs-comment">The length of slice is 7</span><br><span class="hljs-comment">The length of slice is 8</span><br><span class="hljs-comment">The length of slice is 9</span><br><span class="hljs-comment">The length of slice is 10</span><br><span class="hljs-comment">Slice at 0 is 0</span><br><span class="hljs-comment">Slice at 1 is 1</span><br><span class="hljs-comment">Slice at 2 is 2</span><br><span class="hljs-comment">Slice at 3 is 3</span><br><span class="hljs-comment">Slice at 4 is 4</span><br><span class="hljs-comment">Slice at 5 is 5</span><br><span class="hljs-comment">Slice at 6 is 6</span><br><span class="hljs-comment">Slice at 7 is 7</span><br><span class="hljs-comment">Slice at 8 is 8</span><br><span class="hljs-comment">Slice at 9 is 9</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>再举一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ar = [<span class="hljs-number">10</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br><span class="hljs-keyword">var</span> a = ar[<span class="hljs-number">5</span>:<span class="hljs-number">7</span>] <span class="hljs-comment">// reference to subarray &#123;5,6&#125; - len(a) is 2 and cap(a) is 5</span><br></code></pre></td></tr></table></figure><p>我们将<code>a</code>重新分片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">a = a[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>] <span class="hljs-comment">// ref of subarray &#123;5,6,7,8&#125; - len(a) is now 4 but cap(a) is still 5</span><br></code></pre></td></tr></table></figure><p>总结一下，我们对切片进行重组扩容，实际上就是重新创建一个切片，如果是用类似<code>a = a[0 :end]</code>的方式，那就是把a的引用指向了一个新的切片，原本的切片地址就被替换成了现在的切片。也就是说把原来的删了换成新的。</p><h1 id="切片的复制与追加"><a href="#切片的复制与追加" class="headerlink" title="切片的复制与追加"></a>切片的复制与追加</h1><p>如果想增加切片的容量，我们可以创建一个新的更大的切片并把原来的分片内容都拷贝过来。</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slFrom := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>slTo := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><br>n := <span class="hljs-built_in">copy</span>(slTo, slFrom)<br>fmt.Println(slTo)                    <span class="hljs-comment">// output: [1 2 3 0 0 0 0 0 0 0]</span><br>fmt.Printf(<span class="hljs-string">&quot;Copied %d elements\n&quot;</span>, n) <span class="hljs-comment">// n == 3</span><br><br>sl3 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>sl3 = <span class="hljs-built_in">append</span>(sl3, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>fmt.Println(sl3) <span class="hljs-comment">// output: [1 2 3 4 5 6]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个实例中我们使用了<code>copy</code>来拷贝切片，用<code>append</code>来向切片追加新的元素。</p><p><code>func append(s[]T, x ...T)[]T</code>，其中<code>append()</code>方法将0个或多个具有相同类型的<code>s</code>的元素追加到切片后面并返回新的切片；追加的元素必须和原本切片的元素类型相同。如果<code>s</code>的容量不足以存储新增元素，<code>append()</code>会分配新的切片来保证已有切片元素和新增元素的存储。在分配后切片的指针、长度和容量都会被更新。</p><p>如果向追加切片<code>y</code>到切片<code>x</code>的后面，我们只需要将第二个参数扩展为一个列表即可。</p><p>通常情况下<code>append()</code>是很好用的，但我们如果想掌握整个追加过程，我们就可以使用<code>AppendByte()</code>方法。</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AppendByte</span><span class="hljs-params">(slice []<span class="hljs-type">byte</span>, data ...<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>m := <span class="hljs-built_in">len</span>(slice)<br>n := m + <span class="hljs-built_in">len</span>(data)<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-built_in">cap</span>(slice) &#123; <span class="hljs-comment">// if necessary, reallocate</span><br><span class="hljs-comment">// allocate double what&#x27;s needed, for future growth.</span><br>newSlice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, (n+<span class="hljs-number">1</span>)*<span class="hljs-number">2</span>)<br><span class="hljs-built_in">copy</span>(newSlice, slice)<br>slice = newSlice<br>&#125;<br>slice = slice[<span class="hljs-number">0</span>:n]<br><span class="hljs-built_in">copy</span>(slice[m:n], data)<br><span class="hljs-keyword">return</span> slice<br>&#125;<br></code></pre></td></tr></table></figure><p><code>func copy(dst, src []T) int</code>方法将类型为<code>T</code>的切片源地址<code>src</code>拷贝到目标地址<code>dst</code>，覆盖<code>dst</code>的相关元素，并返回拷贝元素的个数。源地址可能和目标地址有重叠，拷贝个数就是<code>src</code>和<code>dst</code>长度的最小值。如果<code>src</code>是字符串类型，那么元素类型就是<code>byte</code>。如果想继续使用<code>src</code>就可以在拷贝执行后再使用<code>src = dst</code>。</p><p>由于这部分内容用的多，写几个练习（我自己写完后对照了一下，然后直接把答案贴上来了）。</p><p>练习1：<br>给定一个切片 <code>s []int</code> 和一个 <code>int</code> 类型的因子 <code>factor</code>，扩展 <code>s</code> 使其长度为 <code>len(s) * factor</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;The length of s before enlarging is:&quot;</span>, <span class="hljs-built_in">len</span>(s))<br>fmt.Println(s)<br>s = enlarge(s, <span class="hljs-number">5</span>)<br>fmt.Println(<span class="hljs-string">&quot;The length of s after enlarging is:&quot;</span>, <span class="hljs-built_in">len</span>(s))<br>fmt.Println(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">enlarge</span><span class="hljs-params">(s []<span class="hljs-type">int</span>, factor <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>ns := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(s)*factor)<br><span class="hljs-comment">// fmt.Println(&quot;The length of ns  is:&quot;, len(ns))</span><br><span class="hljs-built_in">copy</span>(ns, s)<br><span class="hljs-comment">//fmt.Println(ns)</span><br>s = ns<br><span class="hljs-comment">//fmt.Println(s)</span><br><span class="hljs-comment">//fmt.Println(&quot;The length of s after enlarging is:&quot;, len(s))</span><br><span class="hljs-keyword">return</span> s<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">The length of s before enlarging is: 3</span><br><span class="hljs-comment">[1 2 3]</span><br><span class="hljs-comment">The length of s after enlarging is: 15</span><br><span class="hljs-comment">[1 2 3 0 0 0 0 0 0]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>练习2：<br>用顺序函数过滤容器：<code>s</code> 是前 10 个整型的切片。构造一个函数 <code>Filter</code>，第一个参数是 <code>s</code>，第二个参数是一个 <code>fn func(int) bool</code>，返回满足函数 <code>fn</code> 的元素切片。通过 <code>fn</code> 测试方法测试当整型值是偶数时的情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// filter_slice.go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br>s = Filter(s, even)<br>fmt.Println(s)<br>&#125;<br><br><span class="hljs-comment">// Filter returns a new slice holding only</span><br><span class="hljs-comment">// the elements of s that satisfy f()</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Filter</span><span class="hljs-params">(s []<span class="hljs-type">int</span>, fn <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>) []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> p []<span class="hljs-type">int</span> <span class="hljs-comment">// == nil</span><br><span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">if</span> fn(i) &#123;<br>p = <span class="hljs-built_in">append</span>(p, i)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">even</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">/* [0 2 4 6 8] */</span><br></code></pre></td></tr></table></figure><p>练习3：<br>写一个函数 <code>InsertStringSlice()</code> 将切片插入到另一个切片的指定位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// insert_slice.go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>, <span class="hljs-string">&quot;O&quot;</span>, <span class="hljs-string">&quot;P&quot;</span>, <span class="hljs-string">&quot;Q&quot;</span>, <span class="hljs-string">&quot;R&quot;</span>&#125;<br>in := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;<br>res := InsertStringSlice(s, in, <span class="hljs-number">0</span>) <span class="hljs-comment">// at the front</span><br>fmt.Println(res)                   <span class="hljs-comment">// [A B C M N O P Q R]</span><br>res = InsertStringSlice(s, in, <span class="hljs-number">3</span>)  <br>fmt.Println(res)                   <span class="hljs-comment">// [M N O A B C P Q R]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InsertStringSlice</span><span class="hljs-params">(slice, insertion []<span class="hljs-type">string</span>, index <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-built_in">len</span>(slice)+<span class="hljs-built_in">len</span>(insertion))<br>at := <span class="hljs-built_in">copy</span>(result, slice[:index])<br>at += <span class="hljs-built_in">copy</span>(result[at:], insertion)<br><span class="hljs-built_in">copy</span>(result[at:], slice[index:])<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>练习4：<br>写一个函数 <code>RemoveStringSlice()</code> 将从 <code>start</code> 到 <code>end</code> 索引的元素从切片中移除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// remove_slice.go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>, <span class="hljs-string">&quot;O&quot;</span>, <span class="hljs-string">&quot;P&quot;</span>, <span class="hljs-string">&quot;Q&quot;</span>, <span class="hljs-string">&quot;R&quot;</span>&#125;<br>res := RemoveStringSlice(s, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br>fmt.Println(res) <span class="hljs-comment">// [M N Q R]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RemoveStringSlice</span><span class="hljs-params">(slice []<span class="hljs-type">string</span>, start, end <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-built_in">len</span>(slice)-(end-start))<br>at := <span class="hljs-built_in">copy</span>(result, slice[:start])<br><span class="hljs-built_in">copy</span>(result[at:], slice[end:])<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="字符串、数组和切片的应用"><a href="#字符串、数组和切片的应用" class="headerlink" title="字符串、数组和切片的应用"></a>字符串、数组和切片的应用</h1><h2 id="从字符串生成字节切片"><a href="#从字符串生成字节切片" class="headerlink" title="从字符串生成字节切片"></a>从字符串生成字节切片</h2><p>假设<code>s</code>是一个字符串（本质上是一个不可变的字节数组），那么可以直接通过<code>c := []byte(s)</code>来获取一个字节的切片。另外还可以通过<code>copy()</code>函数来达到相同的目的<code>copy(dst []byte, src string)</code></p><p>同样也可以使用for-range来获取每个元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    s := <span class="hljs-string">&quot;\u00ff\u754c&quot;</span><br>    <span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> s &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%d:%c &quot;</span>, i, c)<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">0:ÿ 2:界</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这里涉及到了Unicode字符，Unicode字符会占两个字节甚至3个或4个字节。如果发现错误的UTF8字符，将会被设置为<code>U+FFFD</code>并且索引会前移一位。和字符串转换一样，可以用<code>c := []int32(s)</code>语法，这样切片中每个<code>int</code>都会包含在对应的Unicode字符中，因为字符中的每个字符都对应一个整数，所以我们也可以将字符串转换为元素类型为<code>rune</code>的切片 <code>r := []rune(s)</code>。</p><p>可以通过<code>len([]int32(s))</code>来获取字符串字符的数量，但使用<code>utf8.RunCountInString(s)</code>效率会更高</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;unicode/utf8&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// count number of characters:</span><br>str1 := <span class="hljs-string">&quot;asSASA ddd dsjkdsjs dk&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;The number of bytes in string str1 is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(str1))<br>fmt.Printf(<span class="hljs-string">&quot;The number of characters in string str1 is %d\n&quot;</span>, utf8.RuneCountInString(str1))<br>str2 := <span class="hljs-string">&quot;asSASA ddd dsjkdsjsこん dk&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;The number of bytes in string str2 is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(str2))<br>fmt.Printf(<span class="hljs-string">&quot;The number of characters in string str2 is %d&quot;</span>, utf8.RuneCountInString(str2))<br>&#125;<br><br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">The number of bytes in string str1 is 22</span><br><span class="hljs-comment">The number of characters in string str1 is 22</span><br><span class="hljs-comment">The number of bytes in string str2 is 28</span><br><span class="hljs-comment">The number of characters in string str2 is 24</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>还可以将一个字符串追加到某个字节切片的后面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b []<span class="hljs-type">byte</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br>b = <span class="hljs-built_in">append</span>(b, s...)<br></code></pre></td></tr></table></figure><h2 id="获取字符串的某一部分"><a href="#获取字符串的某一部分" class="headerlink" title="获取字符串的某一部分"></a>获取字符串的某一部分</h2><p>使用<code>substr := str[start : end]</code>可以从字符串<code>str</code>获取从索引<code>start</code>到<code>end - 1</code>的子字符串。</p><h2 id="字符串和切片的内存结构"><a href="#字符串和切片的内存结构" class="headerlink" title="字符串和切片的内存结构"></a>字符串和切片的内存结构</h2><p>在内存中，一个字符串实际上是双字结构，即一个指向实际数据的指针一个记录字符串长度的整数。因为指针对用户来说不可见，所以依旧可以把字符串看作一个值类型。</p><figure>  <img src="/2024/08/14/go-study-sixth-day/7_6_1.png" class="" title="7.6.1">  <figcaption>7.6.1</figcaption></figure><h2 id="修改字符串中的某个字符"><a href="#修改字符串中的某个字符" class="headerlink" title="修改字符串中的某个字符"></a>修改字符串中的某个字符</h2><p>xxxxxxxxxx26 1package main2​3import (4    “fmt”5)6​7func main() {8    &#x2F;&#x2F; 原始映射9    original :&#x3D; map[string]int{10        “apple”:  1,11        “banana”: 2,12        “cherry”: 3,13    }14​15    &#x2F;&#x2F; 创建一个新的映射来存储调换后的键值对16    swapped :&#x3D; make(map[int]string)17​18    &#x2F;&#x2F; 遍历原始映射并调换键值19    for key, value :&#x3D; range original {20        swapped[value] &#x3D; key &#x2F;&#x2F; 将原本的值作为新键，原本的键作为新值21    }22​23    &#x2F;&#x2F; 输出调换后的映射24    fmt.Println(“原始映射:”, original)25    fmt.Println(“调换后的映射:”, swapped)26}go</p><p>因此我们需要将字符串换成字节数组，然后再去修改数组中的元素值，最后再将数组转换为字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;hello&quot;</span><br>c := []<span class="hljs-type">byte</span>(s)<br>c[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;c&#x27;</span><br>s2 := <span class="hljs-type">string</span>(c) <span class="hljs-comment">// s2 == &quot;cello&quot;</span><br></code></pre></td></tr></table></figure><h2 id="字节数组对比函数"><a href="#字节数组对比函数" class="headerlink" title="字节数组对比函数"></a>字节数组对比函数</h2><p><code>Compare()</code> 函数会返回两个字节数组字典顺序的整数对比结果，即<br><code>0 if a == b, -1 if a &lt; b, 1 if a &gt; b</code></p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Compare</span><span class="hljs-params">(a, b[]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(a) &amp;&amp; i &lt; <span class="hljs-built_in">len</span>(b); i++ &#123;<br>        <span class="hljs-keyword">switch</span> &#123;<br>        <span class="hljs-keyword">case</span> a[i] &gt; b[i]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">case</span> a[i] &lt; b[i]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 数组的长度可能不同</span><br>    <span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">len</span>(a) &lt; <span class="hljs-built_in">len</span>(b):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">len</span>(a) &gt; <span class="hljs-built_in">len</span>(b):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 数组相等</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="搜索及排序切片和数组"><a href="#搜索及排序切片和数组" class="headerlink" title="搜索及排序切片和数组"></a>搜索及排序切片和数组</h2><p>标准库中提供了 <code>sort</code> 包来实现常见的搜索和排序操作。（python中sorted万能函数🤣，leetcode只要遇到需要排序的写了就完事，根本不用自己去写排序算法）</p><table><thead><tr><th>sort&#x2F;search</th><th>example</th></tr></thead><tbody><tr><td>func Ints(a []int)</td><td>sort.Ints(arri)</td></tr><tr><td>func Float64s(a []float64)</td><td>sort.Float64s(arrf)</td></tr><tr><td>func Strings(a []string)</td><td>sort.Strings(arrs)</td></tr><tr><td>func Slice(slice interface{}, less func(i, j int) bool)</td><td>sort.Slice(arr, func(i, j int) bool { return arr[i] &lt; arr[j] })</td></tr><tr><td>func SearchInts(a []int, x int)</td><td>sort.SearchInts(arr, x)</td></tr><tr><td>func SearchFloat64s(a []float64, x float64)</td><td>sort.SearchFloat64s(arr, x)</td></tr><tr><td>func SearchStrings(a []string, x string)</td><td>sort.SearchStrings(arr, x)</td></tr></tbody></table><p>这里我们需要注意，想要搜索一个元素，数组或切片必须先进行排序（标准库中默认为二分排序）</p><h2 id="append-函数常见操作"><a href="#append-函数常见操作" class="headerlink" title="append()函数常见操作"></a>append()函数常见操作</h2><table><thead><tr><th>append()函数常见操作</th><th>example</th></tr></thead><tbody><tr><td>切片b追加到切片a的后面</td><td>a &#x3D; append(a, b…)</td></tr><tr><td>复制切片a的元素到新的切片b上</td><td>b &#x3D; make([]T, len(a)); copy(b, a)</td></tr><tr><td>删除位于索引i位置的元素</td><td>a &#x3D; append(a[:i], a[i+1:]…)</td></tr><tr><td>切除切片 a 中从索引 i 至 j 位置的元素</td><td>a &#x3D; append(a[:i], a[j:]…)</td></tr><tr><td>为切片 a 扩展 j 个元素长度</td><td>a &#x3D; append(a, make([]T, j)…)</td></tr><tr><td>在索引 i 的位置插入元素 x</td><td>a &#x3D; append(a[:i], append([]T{x}, a[i:]…)…)</td></tr><tr><td>在索引 i 的位置插入长度为 j 的新切片</td><td>a &#x3D; append(a[:i], append(make([]T, j), a[i:]…)…)</td></tr><tr><td>在索引 i 的位置插入切片 b 的所有元素</td><td>a &#x3D; append(a[:i], append(b, a[i:]…)…)</td></tr><tr><td>取出位于切片 a 最末尾的元素 x</td><td>x, a &#x3D; a[len(a)-1], a[:len(a)-1]</td></tr><tr><td>将元素 x 追加到切片 a</td><td>a &#x3D; append(a, x)</td></tr></tbody></table><p>这边书上推荐了三个能够实现更完整的操作的三个包，我也附上链接（也方便我自己后续去学）<a href="http://github.com/feyeleanor/slices">Slices</a>, <a href="http://github.com/feyeleanor/chain">chain</a>, <a href="http://github.com/feyeleanor/lists">lists</a></p><p>这里再次感谢原书作者 Ivo Balbaert 和中译本的各位老师，以及三个包的开发者 Eleanor McHugh。</p><h2 id="切片和垃圾回收"><a href="#切片和垃圾回收" class="headerlink" title="切片和垃圾回收"></a>切片和垃圾回收</h2><p>切片的底层指向一个数组，该数组的实际容量可能要大于切片所定义的容量，只有在没有任何切片指向的时候，底层的数组内存才会被释放，这种特性会导致程序产生多余的内存消耗。</p><p>实例（函数FindDigits将一个文件加载到内存，然后搜索其中的数字并返回一个切片）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> digitRegexp = regexp.MustCompile(<span class="hljs-string">&quot;[0-9]+&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindDigits</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    b, _ := ioutil.ReadFile(filename)<br>    <span class="hljs-keyword">return</span> digitRegexp.Find(b)<br>&#125;<br></code></pre></td></tr></table></figure><p>代码可以正常运行，但返回的 <code>[]byte</code> 指向的底层是整个文件的数据。只要该返回的切片不被释放，垃圾回收就不能释放整个文件占据的内存。（这句话看到就想到了之前在不知道哪个论坛看到的一个例子，那个例子中程序运行过程中内存会被完全使用，也就是说即使只调用一个功能也会将整个内存拉取，造成大量的内存浪费，大致内容是这样。但我自己感觉和这个有点类似，都会造成内存浪费，拖慢运行速度。）</p><p>避免这个问题可以通过将需要的部分拷贝到一个新的切片再调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindDigits</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>   b, _ := ioutil.ReadFile(filename)<br>   b = digitRegexp.Find(b)<br>   c := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(b))<br>   <span class="hljs-built_in">copy</span>(c, b)<br>   <span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个只找到了第一个匹配正则表达式的字符串，要找到全部的用下面这个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindFileDigits</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>   fileBytes, _ := ioutil.ReadFile(filename)<br>   b := digitRegexp.FindAll(fileBytes, <span class="hljs-built_in">len</span>(fileBytes))<br>   c := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>)<br>   <span class="hljs-keyword">for</span> _, bytes := <span class="hljs-keyword">range</span> b &#123;<br>      c = <span class="hljs-built_in">append</span>(c, bytes...)<br>   &#125;<br>   <span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;For-range结构&quot;&gt;&lt;a href=&quot;#For-range结构&quot; class=&quot;headerlink&quot; title=&quot;For-range结构&quot;&gt;&lt;/a&gt;For-range结构&lt;/h1&gt;&lt;p&gt;这种构建方法可以应用于数组和切片：&lt;/p&gt;
&lt;figure clas</summary>
      
    
    
    
    <category term="学习记录" scheme="https://lx02918.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="go" scheme="https://lx02918.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/go/"/>
    
    
    <category term="学习记录" scheme="https://lx02918.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="go" scheme="https://lx02918.github.io/tags/go/"/>
    
    <category term="切片" scheme="https://lx02918.github.io/tags/%E5%88%87%E7%89%87/"/>
    
    <category term="For-range结构" scheme="https://lx02918.github.io/tags/For-range%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>go学习记录——第五天</title>
    <link href="https://lx02918.github.io/2024/08/13/go-study-fifth-day/"/>
    <id>https://lx02918.github.io/2024/08/13/go-study-fifth-day/</id>
    <published>2024-08-13T06:58:29.000Z</published>
    <updated>2024-08-15T07:51:34.755Z</updated>
    
    <content type="html"><![CDATA[<p>这篇不算完全的记录，要补充一下基本数据结构中关于字符串的包和切片部分的包，顺便补全一下之前说的转义字符和格式化占位符表格。</p><h1 id="strings和strcov包"><a href="#strings和strcov包" class="headerlink" title="strings和strcov包"></a>strings和strcov包</h1><h2 id="前缀和后缀"><a href="#前缀和后缀" class="headerlink" title="前缀和后缀"></a>前缀和后缀</h2><p><code>HasPrefix()</code>和<code>Hassuffix()</code>用于判断字符串<code>s</code>是否以<code>prefix</code>开头或者以<code>suffix</code>结尾。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.HasPrefix(s, prefix <span class="hljs-type">string</span>) <span class="hljs-type">bool</span><br>strings.HasSuffix(s, suffix <span class="hljs-type">string</span>) <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span> = <span class="hljs-string">&quot;This is an example of a string&quot;</span><br><br>fmt.Printf(<span class="hljs-string">&quot;T/F? Does the string \&quot;%s\&quot; have prefix %s? &quot;</span>, str, <span class="hljs-string">&quot;Th&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%t\n&quot;</span>, strings.HasPrefix(str, <span class="hljs-string">&quot;Th&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">// Output: T/F? Does the string &quot;This is an example of a string&quot; have prefix Th? true</span><br></code></pre></td></tr></table></figure><h2 id="字符串包含关系"><a href="#字符串包含关系" class="headerlink" title="字符串包含关系"></a>字符串包含关系</h2><p><code>Contains()</code>判断字符串<code>s</code>是否包含<code>substr</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Contains(s, substr <span class="hljs-type">string</span>) <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><h2 id="判断子字符串或字符在父字符串中出现的位置（索引）"><a href="#判断子字符串或字符在父字符串中出现的位置（索引）" class="headerlink" title="判断子字符串或字符在父字符串中出现的位置（索引）"></a>判断子字符串或字符在父字符串中出现的位置（索引）</h2><p><code>Index()</code>返回字符串<code>str</code>在字符串<code>s</code>中的索引（<code>str</code>的第一个字符的索引），<code>-1</code>表示字符串<code>s</code>不包含字符串<code>str</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Index(s, str <span class="hljs-type">string</span>) <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p><code>LastIndex()</code>返回字符串<code>str</code>在字符串<code>s</code>中最后出现位置的（<code>str</code>的第一个字符的索引），<code>-1</code>表示字符串<code>s</code>不包含字符串<code>str</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.LastIndex(s, str <span class="hljs-type">string</span>) <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>如果要查询非ASCII编码的字符在父字符串中的位置，用<code>IndexRune()</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.IndexRune(s <span class="hljs-type">string</span>, r <span class="hljs-type">rune</span>) <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>在最新版的Go中定义为<code>func IndexRune(s string, r rune) int</code></li><li>实际使用中的第二个参数<code>rune</code>可以是<code>rune</code>或<code>int</code>，例如<code>strings.IndexRune(&quot;chicken&quot;, 99)</code> 或 <code>strings.IndexRune(&quot;chicken&quot;, rune(&#39;k&#39;))</code></li></ul><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Hi, I&#x27;m Marc, Hi.&quot;</span><br><br>fmt.Printf(<span class="hljs-string">&quot;The position of \&quot;Marc\&quot; is: &quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, strings.Index(str, <span class="hljs-string">&quot;Marc&quot;</span>))<br><br>fmt.Printf(<span class="hljs-string">&quot;The position of the first instance of \&quot;Hi\&quot; is: &quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, strings.Index(str, <span class="hljs-string">&quot;Hi&quot;</span>))<br>fmt.Printf(<span class="hljs-string">&quot;The position of the last instance of \&quot;Hi\&quot; is: &quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, strings.LastIndex(str, <span class="hljs-string">&quot;Hi&quot;</span>))<br><br>fmt.Printf(<span class="hljs-string">&quot;The position of \&quot;Burger\&quot; is: &quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, strings.Index(str, <span class="hljs-string">&quot;Burger&quot;</span>))<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">The position of &quot;Marc&quot; is: 8</span><br><span class="hljs-comment">The position of the first instance of &quot;Hi&quot; is: 0</span><br><span class="hljs-comment">The position of the last instance of &quot;Hi&quot; is: 14</span><br><span class="hljs-comment">The position of &quot;Burger&quot; is: -1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p><code>Replace()</code>用于将字符串<code>s</code>中的前<code>n</code>个字符串<code>old</code>替换为字符串<code>new</code>，并返回一个新的字符串，如果<code>n = -1</code>则替换掉所有字符串<code>old</code>为<code>new</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Replace(str, old, <span class="hljs-built_in">new</span> <span class="hljs-type">string</span>, n <span class="hljs-type">int</span>) <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><h2 id="统计字符串出现次数"><a href="#统计字符串出现次数" class="headerlink" title="统计字符串出现次数"></a>统计字符串出现次数</h2><p><code>Count()</code>用于统计字符串<code>str</code>中字符串<code>s</code>出现的次数（非重叠）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Count(s, str <span class="hljs-type">string</span>) <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Hello, how is it going, Hugo?&quot;</span><br><span class="hljs-keyword">var</span> manyG = <span class="hljs-string">&quot;gggggggggg&quot;</span><br><br>fmt.Printf(<span class="hljs-string">&quot;Number of H&#x27;s in %s is: &quot;</span>, str)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, strings.Count(str, <span class="hljs-string">&quot;H&quot;</span>))<br><br>fmt.Printf(<span class="hljs-string">&quot;Number of double g&#x27;s in %s is: &quot;</span>, manyG)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, strings.Count(manyG, <span class="hljs-string">&quot;gg&quot;</span>))<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">Number of H&#x27;s in Hello, how is it going, Hugo? is: 2</span><br><span class="hljs-comment">Number of double g’s in gggggggggg is: 5</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="重复字符串"><a href="#重复字符串" class="headerlink" title="重复字符串"></a>重复字符串</h2><p><code>Repeat()</code>用于将字符串<code>str</code>重复<code>n</code>次，返回一个新的字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Repeat(s, n <span class="hljs-type">int</span>) <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> origS <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Hi there! &quot;</span><br><span class="hljs-keyword">var</span> newS <span class="hljs-type">string</span><br><br>newS = strings.Repeat(origS, <span class="hljs-number">3</span>)<br>fmt.Printf(<span class="hljs-string">&quot;The new repeated string is: %s\n&quot;</span>, newS)<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">The new repeated string is: Hi there! Hi there! Hi there!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="修改字符串的大小写"><a href="#修改字符串的大小写" class="headerlink" title="修改字符串的大小写"></a>修改字符串的大小写</h2><p><code>ToLower()</code>和<code>ToUpper()</code>用于将字符串<code>s</code>中的所有字符转为小写或大写。和python的一样，就多了个<code>To</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.ToLower(s) <span class="hljs-type">string</span><br>strings.ToUpper(s) <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> orig <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Hey, how are you George?&quot;</span><br><span class="hljs-keyword">var</span> lower <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> upper <span class="hljs-type">string</span><br><br>fmt.Printf(<span class="hljs-string">&quot;The original string is: %s\n&quot;</span>, orig)<br>lower = strings.ToLower(orig)<br>fmt.Printf(<span class="hljs-string">&quot;The lowercase string is: %s\n&quot;</span>, lower)<br>upper = strings.ToUpper(orig)<br>fmt.Printf(<span class="hljs-string">&quot;The uppercase string is: %s\n&quot;</span>, upper)<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">The original string is: Hey, how are you George?</span><br><span class="hljs-comment">The lowercase string is: hey, how are you george?</span><br><span class="hljs-comment">The uppercase string is: HEY, HOW ARE YOU GEORGE?</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="修剪字符串"><a href="#修剪字符串" class="headerlink" title="修剪字符串"></a>修剪字符串</h2><p><code>strings.TrimSpace(s)</code>剔除字符串开头和结尾的空白符号<br><code>strings.Trim(s, &quot;cut&quot;)</code>剔除开头和结尾的指定字符，<code>cut</code>参数可以是任意字符<br><code>strings.TrimLeft()</code>或<code>string.TrimRight()</code>可以剔除开头或结尾的字符</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 示例字符串</span><br>    str1 := <span class="hljs-string">&quot;   Hello, World!   &quot;</span><br>    str2 := <span class="hljs-string">&quot;!!!Hello, World!!!&quot;</span><br>    <br>    <span class="hljs-comment">// 使用 TrimSpace 去除开头和结尾的空白符号</span><br>    trimmedSpace := strings.TrimSpace(str1)<br>    fmt.Println(<span class="hljs-string">&quot;使用 TrimSpace 去除空白符号:&quot;</span>, trimmedSpace) <span class="hljs-comment">// 输出: &quot;Hello, World!&quot;</span><br>    <br>    <span class="hljs-comment">// 使用 Trim 去除开头和结尾的指定字符</span><br>    trimmedCut := strings.Trim(str2, <span class="hljs-string">&quot;!&quot;</span>)<br>    fmt.Println(<span class="hljs-string">&quot;使用 Trim 去除指定字符:&quot;</span>, trimmedCut) <span class="hljs-comment">// 输出: &quot;Hello, World&quot;</span><br>    <br>    <span class="hljs-comment">// 使用 TrimLeft 去除开头的指定字符</span><br>    trimmedLeft := strings.TrimLeft(str2, <span class="hljs-string">&quot;!&quot;</span>)<br>    fmt.Println(<span class="hljs-string">&quot;使用 TrimLeft 去除开头的指定字符:&quot;</span>, trimmedLeft) <span class="hljs-comment">// 输出: &quot;Hello, World!!!&quot;</span><br>    <br>    <span class="hljs-comment">// 使用 TrimRight 去除结尾的指定字符</span><br>    trimmedRight := strings.TrimRight(str2, <span class="hljs-string">&quot;!&quot;</span>)<br>    fmt.Println(<span class="hljs-string">&quot;使用 TrimRight 去除结尾的指定字符:&quot;</span>, trimmedRight) <span class="hljs-comment">// 输出: &quot;!!!Hello, World&quot;</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">使用 TrimSpace 去除空白符号: Hello, World!</span><br><span class="hljs-comment">使用 Trim 去除指定字符: Hello, World</span><br><span class="hljs-comment">使用 TrimLeft 去除开头的指定字符: Hello, World!!!</span><br><span class="hljs-comment">使用 TrimRight 去除结尾的指定字符: !!!Hello, World</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h2><p><code>strings.Fields(s)</code>将会利用1个或多个空白符号来作为动态长度的分隔符将字符串分割成若干小块，并返回一个slice，如果字符串只包含空白符，则返回一个长度为0的slice。</p><p><code>strings.Split(s, sep)</code>用自定义符号去对指定字符串进行分割，并返回slice。</p><p>这里的split和python的差不多，一个字符串在内一个字符串在外</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 使用 strings.Split 按指定分隔符分割字符串</span><br>    str1 := <span class="hljs-string">&quot;apple,banana,cherry&quot;</span><br>    splitResult := strings.Split(str1, <span class="hljs-string">&quot;,&quot;</span>)<br>    fmt.Println(<span class="hljs-string">&quot;使用 strings.Split 结果:&quot;</span>, splitResult) <span class="hljs-comment">// 输出: [apple banana cherry]</span><br><br>    <span class="hljs-comment">// 使用 strings.Fields 按空白字符分割字符串</span><br>    str2 := <span class="hljs-string">&quot;  Hello,   World!  This is Go.  &quot;</span><br>    fieldsResult := strings.Fields(str2)<br>    fmt.Println(<span class="hljs-string">&quot;使用 strings.Fields 结果:&quot;</span>, fieldsResult) <span class="hljs-comment">// 输出: [Hello, World! This is Go.]</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">使用 strings.Split 结果: [apple banana cherry]</span><br><span class="hljs-comment">使用 strings.Fields 结果: [Hello, World! This is Go.]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="拼接slice到字符串"><a href="#拼接slice到字符串" class="headerlink" title="拼接slice到字符串"></a>拼接slice到字符串</h2><p><code>Join()</code>用于将元素类型为<code>string</code>的<code>slice</code>使用分隔符来拼接成一个字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Join(sl []<span class="hljs-type">string</span>, sep <span class="hljs-type">string</span>) <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;The quick brown fox jumps over the lazy dog&quot;</span><br>sl := strings.Fields(str)<br>fmt.Printf(<span class="hljs-string">&quot;Splitted in slice: %v\n&quot;</span>, sl)<br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> sl &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s - &quot;</span>, val)<br>&#125;<br>fmt.Println()<br>str2 := <span class="hljs-string">&quot;GO1|The ABC of Go|25&quot;</span><br>sl2 := strings.Split(str2, <span class="hljs-string">&quot;|&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;Splitted in slice: %v\n&quot;</span>, sl2)<br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> sl2 &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s - &quot;</span>, val)<br>&#125;<br>fmt.Println()<br>str3 := strings.Join(sl2,<span class="hljs-string">&quot;;&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;sl2 joined by ;: %s\n&quot;</span>, str3)<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">Splitted in slice: [The quick brown fox jumps over the lazy dog]</span><br><span class="hljs-comment">The - quick - brown - fox - jumps - over - the - lazy - dog -</span><br><span class="hljs-comment">Splitted in slice: [GO1 The ABC of Go 25]</span><br><span class="hljs-comment">GO1 - The ABC of Go - 25 -</span><br><span class="hljs-comment">sl2 joined by ;: GO1;The ABC of Go;25</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="从字符串中读取内容"><a href="#从字符串中读取内容" class="headerlink" title="从字符串中读取内容"></a>从字符串中读取内容</h2><p><code>strings.NewReader(str)</code>用于生成一个<code>Reader</code>并读取字符串中的内容，然后返回指向这个<code>Reader</code>的指针。</p><p><code>Read()</code>从<code>[]byte</code>读取内容</p><p><code>ReadByte()</code>和<code>ReadRune()</code>从字符串中读取下一个<code>byte</code> or <code>rune</code></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>通过<code>strconv</code>包实现</p><p>数字型转字符串型<br><code>strconv.Itoa(i int) string</code> 返回数字 <code>i</code> 所表示的字符串类型的十进制数。</p><p><code>strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string</code> 将 64 位浮点型的数字转换为字符串，其中 <code>fmt</code> 表示格式（其值可以是 <code>&#39;b&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;f&#39;</code> 或 <code>&#39;g&#39;</code>），<code>prec</code> 表示精度，<code>bitSize</code> 则使用 <code>32</code> 表示 <code>float32</code>，用 <code>64</code> 表示 <code>float64</code>。</p><p>字符串型转数字型</p><p><code>strconv.Atoi(s string) (i int, err error)</code> 将字符串转换为 <code>int</code> 型。</p><p><code>strconv.ParseFloat(s string, bitSize int) (f float64, err error)</code> 将字符串转换为 <code>float64</code> 型。</p><h1 id="bytes包"><a href="#bytes包" class="headerlink" title="bytes包"></a>bytes包</h1><p>类型 <code>[]byte</code> 的切片十分常见，包 <code>btyes</code>就用来提供这种类型的操作方法。同时包里还包含一个 <code>Buffer</code> 类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;bytes&quot;</span><br><br><span class="hljs-keyword">type</span> Buffer <span class="hljs-keyword">struct</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>首先 <code>buffer</code> 是长度可变的 <code>btyes</code> ，提供了 <code>Read()</code> and <code>Write()</code> 方法，读写位置长度的 <code>bytes</code> 最好使用 <code>buffer</code></p><p><code>Buffer</code> 的定义是 <code>var buffer bytes.Buffer</code></p><p>或使用函数 <code>func NewBuffer(buf []byte) *Buffer</code>，创建一个 <code>buffer</code> 对象并且初始化好 <code>buf</code>； <code>NewBuffer</code> 最好在从 <code>buf</code> 读取时使用。</p><h2 id="通过buffer串联字符串"><a href="#通过buffer串联字符串" class="headerlink" title="通过buffer串联字符串"></a>通过buffer串联字符串</h2><p>实例</p><p>创建一个 <code>buffer</code>，通过 <code>buffer.WriteString(s)</code> 方法将字符串 <code>s</code> 追加到后面，最后再通过 <code>buffer.String() </code>方法转换为 <code>string</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> buffer bytes.Buffer<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> s, ok := getNextString(); ok &#123; <span class="hljs-comment">//method getNextString() not shown here</span><br>buffer.WriteString(s)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>fmt.Print(buffer.String(), <span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><table><thead><tr><th>转义字符</th><th>说明</th></tr></thead><tbody><tr><td><code>\a</code></td><td>响铃（警报）</td></tr><tr><td><code>\b</code></td><td>退格</td></tr><tr><td><code>\f</code></td><td>换页</td></tr><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\r</code></td><td>回车</td></tr><tr><td><code>\t</code></td><td>制表符</td></tr><tr><td><code>\v</code></td><td>垂直制表符</td></tr><tr><td><code>\\</code></td><td>反斜杠</td></tr><tr><td><code>\&#39;</code></td><td>单引号</td></tr><tr><td><code>\&quot;</code></td><td>双引号</td></tr><tr><td><code>\?</code></td><td>问号</td></tr><tr><td><code>\0</code></td><td>空字符（Null 字符）</td></tr><tr><td><code>\xhh</code></td><td>十六进制表示的 ASCII 字符</td></tr><tr><td><code>\uhhhh</code></td><td>Unicode 字符，表示为 16 位的十六进制</td></tr><tr><td><code>\Uhhhhhhhh</code></td><td>Unicode 字符，表示为 32 位的十六进制</td></tr></tbody></table><h1 id="格式化占位符"><a href="#格式化占位符" class="headerlink" title="格式化占位符"></a>格式化占位符</h1><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td><code>%d</code></td><td>十进制整数</td></tr><tr><td><code>%b</code></td><td>二进制整数</td></tr><tr><td><code>%o</code></td><td>八进制整数</td></tr><tr><td><code>%x</code></td><td>十六进制小写字母</td></tr><tr><td><code>%X</code></td><td>十六进制大写字母</td></tr><tr><td><code>%f</code></td><td>浮点数（默认六位小数）</td></tr><tr><td><code>%e</code></td><td>浮点数（科学计数法）</td></tr><tr><td><code>%E</code></td><td>浮点数（科学计数法，大写E）</td></tr><tr><td><code>%g</code></td><td>浮点数（以最简洁形式输出）</td></tr><tr><td><code>%G</code></td><td>浮点数（以最简洁形式输出，大写E）</td></tr><tr><td><code>%s</code></td><td>字符串</td></tr><tr><td><code>%q</code></td><td>字符串（双引号括起来，转义字符）</td></tr><tr><td><code>%c</code></td><td>Unicode 字符</td></tr><tr><td><code>%p</code></td><td>指针</td></tr><tr><td><code>%t</code></td><td>布尔值</td></tr><tr><td><code>%%</code></td><td>百分号（Literal <code>%</code>）</td></tr></tbody></table><p>今儿就到这吧，再搞下去脑容量不够了🤣</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇不算完全的记录，要补充一下基本数据结构中关于字符串的包和切片部分的包，顺便补全一下之前说的转义字符和格式化占位符表格。&lt;/p&gt;
&lt;h1 id=&quot;strings和strcov包&quot;&gt;&lt;a href=&quot;#strings和strcov包&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="学习记录" scheme="https://lx02918.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="go" scheme="https://lx02918.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/go/"/>
    
    
    <category term="学习记录" scheme="https://lx02918.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="go" scheme="https://lx02918.github.io/tags/go/"/>
    
    <category term="strings" scheme="https://lx02918.github.io/tags/strings/"/>
    
    <category term="strcov" scheme="https://lx02918.github.io/tags/strcov/"/>
    
    <category term="btyes" scheme="https://lx02918.github.io/tags/btyes/"/>
    
    <category term="转义字符" scheme="https://lx02918.github.io/tags/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
    
    <category term="格式化占位符" scheme="https://lx02918.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%8D%A0%E4%BD%8D%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>go学习记录——第四天</title>
    <link href="https://lx02918.github.io/2024/08/12/go-study-fourth-day/"/>
    <id>https://lx02918.github.io/2024/08/12/go-study-fourth-day/</id>
    <published>2024-08-12T06:31:24.000Z</published>
    <updated>2024-08-15T07:52:08.632Z</updated>
    
    <content type="html"><![CDATA[<p>今儿继续学go吧。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>这个一看到第一反应就是python的，感觉go就是受到了python的影响。</p><h2 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h2><p>从定义上看和python的差不多，相同的唯一类型的一组、已编号、长度固定、可通过索引来进行修改</p><p>声明格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier [<span class="hljs-built_in">len</span>]<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>所有元素都会在建立时被自动初始化为0</p><p>在初始化、打印数组元素、处理元素时都可以用<code>for</code>循环去做，和python一样</p><p>在循环中需要注意如果写成<code>i &lt;= len(arr)</code>，会导致数组越界，因为<code>len(arr)</code>是数组的长度，而<code>i</code>是索引，所以应该写成<code>i &lt; len(arr)</code>。</p><p>循环的话可以有两种写法</p><p>第一种是<code>for i := 0; i &lt; len(arr); i++ &#123; &#125;</code>，这种写法可以保证循环的次数是数组的长度，但是不推荐这种写法，因为不够简洁。</p><p>第二种是<code>for i, v := range arr &#123; &#125;</code>，这种写法可以直接遍历数组的所有元素，<code>i</code>是索引，<code>v</code>是元素的值。</p><p>go的数组是值类型（和C&#x2F;C++不同），所以在函数中修改数组元素的值，不会影响到原数组的值。所以可以通过<code>var arr1 = new([5]int)</code>建立</p><p>那么既然go的数组是值类型，那就可以用<code>new()</code>来创建数组，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr1 = <span class="hljs-built_in">new</span>([<span class="hljs-number">5</span>]<span class="hljs-type">int</span>)<br><br><span class="hljs-keyword">var</span> arr2 [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>这两个又有什么区别呢</p><p>首先第一种是创建了一个指针数组的指针，指向了一个在堆上分配的数组，所以<code>arr1</code>是一个指针，<code>arr1[0]</code>是一个指针，<code>*arr1[0]</code>才是数组的第一个元素。</p><p>第二种是创建了一个数组，在栈上分配内存，<code>arr2</code>是一个数组，<code>arr2[0]</code>是数组的第一个元素。</p><p>从使用场景上看想在多个函数之间共享数组或需要动态分配数组大小，可以使用指针（new）。如果大小固定，且只在一个函数内使用，直接声明数组会更好</p><p>所以在想把一个数组赋给另一个数组时，需要再做一次数组内存的拷贝</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">arr2 := *arr1<br>arr2[<span class="hljs-number">2</span>] = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>这样两个数组就分别有了不同的值，且赋值后修改 arr2 对 arr1 不会影响</p><p>所以在函数中将数组传入参数时，会直接拷贝副本而非对数组本身进行操作。如果想修改原数组就需要使用<code>&amp;</code>引用来传数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(a [3]<span class="hljs-type">int</span>)</span></span> &#123; fmt.Println(a) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fp</span><span class="hljs-params">(a *[3]<span class="hljs-type">int</span>)</span></span> &#123; fmt.Println(a) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> ar [<span class="hljs-number">3</span>]<span class="hljs-type">int</span><br>f(ar) <span class="hljs-comment">// passes a copy of ar</span><br>fp(&amp;ar) <span class="hljs-comment">// passes a pointer to ar</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">[0 0 0]</span><br><span class="hljs-comment">&amp;[0 0 0]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>还有一种就是生成数组切片然后传递给函数</p><h3 id="数组常量"><a href="#数组常量" class="headerlink" title="数组常量"></a>数组常量</h3><p>如果数组的值已经提前知道了就可以用数组常量来初始化数组，而不是依次使用<code>[]=</code>来初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> arrAge = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">18</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">22</span>, <span class="hljs-number">16</span>&#125;<br><span class="hljs-keyword">var</span> arrLazy = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">22</span>&#125;<br><span class="hljs-comment">// var arrLazy = []int&#123;5, 6, 7, 8, 22&#125;</span><br><span class="hljs-keyword">var</span> arrKeyValue = [<span class="hljs-number">5</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-number">3</span>: <span class="hljs-string">&quot;Chris&quot;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&quot;Ron&quot;</span>&#125;<br><span class="hljs-comment">//var arrKeyValue = []string&#123;3: &quot;Chris&quot;, 4: &quot;Ron&quot;&#125;</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arrAge); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Age at %d is %d\n&quot;</span>, i, arrAge[i])<br>&#125;<br>fmt.Println()<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arrLazy); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Number at %d is %d\n&quot;</span>, i, arrLazy[i])<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arrKeyValue); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Person at %d is %s\n&quot;</span>, i, arrKeyValue[i])<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面的代码示例可以看出有三种办法来初始化</p><ol><li><p><code>var arrAge = [5]int&#123;18, 20, 15, 22, 16&#125;</code>这种方式是直接初始化数组，数组的长度和元素个数都必须一致。这种办法中我们可以在后续不填充和元素个数一样的，也就是我们只指定左侧开始的部分元素，后续编译器会把没有初始化的元素补0。<code>[10]int &#123;1, 2, 3&#125;</code>这样便会在后续直接补0。</p></li><li><p><code>var arrLazy = [...]int&#123;5, 6, 7, 8, 22&#125;</code>这种方式是使用<code>...</code>语法来声明数组，省略了数组的长度，go会根据元素个数来推断数组的长度。忽略后从技术上来看就变成了切片。</p></li><li><p><code>var arrKeyValue = [5]string&#123;3: &quot;Chris&quot;, 4: &quot;Ron&quot;&#125;</code>这种方式是使用索引来初始化数组，索引必须小于数组的长度，否则会报错。这里的数组长度同样可以写成<code>...</code></p></li></ol><p>同样我们可以取任意数组常量的地址来作为新实例的指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fp</span><span class="hljs-params">(a *[3]<span class="hljs-type">int</span>)</span></span> &#123; fmt.Println(a) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>fp(&amp;[<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;i, i * i, i * i * i&#125;)<br>&#125;<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">&amp;[0 0 0]</span><br><span class="hljs-comment">&amp;[1 1 1]</span><br><span class="hljs-comment">&amp;[2 4 8]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>本质上和python差不多，就是写法上不一样，给个例子就行了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">const</span> (<br>WIDTH  = <span class="hljs-number">1920</span><br>HEIGHT = <span class="hljs-number">1080</span><br>)<br><br><span class="hljs-keyword">type</span> pixel <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> screen [WIDTH][HEIGHT]pixel<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> y := <span class="hljs-number">0</span>; y &lt; HEIGHT; y++ &#123;<br><span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; WIDTH; x++ &#123;<br>screen[x][y] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="将数组传给函数"><a href="#将数组传给函数" class="headerlink" title="将数组传给函数"></a>将数组传给函数</h3><p>将数组传递给函数时如果数组较大将消耗很多内存，这时有两种方法可以解决</p><ul><li>传递数组的指针</li><li>传递数组的切片<br>例子中是第一种方法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>array := [<span class="hljs-number">3</span>]<span class="hljs-type">float64</span>&#123;<span class="hljs-number">7.0</span>, <span class="hljs-number">8.5</span>, <span class="hljs-number">9.1</span>&#125;<br>x := Sum(&amp;array) <span class="hljs-comment">// Note the explicit address-of operator</span><br><span class="hljs-comment">// to pass a pointer to the array</span><br>fmt.Printf(<span class="hljs-string">&quot;The sum of the array is: %f&quot;</span>, x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span><span class="hljs-params">(a *[3]<span class="hljs-type">float64</span>)</span></span> (sum <span class="hljs-type">float64</span>) &#123;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> a &#123; <span class="hljs-comment">// derefencing *a to get back to the array is not necessary!</span><br>sum += v<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片（slice）是对数组的一组连续片段的引用（该数组为匿名数组，也是相关数组），从名字上看类似于python的切片，但实际上和python的list类似而不是切片。</p><p>该片段可能是整个数组，也可能是有起始和终止索引所构成的子集片段。但索引并不包含在整个子集中。</p><p>切片还提供了相关数组的动态窗口（可以拿来做滑动窗口和DP好像，确信）</p><p>由于切片是自带索引的，所以<code>len()</code>, <code>cap()</code>, <code>append()</code>等操作都可以直接使用。</p><p>这里需要说的是<code>cap()</code>，该函数可以测量切片的计算容量最大可以为多少，等于切片的长度 + 数组切片之外的长度。</p><p>举个例子如果有一个切片<code>s</code>，<code>cap(s)</code>就是从索引0到<code>len(s)</code>的元素个数，而<code>len(s)</code>是切片的长度。切片的长度不会超过它的容量，也即<code>0&lt;=s&lt;=cap(s)</code>。</p><p>由于切片是带有索引机制，结合python带索引的东西都是可变的我们可以推理出，切片也可能是可变的。而事实证明切片是可变的，并且是在运行过程中可以改变大小，最小为0，最大为整个数组大小。</p><p>如果多个切片引用同一个数组，则他们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。</p><p>切片的优点是引用，由于不需要额外的内存且比直接使用数组更加高效，所以go中更多的使用切片。</p><h2 id="声明和初始化-1"><a href="#声明和初始化-1" class="headerlink" title="声明和初始化"></a>声明和初始化</h2><p>声明格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier []<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>这里不需要说明长度，切片在未初始化前长度默认为nil，长度为0</p><p>初始化格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> slice1 []<span class="hljs-keyword">type</span> = arr1[start:end]<br></code></pre></td></tr></table></figure><p>这里表示 <code>slice1</code> 是由数组 <code>arr1</code> 从 <code>start</code> 索引到 <code>end-1</code> 索引的切片，包括 <code>start</code> ，不包括 <code>end</code> 。</p><p>如果写<code>var slice []type = arr[:]</code>，则表示 <code>slice</code> 是 <code>arr</code> 的一个切片，等价于 <code>slice = arr[0:len(arr)]</code>。</p><p>arr[2:]表示从索引2开始到数组末尾的切片，arr[:3]表示从数组开头到索引3-1的切片。</p><p>如果想去掉最后一个元素，则为<code>slice = arr[:len(arr)-1]</code>。</p><p>一个由数字 1、2、3 组成的切片可以这么生成：s :&#x3D; [3]int{1,2,3}[:]（注：应先用 s :&#x3D; [3]int{1, 2, 3} 生成数组, 再使用 s[:] 转成切片）甚至更简单的 s :&#x3D; []int{1,2,3}。</p><p>s2 :&#x3D; s[:] 是用切片组成的切片，拥有相同的元素，但是仍然指向相同的相关数组。</p><p>由于前面提到切片的上限是 <code>cap(s)</code> 所以如果继续扩展将会报错。</p><p>对每个切片下面的情况是成立的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s == s[:i] + s[i:] <span class="hljs-comment">// i是一个整数且: 0 &lt;= i &lt;= len(s)</span><br><span class="hljs-built_in">len</span>(s) &lt;= <span class="hljs-built_in">cap</span>(s)<br></code></pre></td></tr></table></figure><p>在前面说数组时提到我们可以不指定长度使用<code>...</code>来表明他长度不固定，让编译器自己去识别。那我们忽略掉<code>...</code>就可以得到切片的初始化了。<code>var x = []int&#123;1,2,3&#125;</code>。这样就创建了一个长度为5的数字同时创建了一个相关切片。</p><p>切片在内存中实际上是一个有三个域的结构体——指向相关数组的指针、切片长度、切片容量。</p><figure>  <img src="/2024/08/12/go-study-fourth-day/7_2_1.png" class="" title="7.2 Silence in Memory">  <figcaption>7.2 Silence in Memory</figcaption></figure><p>从图中看到，<code>y[0] = 3</code>且<code>y[1] = 5</code>。切片y[0:4] &#x3D; [3, 5, 7, 11]。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">6</span>]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> slice1 []<span class="hljs-type">int</span> = arr1[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>] <span class="hljs-comment">// index 5 niet meegerekend!</span><br><br><span class="hljs-comment">// load the array with integers: 0,1,2,3,4,5</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr1); i++ &#123;<br>arr1[i] = i<br>&#125;<br><br><span class="hljs-comment">// print the slice:</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice1); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Slice at %d is %d\n&quot;</span>, i, slice1[i])<br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;The length of arr1 is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(arr1))<br>fmt.Printf(<span class="hljs-string">&quot;The length of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1))<br>fmt.Printf(<span class="hljs-string">&quot;The capacity of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">cap</span>(slice1))<br><br><span class="hljs-comment">// grow the slice:</span><br>slice1 = slice1[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice1); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Slice at %d is %d\n&quot;</span>, i, slice1[i])<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;The length of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1))<br>fmt.Printf(<span class="hljs-string">&quot;The capacity of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">cap</span>(slice1))<br><br><span class="hljs-comment">// grow the slice beyond capacity:</span><br><span class="hljs-comment">// slice1 = slice1[0:7 ] // panic: runtime error: slice bounds out of range</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">Slice at 0 is 2</span><br><span class="hljs-comment">Slice at 1 is 3</span><br><span class="hljs-comment">Slice at 2 is 4</span><br><span class="hljs-comment">Slice at 3 is 5</span><br><span class="hljs-comment">The length of arr1 is 6</span><br><span class="hljs-comment">The length of slice1 is 4</span><br><span class="hljs-comment">The capacity of slice1 is 6</span><br><span class="hljs-comment">Slice at 0 is 2</span><br><span class="hljs-comment">Slice at 1 is 3</span><br><span class="hljs-comment">Slice at 2 is 4</span><br><span class="hljs-comment">Slice at 3 is 5</span><br><span class="hljs-comment">The length of slice1 is 4</span><br><span class="hljs-comment">The capacity of slice1 is 6</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>如果<code>s2</code>是一个切片，我们可以使用<code>s2[1:]</code>来表示将切片向后移一位，而结尾没有后移。而我们使用<code>s2[-1:]</code>就会报错，因为切片不能被重新分片以获得数组的前一个元素。</p><p>由于切片本身就是引用，所以绝不可以再使用一个指针去引用索引。</p><h2 id="将切片传递给函数"><a href="#将切片传递给函数" class="headerlink" title="将切片传递给函数"></a>将切片传递给函数</h2><p>如果一个函数需要调用数组，则我们可以创建一个切片并引用传递函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>s := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(a); i++ &#123;<br>s += a[i]<br>&#125;<br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>sum(arr[:])<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用make-创建一个切片"><a href="#用make-创建一个切片" class="headerlink" title="用make()创建一个切片"></a>用make()创建一个切片</h2><p>当相关数组还没被定义时可以使用<code>make()</code>来创建一个切片，同时创建好相关数组<code>var slice1 []type = make([]type, len)</code>。也可以简写为<code>slice1 := make([]type, len)</code>，这里的<code>len</code>表示切片的长度也是<code>slice</code>的初始长度。</p><p>举个例子<code>s2 := make([]int, 5)</code>表示创建一个长度为5的切片，初始值都是0。那么<code>cap(s2) == len(s2) == 5</code>。</p><p><code>make()</code>可以接受两个参数，元素类型和切片的元素个数。</p><p>如果创建一个<code>slice1</code>且不想占用整个数组，而是占用以<code>len</code>为个数，那么只要<code>slice1 = make([]type, len, cap)</code>就可以了。</p><p><code>make()</code>的使用方法是<code>func make([]T, len, cap)</code>，其中<code>len</code>表示切片的长度，<code>cap</code>表示切片的容量。<code>cap</code>为可选。</p><p>下面两种方法可以创建相同的切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>)<br><span class="hljs-built_in">new</span>([<span class="hljs-number">100</span>]<span class="hljs-type">int</span>)[<span class="hljs-number">0</span>:<span class="hljs-number">50</span>]<br></code></pre></td></tr></table></figure><figure>  <img src="/2024/08/12/go-study-fourth-day/7_2_2.png" class="" title="使用make()生成切片的内存结构">  <figcaption>使用make()生成切片的内存结构</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> slice1 []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><span class="hljs-comment">// load the array/slice:</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice1); i++ &#123;<br>slice1[i] = <span class="hljs-number">5</span> * i<br>&#125;<br><br><span class="hljs-comment">// print the slice:</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice1); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Slice at %d is %d\n&quot;</span>, i, slice1[i])<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\nThe length of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1))<br>fmt.Printf(<span class="hljs-string">&quot;The capacity of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">cap</span>(slice1))<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">Slice at 0 is 0  </span><br><span class="hljs-comment">Slice at 1 is 5  </span><br><span class="hljs-comment">Slice at 2 is 10  </span><br><span class="hljs-comment">Slice at 3 is 15  </span><br><span class="hljs-comment">Slice at 4 is 20  </span><br><span class="hljs-comment">Slice at 5 is 25  </span><br><span class="hljs-comment">Slice at 6 is 30  </span><br><span class="hljs-comment">Slice at 7 is 35  </span><br><span class="hljs-comment">Slice at 8 is 40  </span><br><span class="hljs-comment">Slice at 9 is 45  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">The length of slice1 is 10  </span><br><span class="hljs-comment">The capacity of slice1 is 10  </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="new-和make-的区别"><a href="#new-和make-的区别" class="headerlink" title="new()和make()的区别"></a>new()和make()的区别</h2><p><code>make()</code>是用来创建数组的，<code>new()</code>是用来创建指针的。</p><p><code>new(T)</code>为每个新的类型<code>T</code>分配一片内存，初始化为<code>0</code>并返回类型为<code>*T</code>的内存地址。所以这种方法返回的是 <strong>一个指向类型为<code>T</code>值为<code>0</code>的地址的指针</strong> ，适用于值类型如数组和结构体。</p><p><code>make(T)</code> <strong>返回一个类型为<code>T</code>的初始值</strong> ，适用于三种类型，切片、<code>map</code>、<code>channel</code>。</p><p>也就是说<code>new()</code>用来分配内存，<code>make()</code>用来初始化。</p><p>总结一下就是，由于<code>slice</code>、<code>map</code>、<code>channel</code>都是引用类型，三者都存在对于内存中存在多个组成部分，需要对内存进行初始化后才可以使用，这里就需要<code>make()</code>。而<code>new()</code>是直接获取一个地址，不进行初始化。所以需要使用<code>make()</code>来初始化并获取地址，而非简单使用<code>new()</code>获取地址。</p><figure>  <img src="/2024/08/12/go-study-fourth-day/7_2_3.png" class="" title="new()和make()的不同">  <figcaption>new()和make()的不同</figcaption></figure><p>第一幅图</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p *[]<span class="hljs-type">int</span> = <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>) <span class="hljs-comment">// *p == nil; with len and cap 0</span><br>p := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p>第二幅图</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">p := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>在第二幅图中，实际上切片已经被初始化，但指向了一个空指针。</p><p>上面方法实际上并不实用，更常见的是以下两种</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>)<br><br>或<br><br>v := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><p>这样分配了有50个<code>int</code>值的数组，并且创建了一个长度为10，容量为50的切片<code>v</code>，该切片指向了前10个元素。</p><h2 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h2><p>多维切片和多维数组类似，也是可以由多个一维切片组成，且长度可变。这里也需要用到<code>make()</code>对内层切片进行单独分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个 2x3 的二维切片</span><br>    matrix := [][]<span class="hljs-type">int</span>&#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>        &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;,<br>    &#125;<br><br>    <span class="hljs-comment">// 打印二维切片</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[i]); j++ &#123;<br>            fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, matrix[i][j])<br>        &#125;<br>        fmt.Println() <span class="hljs-comment">// 换行</span><br>    &#125;<br><br>    <span class="hljs-comment">// 修改某个元素</span><br>    matrix[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">10</span> <span class="hljs-comment">// 将第二行第三列的值改为 10</span><br><br>    <span class="hljs-comment">// 再次打印二维切片</span><br>    fmt.Println(<span class="hljs-string">&quot;修改后的二维切片:&quot;</span>)<br>    <span class="hljs-keyword">for</span> _, row := <span class="hljs-keyword">range</span> matrix &#123;<br>        fmt.Println(row)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里发现go和python通过循环对多维数组进行操作有点类似，下面进行对比</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[i]); j++ &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, matrix[i][j])<br>    &#125;<br>    fmt.Println()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON">matrix = [<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>    [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[i])):<br>        <span class="hljs-built_in">print</span>(matrix[i][j], end=<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今儿继续学go吧。&lt;/p&gt;
&lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;p&gt;这个一看到第一反应就是python的，感觉go就是受到了python的影响。&lt;/p&gt;
&lt;h2 id=&quot;声明</summary>
      
    
    
    
    <category term="学习记录" scheme="https://lx02918.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="go" scheme="https://lx02918.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/go/"/>
    
    
    <category term="学习记录" scheme="https://lx02918.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="go" scheme="https://lx02918.github.io/tags/go/"/>
    
    <category term="数组" scheme="https://lx02918.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="切片" scheme="https://lx02918.github.io/tags/%E5%88%87%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题记录——链表</title>
    <link href="https://lx02918.github.io/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/"/>
    <id>https://lx02918.github.io/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/</id>
    <published>2024-08-09T08:20:39.000Z</published>
    <updated>2024-08-29T08:16:24.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141 环形链表"></a>141 环形链表</h1><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：<code>pos</code> <strong>不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。<br>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/141.1.png" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/141.2.png" class="" title="示例2">  <figcaption>示例2</figcaption></figure><pre><code class="hljs">输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p>示例 3：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/141.3.png" class="" title="示例3">  <figcaption>示例3</figcaption></figure><pre><code class="hljs">输入：head = [1], pos = -1输出：false解释：链表中没有环。</code></pre><p>提示：</p><p>链表中节点的数目范围是 <code>[0, 104]</code><br><code>-105 &lt;= Node.val &lt;= 105</code><br><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>环形链表顾名思义就是链表中存在一个环，当节点遍历到能够连接到环的位置能够回到前面。</p><p>所以我们可以用快慢指针，快指针一次走两步慢指针一次走一步，只要这两个能够相遇则为有环，如果不能就表示无环。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        slow = fast = head<br>        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:<br>            slow = slow.<span class="hljs-built_in">next</span><br>            fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> slow == fast:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间76ms，消耗内存18.8MB</p><p>这里提交后发现这个的执行时间还是太慢了，所以我们对这个进行优化。</p><h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>既然我们用两个指针会导致整个代码的速度变慢，把我们就只用一个指针，用一个集合去记录已经走过的位置，只要能够回来就表示这里有环，如果不能就表示无环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        visited = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">while</span> head:<br>            <span class="hljs-keyword">if</span> head <span class="hljs-keyword">in</span> visited:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            visited.add(head)<br>            head = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间46ms，消耗内存19.1MB</p><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2 两数相加"></a>2 两数相加</h1><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/2.1.png" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.</code></pre><p>示例 2：</p><pre><code class="hljs">输入：l1 = [0], l2 = [0]输出：[0]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1]</code></pre><p>提示：</p><p>每个链表中的节点数在范围 <code>[1, 100]</code> 内</p><p><code>0 &lt;= Node.val &lt;= 9</code></p><p>题目数据保证列表表示的数字不含前导零</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这里需要提前知道题目没给的条件，这个是在实例中有体现，我们遇到加和为两位数后，我们需要进位，所以我们需要一个进位的变量。</p><p>这里我们需要用到一个divmod函数来解决这个问题，函数输入为两个数，返回值为一个元组，第一个元素为商，第二个元素为余数。</p><p>其余的就是取数、加和、下一个的问题了</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        curr = dummy<br>        carry = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2 <span class="hljs-keyword">or</span> carry:<br>            val1 = val2 = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> l1:<br>                val1 = l1.val<br>                l1 = l1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> l2:<br>                val2 = l2.val<br>                l2 = l2.<span class="hljs-built_in">next</span><br>            carry, val = <span class="hljs-built_in">divmod</span>(val1 + val2 + carry, <span class="hljs-number">10</span>)<br>            curr.<span class="hljs-built_in">next</span> = ListNode(val)<br>            curr = curr.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间61ms，消耗内存16.4MB</p><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21 合并两个有序链表"></a>21 合并两个有序链表</h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/21.1.jpg" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：l1 = [], l2 = []输出：[]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：l1 = [], l2 = [0]输出：[0]</code></pre><p>提示：</p><p>两个链表的节点数目范围是 <code>[0, 50]</code></p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><p>l1 和 l2 均按 <strong>非递减顺序</strong> 排列</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这里我们就还是设置两个节点，均为头结点的前一位，然后设置一个辅助节点，用来存储合并后的链表。</p><p>然后我们比较两个链表的头结点，谁小就把谁的头结点放到辅助节点的后面，然后把这个节点的指针指向下一个节点，然后继续比较，直到两个链表都为空。</p><p>最后把辅助节点的下一个节点作为合并后的链表的头结点。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        curr = dummy<br>        <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:<br>            <span class="hljs-keyword">if</span> list1.val &lt; list2.val:<br>                curr.<span class="hljs-built_in">next</span> = list1<br>                list1 = list1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                curr.<span class="hljs-built_in">next</span> = list2<br>                list2 = list2.<span class="hljs-built_in">next</span><br>            curr = curr.<span class="hljs-built_in">next</span><br>        curr.<span class="hljs-built_in">next</span> = list1 <span class="hljs-keyword">or</span> list2<br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间40ms，消耗内存16.4MB</p><h1 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138 随机链表的复制"></a>138 随机链表的复制</h1><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 <a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a>。 深拷贝应该正好由 <code>n</code> 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p><p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p><p>返回复制链表的头节点。</p><p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p><p><code>val</code>：一个表示 <code>Node.val</code> 的整数。<br><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为  <code>null</code> 。<br>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p><p>示例 1：<br><img src="/../img/138_1.png" alt="示例1"></p><pre><code class="hljs">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</code></pre><p>示例 2：<br><img src="/../img/138_2.png" alt="示例2"></p><pre><code class="hljs">输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]]</code></pre><p>示例 3：<br><img src="/../img/138_3.png" alt="示例3"></p><pre><code class="hljs">输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]]</code></pre><p>提示：</p><p><code>0 &lt;= n &lt;= 1000</code></p><p><code>-104 &lt;= Node.val &lt;= 104</code></p><p><code>Node.random</code> 为 <code>null</code> 或指向链表中的节点。</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这里我们可以借助字典来实现。</p><p>首先明确一点，我们可以采用两次循环来完成，一次获取val，一次获取next和random</p><p>最后直接返回第一个节点即可。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">copyRandomList</span>(<span class="hljs-params">self, head: <span class="hljs-string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Optional[Node]&#x27;</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        curr = head<br>        dic = &#123;&#125;<br>        <span class="hljs-keyword">while</span> curr:<br>            dic[curr] = Node(curr.val)<br>            curr = curr.<span class="hljs-built_in">next</span><br>            <br>        curr = head<br>        <span class="hljs-keyword">while</span> curr:<br>            dic[curr].<span class="hljs-built_in">next</span> = dic.get(curr.<span class="hljs-built_in">next</span>)<br>            dic[curr].random = dic.get(curr.random)<br>            curr = curr.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dic.get(head)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间48ms，消耗内存17.2MB</p><h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92 反转链表 II"></a>92 反转链表 II</h1><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 反转后的链表 。</p><p>示例 1：</p><pre><code class="hljs">输入：head = [1,2,3,4,5], left = 2, right = 4输出：[1,4,3,2,5]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：head = [5], left = 1, right = 1输出：[5]</code></pre><p>提示：</p><p>链表中节点数目为 <code>n</code></p><p><code>1 &lt;= n &lt;= 500</code></p><p><code>-500 &lt;= Node.val &lt;= 500</code></p><p><code>1 &lt;= left &lt;= right &lt;= n</code></p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>首先需要知道一点，我们在设置头结点前面一个虚拟节点的时候，需要用一个类似pre的字符去表示，直接使用头结点<code>dummy</code>会导致后续出现异常导致无法完全测试。</p><p>然后反转部分我的思路是直接原地操作，不进行拆开后后续拼接，所以时间复杂度上会相对来说高一些。之前反转链表中使用过拆开后拼接，这种情况下时间复杂度会降低，但是也会由于思路的混乱导致最后测试失败。</p><p>这里需要注意的另外一点是，我们这里只使用两个节点进行直接操作。刚开始我也使用了添加一个tail进行操作，但是会导致后续反转逻辑写起来比较复杂。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBetween</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        dummy.<span class="hljs-built_in">next</span> = head<br>        pre = dummy<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m - <span class="hljs-number">1</span>):<br>            pre = pre.<span class="hljs-built_in">next</span><br>        start = pre.<span class="hljs-built_in">next</span><br>        then = start.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - m):<br>            start.<span class="hljs-built_in">next</span> = then.<span class="hljs-built_in">next</span><br>            then.<span class="hljs-built_in">next</span> = pre.<span class="hljs-built_in">next</span><br>            pre.<span class="hljs-built_in">next</span> = then<br>            then = start.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span> <br></code></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间46ms，消耗内存16.3MB</p><h1 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25 K 个一组翻转链表"></a>25 K 个一组翻转链表</h1><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/25_1.jpg" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：head = [1,2,3,4,5], k = 2输出：[2,1,4,3,5]</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/25_2.jpg" class="" title="示例2">  <figcaption>示例2</figcaption></figure><pre><code class="hljs">输入：head = [1,2,3,4,5], k = 3输出：[3,2,1,4,5]</code></pre><p>提示：</p><p>链表中的节点数目为 <code>n</code></p><p><code>1 &lt;= k &lt;= n &lt;= 5000</code></p><p><code>0 &lt;= Node.val &lt;= 1000</code></p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>这里其实反转思路和前一道题一模一样。</p><p>需要注意的是我这里没用一个额外的数去累加计数，而是将整个需要反转的进行递归。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseKGroup</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        a = b = head<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> b:<br>                <span class="hljs-keyword">return</span> head<br>            b = b.<span class="hljs-built_in">next</span>  <br>        newHead = <span class="hljs-variable language_">self</span>.reverse(a, b)<br>        a.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.reverseKGroup(b, k)<br>        <span class="hljs-keyword">return</span> newHead<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">self, a, b</span>):<br>        prev = <span class="hljs-literal">None</span><br>        curr = a<br>        <span class="hljs-keyword">while</span> curr != b:<br>            <span class="hljs-built_in">next</span> = curr.<span class="hljs-built_in">next</span><br>            curr.<span class="hljs-built_in">next</span> = prev<br>            prev = curr<br>            curr = <span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> prev<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间37ms，消耗内存17.1MB</p><h1 id="19-删除链表的倒数第-N-个节点"><a href="#19-删除链表的倒数第-N-个节点" class="headerlink" title="19 删除链表的倒数第 N 个节点"></a>19 删除链表的倒数第 N 个节点</h1><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p>示例 1：</p><pre><code class="hljs">输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：head = [1], n = 1输出：[]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：head = [1,2], n = 1输出：[1]</code></pre><p>提示：</p><p>链表中结点的数目为 <code>sz</code></p><p><code>1 &lt;= sz &lt;= 30</code></p><p><code>0 &lt;= Node.val &lt;= 100</code></p><p><code>1 &lt;= n &lt;= sz</code></p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>首先按照数组字符串的思路直接倒序遍历找到节点删除就可以，但链表是不能进行倒序遍历和直接获取长度的。所以我们就需要自己去通过循环得到相关的内容。</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        dummy.<span class="hljs-built_in">next</span> = head<br>        cur, length = head, <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 获取长度</span><br>        <span class="hljs-keyword">while</span> cur:<br>            length += <span class="hljs-number">1</span><br>            cur = cur.<span class="hljs-built_in">next</span><br>        cur = dummy<br>        <span class="hljs-comment"># 找到倒数第 n 个节点</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length - n):<br>            cur = cur.<span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 删除节点</span><br>        cur.<span class="hljs-built_in">next</span> = cur.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间39ms，消耗内存16.3MB</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>这里我用了快慢指针去，思路上都差不多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> n &lt;= <span class="hljs-number">0</span>:  <span class="hljs-comment"># 增加对n的合理性检查</span><br>            <span class="hljs-keyword">return</span> head<br>        <br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        dummy.<span class="hljs-built_in">next</span> = head<br>        first = second = dummy<br>        <br>        <span class="hljs-comment"># 先将first指针移动n+1步</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> first:  <span class="hljs-comment"># 如果n大于链表长度，直接返回</span><br>                <span class="hljs-keyword">return</span> head<br>            first = first.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-comment"># 同时移动first和second指针，直到first到达链表末尾</span><br>        <span class="hljs-keyword">while</span> first:<br>            first = first.<span class="hljs-built_in">next</span><br>            second = second.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-comment"># 删除节点</span><br>        second.<span class="hljs-built_in">next</span> = second.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h1 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82 删除排序链表中的重复元素 II"></a>82 删除排序链表中的重复元素 II</h1><p>给定一个已排序的链表的头 <code>head</code> ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p><p>示例 1：</p><pre><code class="hljs">输入：head = [1,2,3,3,4,4,5]输出：[1,2,5]</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/82_2.jpg" class="" title="示例2">  <figcaption>示例2</figcaption></figure>    输入：head = [1,1,1,2,3]    输出：[2,3]<p>提示：</p><p>链表中节点数目在范围 <code>[0, 300]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><p>题目数据保证链表已经按升序 <strong>排列</strong></p><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>这里首先要注意一点也是我之前做了好几次一直过不去的原因。当我们发现两个节点值相同时，应该用一个变量去存储值，而不是直接进行后续的循环操作，直接进行操作将一直持续不断的遍历两个节点而非继续往后走。</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        dummy.<span class="hljs-built_in">next</span> = head<br>        curr = dummy<br>        <span class="hljs-keyword">while</span> curr.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> curr.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>:<br>            <span class="hljs-keyword">if</span> curr.<span class="hljs-built_in">next</span>.val == curr.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>.val:<br>                duplicate_val = curr.<span class="hljs-built_in">next</span>.val<br>                <span class="hljs-keyword">while</span> curr.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> curr.<span class="hljs-built_in">next</span>.val == duplicate_val:<br>                    curr.<span class="hljs-built_in">next</span> = curr.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                curr = curr.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间45ms，消耗内存16.3MB</p><h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61 旋转链表"></a>61 旋转链表</h1><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 k 个位置。</p><p>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/61_1.jpg" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：head = [1,2,3,4,5], k = 2输出：[4,5,1,2,3]</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/61_2.jpg" class="" title="示例2">  <figcaption>示例2</figcaption></figure><pre><code class="hljs">输入：head = [0,1,2], k = 4输出：[2,0,1]</code></pre><p>提示：</p><p>链表中节点的数目在范围 <code>[0, 500]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><p><code>0 &lt;= k &lt;= 2 * 109</code></p><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>首先知道我们每个节点往前移k个就相当于倒数第k个节点之后的节点移到头结点前。</p><p>其次我们计算长度后，我们对k进行操作，k就相当于k对长度取余，因为k大于长度时我们进行后续操作就相当于走了一圈又继续走。</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotateRight</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        curr = head<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> curr:<br>            count += <span class="hljs-number">1</span><br>            curr = curr.<span class="hljs-built_in">next</span><br>        k = k % count<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> head<br>        fast = slow = head<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            fast = fast.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> fast.<span class="hljs-built_in">next</span>:<br>            slow = slow.<span class="hljs-built_in">next</span><br>            fast = fast.<span class="hljs-built_in">next</span><br>        new_head = slow.<span class="hljs-built_in">next</span><br>        slow.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        fast.<span class="hljs-built_in">next</span> = head<br>        <span class="hljs-keyword">return</span> new_head<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间40ms，消耗内存16.4MB</p><h1 id="86-分割链表"><a href="#86-分割链表" class="headerlink" title="86 分割链表"></a>86 分割链表</h1><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p><p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p><p>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/86_1.jpg" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：head = [1,4,3,2,5,2], x = 3输出：[1,2,2,4,3,5]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：head = [2,1], x = 2输出：[1,2]</code></pre><p>提示：</p><p>链表中节点的数目在范围 <code>[0, 200]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><p><code>-200 &lt;= x &lt;= 200</code></p><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>看到题目第一反应是二分法，大于k的在右边，小于的在左边。</p><p>然后我们就可以用相似的思路去做。我们建立两个表用来存储大于和小于的节点，其次我们在遍历后直接将两个表一拼接就直接完成了。</p><p>切记我们需要在最后将大于的那个表的尾节点指向None，不然就会形成环。</p><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        smaller = ListNode(<span class="hljs-number">0</span>)<br>        bigger = ListNode(<span class="hljs-number">0</span>)<br>        small, big = smaller, bigger<br>        <span class="hljs-keyword">while</span> head:<br>            <span class="hljs-keyword">if</span> head.val &lt; x:<br>                small.<span class="hljs-built_in">next</span> = head<br>                small = small.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                big.<span class="hljs-built_in">next</span> = head<br>                big = big.<span class="hljs-built_in">next</span>  <br>            head = head.<span class="hljs-built_in">next</span><br>        small.<span class="hljs-built_in">next</span> = bigger.<span class="hljs-built_in">next</span><br>        big.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> smaller.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间38ms，消耗内存16.3MB</p><h1 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146 LRU 缓存"></a>146 LRU 缓存</h1><p>请你设计并实现一个满足  <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。<br>实现 <code>LRUCache</code> 类：<br><code>LRUCache(int capacity)</code> 以 正整数 作为容量 <code>capacity</code> 初始化 LRU 缓存<br><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。<br><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 逐出 最久未使用的关键字。<br>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p>示例：</p><pre><code class="hljs">输入[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;lRUCache.get(1);    // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;lRUCache.get(2);    // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;lRUCache.get(1);    // 返回 -1 (未找到)lRUCache.get(3);    // 返回 3lRUCache.get(4);    // 返回 4</code></pre><p>提示：</p><p><code>1 &lt;= capacity &lt;= 3000</code></p><p><code>0 &lt;= key &lt;= 10000</code></p><p><code>0 &lt;= value &lt;= 105</code></p><p>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></p><h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>这道题有那么亿点点绕，所以思路上写的比较详细</p><p>首先我们需要完成两个操作</p><ul><li><code>get(key)</code>: 如果key存在于缓存中，则返回对应的值，否则返回-1。</li><li><code>put(key, value)</code>: 将key-value对插入缓存中。如果key已经存在，更新其值；如果key不存在并且缓存已满，则移除最近最少使用的项。</li></ul><p>然后我们来说明如何实现</p><ol><li>初始化：构建一个空哈希表和一个带有哨兵头尾节点的双向链表</li><li><code>get(key)</code>：<ul><li>如果不存在，直接返回-1</li><li>如果存在，找到对应节点，将其从链表中移除并添加到链表末尾，以表示它是最近使用的元素</li></ul></li><li><code>put(key, value)</code>：<ul><li>如果key已经在缓存中，更新其值，并将该节点移动到链表的末尾。</li><li>如果key不存在，创建一个新节点并插入到链表末尾。</li><li>如果插入后缓存超出了容量，移除链表头部的节点（即最近最少使用的节点），并从哈希表中删除对应的键。</li></ul></li><li>操作解释<ul><li><code>_add</code>：将节点添加到双向链表的末尾，这表示该节点是最新被访问的。</li><li><code>_remove</code>：将节点从双向链表中删除，这个操作主要用于在<code>get</code>或<code>put</code>操作时调整节点的位置，以及在缓存容量超出限制时移除最老的节点。</li></ul></li></ol><h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CreatNode</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key = <span class="hljs-number">0</span>, value = <span class="hljs-number">0</span></span>):<br>        <span class="hljs-variable language_">self</span>.key = key<br>        <span class="hljs-variable language_">self</span>.value = value<br>        <span class="hljs-variable language_">self</span>.prev = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span> = &#123;&#125;<br>        <span class="hljs-variable language_">self</span>.head = CreatNode()<br>        <span class="hljs-variable language_">self</span>.tail = CreatNode()<br>        <span class="hljs-variable language_">self</span>.head.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.tail<br>        <span class="hljs-variable language_">self</span>.tail.prev = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-variable language_">self</span>.capacity = capacity<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        node = <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>[key]<br>        <span class="hljs-variable language_">self</span>._remove(node)<br>        <span class="hljs-variable language_">self</span>._add(node)<br>        <span class="hljs-keyword">return</span> node.value<br>    <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span>, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>:<br>            node = <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>[key]<br>            node.value = value<br>            <span class="hljs-variable language_">self</span>._remove(node)<br>            <span class="hljs-variable language_">self</span>._add(node)<br>        <span class="hljs-keyword">else</span>:<br>            node = CreatNode(key, value)<br>            <span class="hljs-variable language_">self</span>._add(node)<br>            <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>[key] = node<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>) &gt; <span class="hljs-variable language_">self</span>.capacity:<br>                <span class="hljs-keyword">del</span> <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>[<span class="hljs-variable language_">self</span>.head.<span class="hljs-built_in">next</span>.key]<br>                <span class="hljs-variable language_">self</span>._remove(<span class="hljs-variable language_">self</span>.head.<span class="hljs-built_in">next</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_remove</span>(<span class="hljs-params">self, node</span>):<br>        prev = node.prev<br>        <span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span><br>        prev.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>        <span class="hljs-built_in">next</span>.prev = prev<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_add</span>(<span class="hljs-params">self, node</span>):<br>        prev = <span class="hljs-variable language_">self</span>.tail.prev<br>        prev.<span class="hljs-built_in">next</span> = node<br>        node.prev = prev<br>        node.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.tail<br>        <span class="hljs-variable language_">self</span>.tail.prev = node<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(1)，执行时间457ms，消耗内存75.6MB</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;141-环形链表&quot;&gt;&lt;a href=&quot;#141-环形链表&quot; class=&quot;headerlink&quot; title=&quot;141 环形链表&quot;&gt;&lt;/a&gt;141 环形链表&lt;/h1&gt;&lt;p&gt;给你一个链表的头节点 &lt;code&gt;head&lt;/code&gt; ，判断链表中是否有环。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="刷题记录" scheme="https://lx02918.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Leetcode" scheme="https://lx02918.github.io/tags/Leetcode/"/>
    
    <category term="刷题" scheme="https://lx02918.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="链表" scheme="https://lx02918.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>go学习记录——第三天</title>
    <link href="https://lx02918.github.io/2024/08/09/go-study-third-day/"/>
    <id>https://lx02918.github.io/2024/08/09/go-study-third-day/</id>
    <published>2024-08-09T01:19:34.000Z</published>
    <updated>2024-08-15T07:53:01.469Z</updated>
    
    <content type="html"><![CDATA[<p>今天也继续学习go吧。今天找了下《The Way to Go》这本书的中译本，书作者是Ivo Balbaert。也非常感谢翻译者们的努力，在这里贴上链接<a href="https://github.com/unknwon/the-way-to-go_ZH_CN.git">The Way to Go</a>，也希望大家能支持下翻译者们，给项目加个小星星。</p><p>根据对比，这个讲的比较完整，咱就准备根据这个进行学习，后续也会找一些其他资料来学习。早知道就直接在GitHub上找资料来学习了🤣，事实证明GitHub才是好东西。</p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>go的指针不同于C的指针，go的指针不能进行算术运算，但是可以通过指针控制特定集合的数据结构、分配的数量及内存的访问模式。</p><p>go的取地址符号是<code>&amp;</code>，放在变量前即可获得该变量的地址。</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i1 = <span class="hljs-number">5</span><br>fmt.Printf(<span class="hljs-string">&quot;An integer: %d, its location in memory: %p\n&quot;</span>, i1, &amp;i1)<br><br><span class="hljs-keyword">var</span> intP *<span class="hljs-type">int</span><br>intP = &amp;i1<br>fmt.Printf(<span class="hljs-string">&quot;The value at memory location %p is %d\n&quot;</span>, intP, *intP)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的第一个输出的便是i1的地址</p><p>而在第二个输出中，定义了一个指向int的指针，用*i表示，然后我们用intP就可以调用。而后intP的值为i1的地址，所以输出的结果为5且地址为原始i1的地址。</p><p>指针格式化标识符为<code>%p</code>。（关于这个后续写个表格都列一下，好像还蛮多的）</p><p>然后捋一下第二个输出，intP -&gt; &amp;i1，所以引用了i1。没有指向任何东西的时候指针的默认值为nil，通常来说指针缩写是<code>prt</code></p><p>再来另外一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-string">&quot;good bye&quot;</span><br><span class="hljs-keyword">var</span> p *<span class="hljs-type">string</span> = &amp;s<br>*p = <span class="hljs-string">&quot;ciao&quot;</span><br><br>fmt.Printf(<span class="hljs-string">&quot;Here is the pointer p: %p\n&quot;</span>, p)  <span class="hljs-comment">// prints address</span><br>fmt.Printf(<span class="hljs-string">&quot;Here is the string *p: %s\n&quot;</span>, *p) <span class="hljs-comment">// prints string</span><br>fmt.Printf(<span class="hljs-string">&quot;Here is the string  s: %s\n&quot;</span>, s)  <span class="hljs-comment">// prints same string</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">Here is the pointer p: 0x2540820</span><br><span class="hljs-comment">Here is the string *p: ciao</span><br><span class="hljs-comment">Here is the string s: ciao</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这里可以看到，当我们在使用指针的时候，第一个输出由于还没有进行操作，所以p指向的是s的地址。而第二个输出*p已经被赋了新值，而后s也被改变了，所以输出都是ciao。</p><p>需要注意的是指针不能获取字面量和常量的地址。</p><p>指针的一个高级应用是你可以传递一个变量的引用（如函数的参数），这样不会传递变量的拷贝。指针传递是很廉价的，只占用 4 个或 8 个字节。当程序在工作中需要占用大量的内存，或很多变量，或者两者都有，使用指针会减少内存占用和提高效率。被指向的变量也保存在内存中，直到没有任何指针指向它们，所以从它们被创建开始就具有相互独立的生命周期。</p><p>另一方面（虽然不太可能），由于一个指针导致的间接引用（一个进程执行了另一个地址），指针的过度频繁使用也会导致性能下降。</p><p>指针也可以指向另一个指针，并且可以进行任意深度的嵌套，导致你可以有多级的间接引用，但在大多数情况这会使你的代码结构不清晰。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>这里将根据这本书的相关内容对之前学习的内容进行补充。</p><p>首先先做一下书中提出的问题</p><p>如下的两个函数调用有什么不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">(A) <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">(a *A)</span></span> &#123;<br>        b = a<br>    &#125;<br><br>(B) <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">(a A)</span></span> &#123;<br>        b = &amp;a<br>    &#125;<br></code></pre></td></tr></table></figure><p>首先A中，a指向了指针*A，所以在后续是可以直接对A值本身进行修改，也就是说b现在指向了和a一样的地址，后续函数内对b的修改同样会影响a</p><p>B中，a指向的是值A，而b指向的是a的地址（副本），也就是调用了这个值（副本），并不会影响a原本的值</p><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>函数返回值可以使用<code>return</code>或<code>return var</code>，但这里就有一个问题，返回值是一个表达式的时候可能会因为没有明确的目标而报错（虽然我写python的时候也老干这个，但好像没啥影响）。所以尽可能用简短的，好辨识的返回值来命名，尽可能减少使用表达式。</p><h2 id="改变外部变量"><a href="#改变外部变量" class="headerlink" title="改变外部变量"></a>改变外部变量</h2><p>这里就需要用到指针了，实例如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// this function changes reply:</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Multiply</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>, reply *<span class="hljs-type">int</span>)</span></span> &#123;<br>    *reply = a * b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    n := <span class="hljs-number">0</span><br>    reply := &amp;n<br>    Multiply(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, reply)<br>    fmt.Println(<span class="hljs-string">&quot;Multiply:&quot;</span>, *reply) <span class="hljs-comment">// Multiply: 50</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以看到，我们在主函数部分让reply指向了n的地址，后续我们在Multiply函数中对reply的修改会影响到n，也就是通过*reply修改了外部变量的值。这里我们就是按引用传递而不是按值传递.</p><h2 id="传递变长参数"><a href="#传递变长参数" class="headerlink" title="传递变长参数"></a>传递变长参数</h2><p>如果函数的最后一个参数是<code>...type</code>的形式，这个函数就可以处理一个变长的参数，这个长度可以为0，故而被称为变参函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(a, b, arg ...<span class="hljs-type">int</span>)</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greeting</span><span class="hljs-params">(prefix <span class="hljs-type">string</span>, who ...<span class="hljs-type">string</span>)</span></span><br>Greeting(<span class="hljs-string">&quot;hello:&quot;</span>, <span class="hljs-string">&quot;Joe&quot;</span>, <span class="hljs-string">&quot;Anna&quot;</span>, <span class="hljs-string">&quot;Eileen&quot;</span>)<br></code></pre></td></tr></table></figure><p>在<code>Greeting</code>函数中，变量<code>who</code>便是变长参数，值便是<code>[]string&#123;&quot;Joe&quot;, &quot;Anna&quot;, &quot;Eileen&quot;&#125;</code></p><p>如果参数被存储在一个 slice 类型的变量 <code>slice</code> 中，则可以通过 <code>slice...</code> 的形式来传递参数，调用变参函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>x := min(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)<br>fmt.Printf(<span class="hljs-string">&quot;The minimum is: %d\n&quot;</span>, x)<br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>&#125;<br>x = min(slice...)<br>fmt.Printf(<span class="hljs-string">&quot;The minimum in the slice is: %d&quot;</span>, x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(s ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s)==<span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>min := s[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">if</span> v &lt; min &#123;<br>min = v<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> min<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">The minimum is: 0</span><br><span class="hljs-comment">The minimum in the slice is: 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>一个接受变长参数的函数可以将这个参数作为其他函数的参数进行传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F1</span><span class="hljs-params">(s ...<span class="hljs-type">string</span>)</span></span> &#123;<br>F2(s...)<br>F3(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F2</span><span class="hljs-params">(s ...<span class="hljs-type">string</span>)</span></span> &#123; &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F3</span><span class="hljs-params">(s []<span class="hljs-type">string</span>)</span></span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>变长参数可以作为对应类型的slice进行二次传递</p><p>如果变长参数的类型不同，有两种方式可以解决</p><ol><li>使用结构，定义一个结构类型，假设它叫<code>Options</code>，用于存储所有可能的参数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Options <span class="hljs-keyword">struct</span> &#123;<br>par1 type1,<br>par2 type2,<br>...<br>&#125;<br></code></pre></td></tr></table></figure>函数 F1() 可以使用正常的参数 a 和 b，以及一个没有任何初始化的 Options 结构： F1(a, b, Options {})。如果需要对选项进行初始化，则可以使用 F1(a, b, Options {par1:val1, par2:val2})。</li><li>使用空接口，如果一个变长参数的类型没有被指定，则默认为空接口interface{}，则就可以接入任何类型的参数。这种情况下我们不仅可以接入任何类型的参数，即使参数长度不固定也是没问题的。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">typecheck</span><span class="hljs-params">(..,..,values … <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> values &#123;<br><span class="hljs-keyword">switch</span> v := value.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-type">int</span>: …<br><span class="hljs-keyword">case</span> float: …<br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>: …<br><span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>: …<br><span class="hljs-keyword">default</span>: …<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="defer和追踪"><a href="#defer和追踪" class="headerlink" title="defer和追踪"></a>defer和追踪</h2><p>关键词<code>defer</code>允许我们推迟到函数返回之前（或任意位置执行<code>return</code>语句之后）一刻才执行某个语句或函数。而返回的原因就是在<code>return</code>中同样包含一些操作，并不是单纯返回一个值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>function1()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function1</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;In function1 at the top\n&quot;</span>)<br><span class="hljs-keyword">defer</span> function2()<br>fmt.Printf(<span class="hljs-string">&quot;In function1 at the bottom!\n&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function2</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Function2: Deferred until the end of the calling function!\n&quot;</span>)<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">In Function1 at the top</span><br><span class="hljs-comment">In Function1 at the bottom!</span><br><span class="hljs-comment">Function2: Deferred until the end of the calling function!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这里我们在执行后可以看到是在function1的第二个Println之后才去执行function2。我们再对比下去掉<code>defer</code>关键词的结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">In function1 at the top<br>Function2: Deferred until the end of the calling function!<br>In function1 at the bottom!<br></code></pre></td></tr></table></figure><p>这里我们就可以很清楚的看到，加入了<code>defer</code>关键词，我们的function2就被在运行到的时候被挂起，等function1的执行结束后立刻接在后面，这也就是概念中提到的推迟。</p><p>使用<code>defer</code>关键词还可以接受参数，下面这个例子就是因为defer直接接受了参数i &#x3D; 0，然后挂起。即使后面i &#x3D; 1还是会用挂起时的数进行输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">defer</span> fmt.Println(i)<br>i++<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当有多个<code>defer</code>行被注册时，将会以逆序进行运行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, i)<br>&#125;<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">4 3 2 1 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>defer</code>关键词的特性可以使得我们能够进行一些特殊的操作</p><ol><li>关闭文件流<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// open a file  </span><br><span class="hljs-keyword">defer</span> file.Close()<br></code></pre></td></tr></table></figure></li><li>解锁一个加锁的资源<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">mu.Lock()  <br><span class="hljs-keyword">defer</span> mu.Unlock() <br></code></pre></td></tr></table></figure></li><li>打印最终的报告<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">printHeader()  <br><span class="hljs-keyword">defer</span> printFooter()<br></code></pre></td></tr></table></figure></li><li>关闭数据库链接<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// open a database connection  </span><br><span class="hljs-keyword">defer</span> disconnectFromDB()   <br></code></pre></td></tr></table></figure></li></ol><p>下面一个实例来结合上面的第四种操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>doDBOperations()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connectToDB</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;ok, connected to db&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">disconnectFromDB</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;ok, disconnected from db&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doDBOperations</span><span class="hljs-params">()</span></span> &#123;<br>connectToDB()<br>fmt.Println(<span class="hljs-string">&quot;Defering the database disconnect.&quot;</span>)<br><span class="hljs-keyword">defer</span> disconnectFromDB() <span class="hljs-comment">//function called here with defer</span><br>fmt.Println(<span class="hljs-string">&quot;Doing some DB operations ...&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;Oops! some crash or network error ...&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;Returning from function here!&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-comment">//terminate the program</span><br><span class="hljs-comment">// deferred function executed here just before actually returning, even if</span><br><span class="hljs-comment">// there is a return or abnormal termination before</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">ok, connected to db</span><br><span class="hljs-comment">Defering the database disconnect.</span><br><span class="hljs-comment">Doing some DB operations ...</span><br><span class="hljs-comment">Oops! some crash or network error ...</span><br><span class="hljs-comment">Returning from function here!</span><br><span class="hljs-comment">ok, disconnected from db</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>还可以使用<code>defer</code>来实现追踪，下面两个函数就是很简单的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;entering:&quot;</span>, s) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">untrace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;leaving:&quot;</span>, s) &#125;<br></code></pre></td></tr></table></figure><p>结合到实际中就是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span>   &#123; fmt.Println(<span class="hljs-string">&quot;entering:&quot;</span>, s) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">untrace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;leaving:&quot;</span>, s) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br>trace(<span class="hljs-string">&quot;a&quot;</span>)<br><span class="hljs-keyword">defer</span> untrace(<span class="hljs-string">&quot;a&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;in a&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br>trace(<span class="hljs-string">&quot;b&quot;</span>)<br><span class="hljs-keyword">defer</span> untrace(<span class="hljs-string">&quot;b&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;in b&quot;</span>)<br>a()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>b()<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">entering: b</span><br><span class="hljs-comment">in b</span><br><span class="hljs-comment">entering: a</span><br><span class="hljs-comment">in a</span><br><span class="hljs-comment">leaving: a</span><br><span class="hljs-comment">leaving: b</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这里leaving先a后b是因为挂起是b先挂起，所以后输出</p><p>这里还有一个例子说明另一种<code>defer</code>语句，也就是使用<code>defer</code>语句来记录函数的参数和返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func1</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>log.Printf(<span class="hljs-string">&quot;func1(%q) = %d, %v&quot;</span>, s, n, err)<br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">7</span>, io.EOF<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>func1(<span class="hljs-string">&quot;Go&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">2024/08/09 15:17:05 func1(&quot;Go&quot;) = 7, EOF</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><code>close()</code></td><td>用于管道通信</td></tr><tr><td><code>len()</code>、<code>cap()</code></td><td><code>len()</code> 用于返回某个类型的长度或数量（字符串、数组、切片、<code>map</code> 和管道）；<code>cap()</code> 是容量的意思，用于返回某个类型的最大容量（只能用于数组、切片和管道，不能用于 <code>map</code>）</td></tr><tr><td><code>new()</code>、<code>make()</code></td><td><code>new()</code> 和 <code>make()</code> 均是用于分配内存：<code>new()</code> 用于值类型和用户定义的类型，如自定义结构，<code>make</code> 用于内置引用类型（切片、<code>map</code> 和管道）。它们的用法就像是函数，但是将类型作为参数：<code>new(type)</code>、<code>make(type)</code>。<code>new(T)</code> 分配类型 <code>T</code> 的零值并返回其地址，也就是指向类型 <code>T</code> 的指针。它也可以被用于基本类型：<code>v := new(int)</code>。<code>make(T)</code> 返回类型 <code>T</code> 的初始化之后的值，因此它比 <code>new()</code> 进行更多的工作。<code>new()</code> 是一个函数，不要忘记它的括号。</td></tr><tr><td><code>copy()</code>、<code>append()</code></td><td>用于复制和连接切片</td></tr><tr><td><code>panic()</code>、<code>recover()</code></td><td>两者均用于错误处理机制</td></tr><tr><td><code>print()</code>、<code>println()</code></td><td>底层打印函数，在部署环境中建议使用 <code>fmt</code> 包</td></tr><tr><td><code>complex()</code>、<code>real ()</code>、<code>imag()</code></td><td>用于创建和操作复数</td></tr></tbody></table><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>最经典的就是计算斐波那契数列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>result := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>result = fibonacci(i)<br>fmt.Printf(<span class="hljs-string">&quot;fibonacci(%d) is: %d\n&quot;</span>, i, result)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> (res <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<br>res = <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>res = fibonacci(n<span class="hljs-number">-1</span>) + fibonacci(n<span class="hljs-number">-2</span>)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">fibonacci(0) is: 1</span><br><span class="hljs-comment">fibonacci(1) is: 1</span><br><span class="hljs-comment">fibonacci(2) is: 2</span><br><span class="hljs-comment">fibonacci(3) is: 3</span><br><span class="hljs-comment">fibonacci(4) is: 5</span><br><span class="hljs-comment">fibonacci(5) is: 8</span><br><span class="hljs-comment">fibonacci(6) is: 13</span><br><span class="hljs-comment">fibonacci(7) is: 21</span><br><span class="hljs-comment">fibonacci(8) is: 34</span><br><span class="hljs-comment">fibonacci(9) is: 55</span><br><span class="hljs-comment">fibonacci(10) is: 89</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>go还可以函数之间相互递归调用，由于go的特性，函数声明的位置可以任意</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d is even: is %t\n&quot;</span>, <span class="hljs-number">16</span>, even(<span class="hljs-number">16</span>)) <span class="hljs-comment">// 16 is even: is true</span><br>fmt.Printf(<span class="hljs-string">&quot;%d is odd: is %t\n&quot;</span>, <span class="hljs-number">17</span>, odd(<span class="hljs-number">17</span>))<br><span class="hljs-comment">// 17 is odd: is true</span><br>fmt.Printf(<span class="hljs-string">&quot;%d is odd: is %t\n&quot;</span>, <span class="hljs-number">18</span>, odd(<span class="hljs-number">18</span>))<br><span class="hljs-comment">// 18 is odd: is false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">even</span><span class="hljs-params">(nr <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> nr == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> odd(RevSign(nr) - <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">odd</span><span class="hljs-params">(nr <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> nr == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> even(RevSign(nr) - <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RevSign</span><span class="hljs-params">(nr <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> nr &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> -nr<br>&#125;<br><span class="hljs-keyword">return</span> nr<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">16 is even: is true</span><br><span class="hljs-comment">17 is odd: is true</span><br><span class="hljs-comment">18 is odd: is false</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="闭包的补充"><a href="#闭包的补充" class="headerlink" title="闭包的补充"></a>闭包的补充</h2><p>实例中将会看到函数<code>Add2()</code>和<code>Adder()</code>均返回签名为<code>func(b_int) int</code>的函数</p><p><code>Add2()</code>不接受任何参数，而<code>Adder()</code>接受一个int类型的参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// make an Add2 function, give it a name p2, and call it:</span><br>p2 := Add2()<br>fmt.Printf(<span class="hljs-string">&quot;Call Add2 for 3 gives: %v\n&quot;</span>, p2(<span class="hljs-number">3</span>))<br><span class="hljs-comment">// make a special Adder function, a gets value 2:</span><br>TwoAdder := Adder(<span class="hljs-number">2</span>)<br>fmt.Printf(<span class="hljs-string">&quot;The result is: %v\n&quot;</span>, TwoAdder(<span class="hljs-number">3</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add2</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> b + <span class="hljs-number">2</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Adder</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面这个实例是另外一种写法实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f = Adder()<br>fmt.Print(f(<span class="hljs-number">1</span>), <span class="hljs-string">&quot; - &quot;</span>)<br>fmt.Print(f(<span class="hljs-number">20</span>), <span class="hljs-string">&quot; - &quot;</span>)<br>fmt.Print(f(<span class="hljs-number">300</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Adder</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(delta <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>x += delta<br><span class="hljs-keyword">return</span> x<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用闭包调试"><a href="#使用闭包调试" class="headerlink" title="使用闭包调试"></a>使用闭包调试</h2><p>在分析和调试复杂程序时，无数个函数在代码之间相互调用，如果能准确知道哪个文件中哪个函数在运行会对分析有很大的帮助。可以使用 <code>runtime</code> 或 <code>log</code> 包中的特殊函数来实现这样的功能。包 <code>runtime</code> 中的函数 <code>Caller()</code> 提供了相应的信息，因此可以在需要的时候实现一个 <code>where()</code> 闭包函数来打印函数执行的位置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">where := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>_, file, line, _ := runtime.Caller(<span class="hljs-number">1</span>)<br>log.Printf(<span class="hljs-string">&quot;%s:%d&quot;</span>, file, line)<br>&#125;<br>where()<br><span class="hljs-comment">// some code</span><br>where()<br><span class="hljs-comment">// some more code</span><br>where()<br></code></pre></td></tr></table></figure><p>也可以设置<code>log</code>包中的<code>flag</code>参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">log.SetFlags(log.Llongfile)<br>log.Print(<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p>或使用更精简版的<code>where()</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> where = log.Print<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span> &#123;<br>where()<br>... some code<br>where()<br>... some code<br>where()<br>&#125;<br></code></pre></td></tr></table></figure><p>这部分还是等后面再深入学吧🤣，咱连很多基础内容都没学呢。</p><p>得嘞，今儿就到这吧，bye~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天也继续学习go吧。今天找了下《The Way to Go》这本书的中译本，书作者是Ivo Balbaert。也非常感谢翻译者们的努力，在这里贴上链接&lt;a href=&quot;https://github.com/unknwon/the-way-to-go_ZH_CN.git&quot;&gt;</summary>
      
    
    
    
    <category term="学习记录" scheme="https://lx02918.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="go" scheme="https://lx02918.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/go/"/>
    
    
    <category term="学习记录" scheme="https://lx02918.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="go" scheme="https://lx02918.github.io/tags/go/"/>
    
    <category term="函数" scheme="https://lx02918.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
    <category term="指针" scheme="https://lx02918.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题记录——栈</title>
    <link href="https://lx02918.github.io/2024/08/08/leetcode-%E6%A0%88/"/>
    <id>https://lx02918.github.io/2024/08/08/leetcode-%E6%A0%88/</id>
    <published>2024-08-08T08:22:02.000Z</published>
    <updated>2024-08-27T02:26:07.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20 有效的括号"></a>20 有效的括号</h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li><p>左括号必须用相同类型的右括号闭合。</p></li><li><p>左括号必须以正确的顺序闭合。</p></li><li><p>每个右括号都有一个对应的相同类型的左括号。</p></li></ol><p>示例 1：</p><pre><code class="hljs">输入：s = &quot;()&quot;输出：true</code></pre><p>示例 2：</p><pre><code class="hljs">输入：s = &quot;()[]&#123;&#125;&quot;输出：true</code></pre><p>示例 3：</p><pre><code class="hljs">输入：s = &quot;(]&quot;输出：false</code></pre><p>提示：</p><p><code>1 &lt;= s.length &lt;= 104</code></p><p><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题基本上都多多少少做过、听过，思路基本上就是一个，遇到括号左边压入栈，遇到括号右边就匹配，成功就弹出栈顶失败就false</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        stack = []<br>        dic = &#123;<span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>:<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>:<span class="hljs-string">&#x27;&#125;&#x27;</span>&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> dic:<br>                stack.append(i)<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> dic[stack.pop()] != i:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间43ms，消耗内存16.5MB</p><h1 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71 简化路径"></a>71 简化路径</h1><p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 <code>Unix</code> 风格 <strong>绝对路径</strong> （以 <code>&#39;/&#39;</code> 开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>&#39;//&#39;</code>）都被视为单个斜杠 <code>&#39;/&#39; </code>。 对于此问题，任何其他格式的点（例如，’<code>...</code>‘）均被视为文件&#x2F;目录名称。</p><p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p><p>始终以斜杠 <code>&#39;/&#39;</code> 开头。<br>两个目录名之间必须只有一个斜杠 <code>&#39;/&#39;</code> 。<br>最后一个目录名（如果存在）不能 以 <code>&#39;/&#39;</code> 结尾。<br>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘<code>.</code>‘ 或 ‘<code>..</code>‘）。<br>返回简化后得到的 <strong>规范路径</strong> 。</p><p>示例 1：</p><pre><code class="hljs">输入：path = &quot;/home/&quot;输出：&quot;/home&quot;解释：注意，最后一个目录名后面没有斜杠。 </code></pre><p>示例 2：</p><pre><code class="hljs">输入：path = &quot;/../&quot;输出：&quot;/&quot;解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</code></pre><p>示例 3：</p><pre><code class="hljs">输入：path = &quot;/home//foo/&quot;输出：&quot;/home/foo&quot;解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</code></pre><p>示例 4：</p><pre><code class="hljs">输入：path = &quot;/a/./b/../../c/&quot;输出：&quot;/c&quot;</code></pre><p>提示：</p><p><code>1 &lt;= path.length &lt;= 3000</code></p><p><code>path</code> 由英文字母，数字，<code>&#39;.&#39;</code>，<code>&#39;/&#39;</code> 或 <code>&#39;_&#39;</code> 组成。</p><p><code>path</code> 是一个有效的 Unix 风格绝对路径。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先将所有的<code>/</code>给去掉，然后在我们没遇到<code>&#39; &#39;</code>, <code>&#39;.&#39;</code>, <code>&#39;..&#39;</code>时就会直接压入当前元素，然后当我们遇到<code>&#39;..&#39;</code>就直接将栈顶元素弹出，因为要返回上一级。最后用<code>/</code>连接每个字符并在最前面添加一个<code>/</code></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">simplifyPath</span>(<span class="hljs-params">self, path: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        stack = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> path.split(<span class="hljs-string">&#x27;/&#x27;</span>):<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;..&#x27;</span> <span class="hljs-keyword">and</span> stack:<br>                stack.pop()<br>            <span class="hljs-keyword">elif</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;..&#x27;</span>]:<br>                stack.append(i)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;/&#x27;</span> + <span class="hljs-string">&#x27;/&#x27;</span>.join(stack)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间49ms，消耗内存16.3MB</p><h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155 最小栈"></a>155 最小栈</h1><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><p><code>MinStack()</code> 初始化堆栈对象。<br><code>void push(int val)</code> 将元素val推入堆栈。<br><code>void pop()</code> 删除堆栈顶部的元素。<br><code>int top()</code> 获取堆栈顶部的元素。<br><code>int getMin()</code> 获取堆栈中的最小元素。</p><p>示例 1:</p><p>输入：</p><pre><code class="hljs">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]</code></pre><p>输出：</p><pre><code class="hljs">[null,null,null,null,-3,null,0,-2] </code></pre><p>解释：</p><pre><code class="hljs">MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre><p>提示：</p><p><code>-231 &lt;= val &lt;= 231 - 1</code></p><p><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</p><p><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 104</code> 次</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这里基本上都是采用辅助栈的形式去做，做法其实大差不差</p><p>四个函数分别说一下</p><p><code>push</code>，每当我们push一个新值进来，如果小于等于辅助栈的栈顶则一起push到辅助栈，也就更新了最小值</p><p><code>pop</code>，如果栈顶和辅助栈的栈顶一样，两个都pop，保证最小值在辅助栈中</p><p><code>top</code>，返回主栈栈顶元素</p><p><code>getMin</code>，返回辅助栈栈顶元素也即最小值</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span>:<br>    <span class="hljs-comment"># 初始化两个栈，一个用于存储所有元素，另一个用于存储最小元素</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.stack = []<br>        <span class="hljs-variable language_">self</span>.min_stack = []<br><br>    <span class="hljs-comment"># 向栈中添加元素，并更新最小元素栈</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-variable language_">self</span>.stack.append(val)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.min_stack <span class="hljs-keyword">or</span> val &lt;= <span class="hljs-variable language_">self</span>.min_stack[-<span class="hljs-number">1</span>]:<br>            <span class="hljs-variable language_">self</span>.min_stack.append(val)<br><br>    <span class="hljs-comment"># 从栈中移除元素，并更新最小元素栈</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        x = <span class="hljs-variable language_">self</span>.stack.pop()<br>        <span class="hljs-keyword">if</span> x == <span class="hljs-variable language_">self</span>.min_stack[-<span class="hljs-number">1</span>]:<br>            <span class="hljs-variable language_">self</span>.min_stack.pop()<br><br>    <span class="hljs-comment"># 获取栈顶元素</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.stack[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-comment"># 获取栈中的最小元素</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMin</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.min_stack[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(1)，执行时间59ms，消耗内存20MB</p><p>这里容易有一个误区就是pop的时候我们把辅助栈的最小元素给pop了，那么我们是不是就没有辅助栈了呢。并不是，辅助栈也是会被更新的，如果我们在pop的下一个就需要运行getMin了，那得到的就肯定为空了。当我们在后续还有新的push，那必然获得的就不是这个为空的了。</p><h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150 逆波兰表达式求值"></a>150 逆波兰表达式求值</h1><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p>注意：</p><p>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</p><p>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</p><p>两个整数之间的除法总是 <strong>向零截断</strong> 。</p><p>表达式中不含除零运算。</p><p>输入是一个根据逆波兰表示法表示的算术表达式。</p><p>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</p><p>示例 1：</p><pre><code class="hljs">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]输出：9解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</code></pre><p>示例 2：</p><pre><code class="hljs">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]输出：6解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</code></pre><p>示例 3：</p><pre><code class="hljs">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]输出：22解释：该算式转化为常见的中缀算术表达式为：((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22</code></pre><p>提示：</p><p><code>1 &lt;= tokens.length &lt;= 104</code></p><p><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</p><p>逆波兰表达式：</p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><p>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</p><p>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</p><p>逆波兰表达式主要有以下两个优点：</p><p>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + *</code> 也可以依据次序计算出正确结果。</p><p>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先第一个需要理解的点是逆波兰表达式是一个后缀表达式，所以我们可以先将后缀表达式转换为逆波兰表达式，并计算结果。而我们常用的计算式是中缀表达式，所以明白了这点就可以大概构思出怎么做。</p><p>接下来我们需要想到几个问题。</p><p>第一当用例中出现负数怎么办，负数我们可以直接转换为<code>-</code> + <code>num</code>这样就变相的改成了计算式，然后数字直接int为整数就行。</p><p>第二，当我们看到题目中的第三条时会有一个很无语的事情，就是除法需要 <strong>向零截断</strong>，而python的除余结果是直接向下取整。然而，在我们第一步的操作后，我们直接解决了这个问题，唯一需要注意的是我们除式的结果需要转化为int型变量</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">evalRPN</span>(<span class="hljs-params">self, tokens: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        stack = []<br>        dic = &#123;<span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">lambda</span> x,y:x+y, <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">lambda</span> x,y:x-y, <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">lambda</span> x,y:x*y, <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">lambda</span> x,y:<span class="hljs-built_in">int</span>(x/y)&#125;<br>        <span class="hljs-comment"># 定义一个字典dic，存储运算符和对应的lambda函数，用于执行相应的算术操作</span><br>        <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> tokens:<br>            <span class="hljs-comment"># 遍历tokens列表中的每一个token</span><br>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">in</span> dic:<br>                <span class="hljs-comment"># 如果token是运算符</span><br>                y = stack.pop()<br>                x = stack.pop()<br>                <span class="hljs-comment"># 从stack中弹出两个操作数</span><br>                stack.append(dic[token](x,y))<br>                <span class="hljs-comment"># 执行相应的算术操作，并将结果压入stack</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 如果token是操作数</span><br>                stack.append(<span class="hljs-built_in">int</span>(token))<br>                <span class="hljs-comment"># 将token转换为整数并压入stack</span><br>        <span class="hljs-keyword">return</span> stack[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># 返回stack中唯一的元素，即逆波兰表达式的计算结果</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间40ms，消耗内存18.2MB</p><h1 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224 基本计算器"></a>224 基本计算器</h1><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval() </code>。</p><p>示例 1：</p><pre><code class="hljs">输入：s = &quot;1 + 1&quot;输出：2</code></pre><p>示例 2：</p><pre><code class="hljs">输入：s = &quot; 2-1 + 2 &quot;输出：3</code></pre><p>示例 3：</p><pre><code class="hljs">输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;输出：23</code></pre><p>提示：</p><p><code>1 &lt;= s.length &lt;= 3 * 105</code></p><p><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</p><p><code>s</code> 表示一个有效的表达式</p><p><code>&#39;+&#39;</code> 不能用作一元运算(例如， <code>&quot;+1&quot;</code> 和 <code>&quot;+(2 + 3)&quot;</code> 无效)</p><p><code>&#39;-&#39;</code> 可以用作一元运算(即 <code>&quot;-1&quot;</code> 和 <code>&quot;-(2 + 3)&quot;</code> 是有效的)</p><p>输入中不存在两个连续的操作符</p><p>每个数字和运行的计算将适合于一个有符号的 <strong>32位</strong> 整数</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这个问题的核心是如何处理加减法运算，并正确处理括号内的优先级。我们可以通过以下步骤来解决问题：</p><ol><li><p>符号转换：我们将 <code>+</code> 用 <code>1</code> 表示，将 <code>-</code> 用 <code>-1</code> 表示。这样，当遇到加减号时，可以通过将当前数字乘以符号值来简化运算过程。</p></li><li><p>处理括号：当遇到左括号 <code>(</code> 时，需要将当前的计算结果和运算符号压入栈中，保存当前的运算状态。这是因为括号内的运算结果会影响括号外的结果。遇到右括号 <code>)</code> 时，需要弹出栈顶的运算符号和结果，并将括号内的计算结果与之相结合。</p></li></ol><p>示例<br>例如对于表达式 <code>(1+(4+5+2)-3)+(6+8)</code>，我们首先处理最内层的括号，然后逐步将结果合并到外层的运算中。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        stack = []<br>        num = <span class="hljs-number">0</span><br>        sign = <span class="hljs-number">1</span>  <span class="hljs-comment"># 1表示加号，-1表示减号</span><br>        result = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> char.isdigit():<br>                num = num * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(char)<br>            <span class="hljs-keyword">elif</span> char == <span class="hljs-string">&#x27;+&#x27;</span>:<br>                result += sign * num<br>                num = <span class="hljs-number">0</span><br>                sign = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> char == <span class="hljs-string">&#x27;-&#x27;</span>:<br>                result += sign * num<br>                num = <span class="hljs-number">0</span><br>                sign = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> char == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                stack.append(result)<br>                stack.append(sign)<br>                result = <span class="hljs-number">0</span><br>                sign = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> char == <span class="hljs-string">&#x27;)&#x27;</span>:<br>                result += sign * num<br>                num = <span class="hljs-number">0</span><br>                result *= stack.pop()  <span class="hljs-comment"># 乘以括号前的符号</span><br>                result += stack.pop()  <span class="hljs-comment"># 加上括号前的结果</span><br>        <br>        <span class="hljs-comment"># 处理最后一个数字</span><br>        result += sign * num<br>        <br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度：O(n)，执行时间57ms，消耗内存16.9MB</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;20-有效的括号&quot;&gt;&lt;a href=&quot;#20-有效的括号&quot; class=&quot;headerlink&quot; title=&quot;20 有效的括号&quot;&gt;&lt;/a&gt;20 有效的括号&lt;/h1&gt;&lt;p&gt;给定一个只包括 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;)&amp;</summary>
      
    
    
    
    <category term="刷题记录" scheme="https://lx02918.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Leetcode" scheme="https://lx02918.github.io/tags/Leetcode/"/>
    
    <category term="刷题" scheme="https://lx02918.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="栈" scheme="https://lx02918.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>go学习记录——第二天</title>
    <link href="https://lx02918.github.io/2024/08/08/go-study-second-day/"/>
    <id>https://lx02918.github.io/2024/08/08/go-study-second-day/</id>
    <published>2024-08-08T06:51:12.000Z</published>
    <updated>2024-08-15T07:53:04.891Z</updated>
    
    <content type="html"><![CDATA[<p>今儿继续学go，争取多学点吧，不过感觉困死了，不一定能学多少。</p><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p>惊奇的发现go是没有while循环的，全靠for实现</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>一共三种形式</p><ol><li><code>for init; condition; post &#123;&#125;</code></li><li><code>for condition &#123;&#125;</code></li><li><code>for &#123;&#125;</code></li></ol><p>第一种就是和C差不多的，初始化；条件；后置语句，用来控制循环的次数</p><p>第二种类似于while</p><p>第三种用来无限循环，直到遇到break</p><p>for循环还能对map、slice、数组、字符串进行迭代循环，语法如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> oldMap &#123;<br>    newMap[key] = value<br>&#125;<br></code></pre></td></tr></table></figure><p>其中key和value都是可以省略的，省略的话就只会迭代key，或者只会迭代value</p><p>如果想只读key</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> oldMap<br></code></pre></td></tr></table></figure><p>如果想只读value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> oldMap<br></code></pre></td></tr></table></figure><h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><p>和别的一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> [condition |  ( init; condition; increment ) | Range]<br>&#123;<br>   <span class="hljs-keyword">for</span> [condition |  ( init; condition; increment ) | Range]<br>   &#123;<br>      statement(s)<br>   &#125;<br>   statement(s)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p><code>for</code> 和 <code>switch</code> 都可以用</p><p>唯一需要注意啊的是break和别的不同的一点是可以添加<code>label</code>也就是标签。使用时可以添加在最前面就比如下面这个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>outerLoop: <span class="hljs-comment">// 定义一个名为 outerLoop 的标签</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++ &#123;<br><span class="hljs-keyword">if</span> j == <span class="hljs-number">3</span> &#123;<br><span class="hljs-keyword">break</span> outerLoop <span class="hljs-comment">// 跳出 outerLoop 标签的循环</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;i=%d, j=%d\n&quot;</span>, i, j)<br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;循环结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用outerLoop标记了两层循环，最后跳出循环后继续走下面的代码</p><p>switch和select都可以用break，但通常都用于最后一个case。但select中如果想使用break，虽然可以但理论上由于是非阻塞式循环，是在所有通道匹配后才会输出，break就会影响这个效果。所以通常使用return或goto来跳出循环。</p><p>但这里还有一个问题，由于goto是直接直接去到标记的位置，所以对select来说其实会影响代码的可读性，所以通常还是用return。关于goto后面还会有内容。</p><p>return的例子如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>c2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(time.Second)<br>c1 &lt;- <span class="hljs-number">1</span><br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>c2 &lt;- <span class="hljs-string">&quot;hello&quot;</span><br>&#125;()<br><br><span class="hljs-comment">// 使用 return 跳出 select 语句</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> v := &lt;-c1:<br>fmt.Println(<span class="hljs-string">&quot;received from c1:&quot;</span>, v)<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// 退出函数</span><br><span class="hljs-keyword">case</span> v := &lt;-c2:<br>fmt.Println(<span class="hljs-string">&quot;received from c2:&quot;</span>, v)<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// 退出函数</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>和别的没什么区别</p><p>唯一需要注意的不同就是label</p><p>go的continue也可以使用label去进行操作，例子如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>outerLoop: <span class="hljs-comment">// 定义一个名为 outerLoop 的标签</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++ &#123;<br><span class="hljs-keyword">if</span> j == <span class="hljs-number">3</span> &#123;<br><span class="hljs-keyword">continue</span> outerLoop <span class="hljs-comment">// 跳过当前外层循环的剩余迭代</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;i=%d, j=%d\n&quot;</span>, i, j)<br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;循环结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><p>goto就像前面说的，无条件直达某个位置，这也就导致了代码的结构性和可读性变差，所以能不用就不用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">goto</span> label;<br>..<br>.<br>label: statement;<br></code></pre></td></tr></table></figure><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 定义局部变量 */</span><br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br><br>   <span class="hljs-comment">/* 循环 */</span><br>   LOOP: <span class="hljs-keyword">for</span> a &lt; <span class="hljs-number">20</span> &#123;<br>      <span class="hljs-keyword">if</span> a == <span class="hljs-number">15</span> &#123;<br>         <span class="hljs-comment">/* 跳过迭代 */</span><br>         a = a + <span class="hljs-number">1</span><br>         <span class="hljs-keyword">goto</span> LOOP<br>      &#125;<br>      fmt.Printf(<span class="hljs-string">&quot;a的值为 : %d\n&quot;</span>, a)<br>      a++     <br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-literal">true</span>  &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;这是无限循环。\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>和别的一样，概念没啥好说的</p><p>函数格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function_name</span><span class="hljs-params">( [parameter list] )</span></span> [return_types] &#123;<br>   函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>func：函数从<code>func</code>开始声明<br>function_name：函数名称<br>parameter list：参数列表<br>return_types：返回类型，可以省略<br>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 函数返回两个数的最大值 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(num1, num2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-comment">/* 声明局部变量 */</span><br>   <span class="hljs-keyword">var</span> result <span class="hljs-type">int</span><br><br>   <span class="hljs-keyword">if</span> (num1 &gt; num2) &#123;<br>      result = num1<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      result = num2<br>   &#125;<br>   <span class="hljs-keyword">return</span> result <br>&#125;<br></code></pre></td></tr></table></figure><p>函数调用和python没区别，一个道理</p><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数参数依旧是形参非实参</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 定义相互交换值的函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br><br>   temp = x <span class="hljs-comment">/* 保存 x 的值 */</span><br>   x = y    <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>   y = temp <span class="hljs-comment">/* 将 temp 值赋给 y*/</span><br><br>   <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终如果调用函数，则函数内将交换值，但全局变量并不会变。</p><h2 id="引用传递值"><a href="#引用传递值" class="headerlink" title="引用传递值"></a>引用传递值</h2><p>这里用到指针进行操作，由于指针指向的是实际存储地址，所以在交换后将直接对变量所指向的地址进行改变，进而改变变量值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 定义交换值函数*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x *<span class="hljs-type">int</span>, y *<span class="hljs-type">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br>   temp = *x    <span class="hljs-comment">/* 保持 x 地址上的值 */</span><br>   *x = *y      <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>   *y = temp    <span class="hljs-comment">/* 将 temp 值赋给 y */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数作为实参"><a href="#函数作为实参" class="headerlink" title="函数作为实参"></a>函数作为实参</h2><p>go中可以将函数直接传递给某个变量而作为实参</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-comment">/* 声明函数变量 */</span><br>   getSquareRoot := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>      <span class="hljs-keyword">return</span> math.Sqrt(x)<br>   &#125;<br><br>   <span class="hljs-comment">/* 使用函数 */</span><br>   fmt.Println(getSquareRoot(<span class="hljs-number">9</span>))<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包（匿名函数）"><a href="#闭包（匿名函数）" class="headerlink" title="闭包（匿名函数）"></a>闭包（匿名函数）</h2><p>匿名函数是一个“内联”语句或表达式，优点在于可以直接使用函数内的变量，不用声明。</p><p>匿名函数是无需命名的函数，可以被赋值给变量，方便后续调用。它们可以访问定义时的外部变量，但只访问了这些变量的副本，不会改变外部变量的值。</p><p>当调用匿名函数并传递参数时，参数会覆盖函数内部的同名变量，函数执行完毕后，这些参数会恢复到初始状态。</p><p>匿名函数的优势在于可以方便地创建临时函数，避免重复代码。</p><p>闭包是匿名函数的一个重要特性，它允许匿名函数访问外部变量，即使外部函数已经执行完毕。这里访问的是外部变量的初始参数，而不是副本。</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getSequence</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>   i:=<span class="hljs-number">0</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>      i+=<span class="hljs-number">1</span><br>     <span class="hljs-keyword">return</span> i  <br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-comment">/* nextNumber 为一个函数，函数 i 为 0 */</span><br>   nextNumber := getSequence()  <br><br>   <span class="hljs-comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span><br>   fmt.Println(nextNumber())<br>   fmt.Println(nextNumber())<br>   fmt.Println(nextNumber())<br>   <br>   <span class="hljs-comment">/* 创建新的函数 nextNumber1，并查看结果 */</span><br>   nextNumber1 := getSequence()  <br>   fmt.Println(nextNumber1())<br>   fmt.Println(nextNumber1())<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">output:</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>go中除了函数还有方法，是与特定类型（结构体、接口等）关联的函数，将接收者作为函数的第一个参数。接收者可以是值类型（值拷贝）或指针类型（指针引用）。方法调用时，会将接收者作为第一个参数传递给方法函数，然后方法函数会根据接收者的值或指针进行计算。</p><p>方法的声明格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(variable_name variable_data_type)</span></span> function_name() [return_type]&#123;<br>   <span class="hljs-comment">/* 函数体*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Rectangle <span class="hljs-keyword">struct</span> &#123;<br>Width  <span class="hljs-type">int</span><br>Height <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 方法：计算矩形的面积</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r Rectangle)</span></span> Area() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> r.Width * r.Height<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>rect := Rectangle&#123;Width: <span class="hljs-number">10</span>, Height: <span class="hljs-number">5</span>&#125;<br>area := rect.Area() <span class="hljs-comment">// 调用方法</span><br>fmt.Println(<span class="hljs-string">&quot;面积:&quot;</span>, area) <span class="hljs-comment">// 输出：面积: 50</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Area</code> 方法与 <code>Rectangle</code> 类型关联。当调用 <code>rect.Area()</code> 时，<code>rect</code> 作为接收者被传递给 <code>Area</code> 方法，方法内部使用 <code>r.Width</code> 和 <code>r.Height</code> 计算面积。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>方法是与特定类型关联的函数。</li><li>方法的第一个参数是接收者，可以是值类型或指针类型。</li><li>方法调用时，会将接收者作为第一个参数传递给方法函数。</li><li>方法函数会根据接收者的值或指针进行计算。</li></ul><h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>作用域控制代码中各种元素的使用范围，如包、结构体、变量、函数、方法、常量</p><p>具体来看可以分成三个</p><ul><li>局部变量——函数级作用域</li><li>全局变量——包级作用域</li><li>块级作用域</li><li>形参变量——函数参数</li></ul><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>函数内定义的变量称为局部变量，参数和返回值均为局部变量</p><p>变量用<code>var</code>定义</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 声明局部变量 */</span><br>   <span class="hljs-keyword">var</span> a, b, c <span class="hljs-type">int</span> <br><br>   <span class="hljs-comment">/* 初始化参数 */</span><br>   a = <span class="hljs-number">10</span><br>   b = <span class="hljs-number">20</span><br>   c = a + b<br><br>   fmt.Printf (<span class="hljs-string">&quot;结果： a = %d, b = %d and c = %d\n&quot;</span>, a, b, c)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>函数外定义的变量称为全局变量全局变量可以在整个包（甚至包导出后）使用</p><p>变量用<code>var</code>定义，在包的顶部定义</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">/* 声明全局变量 */</span><br><span class="hljs-keyword">var</span> g <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>   <span class="hljs-comment">/* 声明局部变量 */</span><br>   <span class="hljs-keyword">var</span> a, b <span class="hljs-type">int</span><br><br>   <span class="hljs-comment">/* 初始化参数 */</span><br>   a = <span class="hljs-number">10</span><br>   b = <span class="hljs-number">20</span><br>   g = a + b<br><br>   fmt.Printf(<span class="hljs-string">&quot;结果： a = %d, b = %d and g = %d\n&quot;</span>, a, b, g)<br>&#125;<br></code></pre></td></tr></table></figure><p>在整个代码中，全局变量和局部变量的名称可以是一样的，但在函数内优先使用局部变量。这个和别的是一样的</p><h2 id="形参变量"><a href="#形参变量" class="headerlink" title="形参变量"></a>形参变量</h2><p>形参变量只能在函数内使用，一般作为函数内的局部变量使用</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>在代码块（<code>for</code>, <code>if</code>, <code>switch</code> 等）中，变量的作用范围为这个代码块。</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br>        blockVar := <span class="hljs-number">30</span> <span class="hljs-comment">// 块级作用域</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>今天就到这里吧，虽然但是，总感觉最近学习状态好差，得想办法调整调整了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今儿继续学go，争取多学点吧，不过感觉困死了，不一定能学多少。&lt;/p&gt;
&lt;h1 id=&quot;循环语句&quot;&gt;&lt;a href=&quot;#循环语句&quot; class=&quot;headerlink&quot; title=&quot;循环语句&quot;&gt;&lt;/a&gt;循环语句&lt;/h1&gt;&lt;p&gt;惊奇的发现go是没有while循环的，全靠fo</summary>
      
    
    
    
    <category term="学习记录" scheme="https://lx02918.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="go" scheme="https://lx02918.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/go/"/>
    
    
    <category term="学习记录" scheme="https://lx02918.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="go" scheme="https://lx02918.github.io/tags/go/"/>
    
    <category term="循环语句" scheme="https://lx02918.github.io/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
    
    <category term="函数" scheme="https://lx02918.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
    <category term="变量作用域" scheme="https://lx02918.github.io/tags/%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>go学习记录——第一天</title>
    <link href="https://lx02918.github.io/2024/08/07/go-study-first-day/"/>
    <id>https://lx02918.github.io/2024/08/07/go-study-first-day/</id>
    <published>2024-08-07T02:49:32.000Z</published>
    <updated>2024-08-15T07:51:59.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go的基本组成部分"><a href="#go的基本组成部分" class="headerlink" title="go的基本组成部分"></a>go的基本组成部分</h1><ul><li>包声明</li><li>引入包</li><li>函数</li><li>变量</li><li>语句 &amp; 表达式</li><li>注释</li></ul><h1 id="go变量声明"><a href="#go变量声明" class="headerlink" title="go变量声明"></a>go变量声明</h1><p>go中用var来声明变量，语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> variableName dataType<br></code></pre></td></tr></table></figure><p>其中，variableName为变量名，dataType为变量的数据类型。</p><p>一次声明多个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    variable1 dataType1<br>    variable2 dataType2<br>    variable3 dataType3<br>)<br></code></pre></td></tr></table></figure><p>第一种，指定变量类型，如果没有初始化则默认为0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v_name v_type<br>v_name = value<br>或<br><span class="hljs-keyword">var</span> v_name v_type = value<br></code></pre></td></tr></table></figure><p>第二种，不指定类型，由编译器自动推导</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v_name = value<br></code></pre></td></tr></table></figure><p>第三种，短变量声明，在函数内使用，注意当已经进行了变量声明再使用短声明会报错。短声明只适用于函数内使用，不能在全局作用域使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">v_name := value<br></code></pre></td></tr></table></figure><p>第四种，多变量声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    v1, v2, v3 = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;hello&quot;</span><br>)<br>或<br><span class="hljs-keyword">var</span> v1, v2, v3 = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-comment">// 这个为主使用，和python类似，迁移起来较快</span><br>或<br>v1, v2, v3 := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><h1 id="go常量声明"><a href="#go常量声明" class="headerlink" title="go常量声明"></a>go常量声明</h1><p>只能使用布尔型、数字型（int, float, 复数）和字符串型</p><p>常量定义格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> constantName  [<span class="hljs-keyword">type</span>]= value<br></code></pre></td></tr></table></figure><p>多个常量声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> constantName1, constantName2 = value1, value2<br></code></pre></td></tr></table></figure><p>常量中可以使用内置函数进行运算，如len(), cap(), unsafe.Sizeof()等。</p><h2 id="inta"><a href="#inta" class="headerlink" title="inta"></a>inta</h2><p>inta是go中的特殊常量，可以当作一个可以被编译成功的常量</p><p>inta在const关键词出现时将被重置为0，const中每加一行都将使inta加1。</p><p>inta可以做枚举值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    a = inta<br>    b = inta<br>    c = inta<br>)<br></code></pre></td></tr></table></figure><p>inta也可以做一个类似行索引的功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    a = inta<br>    b<br>    c<br>)<br></code></pre></td></tr></table></figure><p>输出的结果就是<code>a=0, b=1, c=2</code>。</p><p>inta用法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>a = <span class="hljs-literal">iota</span><br>b<br>c<br>d = <span class="hljs-string">&quot;ha&quot;</span><br>e<br>f = <span class="hljs-number">100</span><br>g<br>h = <span class="hljs-literal">iota</span><br>i<br>)<br><br>fmt.Println(a, b, c, d, e, f, g, h, i)<br>&#125;<br><span class="hljs-comment">// output：</span><br><span class="hljs-comment">// 0 1 2 ha 4 100 6 7 8</span><br></code></pre></td></tr></table></figure><h1 id="go的运算符"><a href="#go的运算符" class="headerlink" title="go的运算符"></a>go的运算符</h1><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><ol><li><p>++ 自增，和+&#x3D;1类似</p></li><li><p>– 自减，和-&#x3D;1类似</p></li></ol><p>别的和python一样</p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>和python一样，直接忽略</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ol><li><p>&amp;&amp; -&gt; and</p></li><li><p>|| -&gt; or</p></li><li><p>!  -&gt; not</p></li></ol><p>从字母换成了符号，其他没区别</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ol><li><p>&amp;  -&gt; 按位与</p></li><li><p>|  -&gt; 按位或</p></li><li><p>^  -&gt; 按位异或</p></li><li><p>&lt;&lt; -&gt; 左移</p></li><li><blockquote><blockquote><p>-&gt; 右移</p></blockquote></blockquote></li><li><p>~  -&gt; 按位取反</p></li></ol><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ol><li>&lt;&lt;&#x3D; -&gt; 左移后赋值</li><li><blockquote><blockquote><p>&#x3D; -&gt; 右移后赋值</p></blockquote></blockquote></li><li>&amp;&#x3D;  -&gt; 按位与后赋值</li><li>|&#x3D;  -&gt; 按位或后赋值</li><li>^&#x3D;  -&gt; 按位异或后赋值</li></ol><p>其他和python一样</p><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><ol><li>&amp; -&gt; 返回实际地址</li><li>‘*’  -&gt; 指针变量</li></ol><h2 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h2><table><thead><tr><th>优先级</th><th>运算符</th></tr></thead><tbody><tr><td>1 一元运算符</td><td>*   &amp;（取地址） +（正号） -（负号）! ~（按位异或）</td></tr><tr><td>2 乘除类运算符</td><td>*  &#x2F;  %  &lt;&lt;  &gt;&gt; &amp;（按位与） &amp;^（按位清除）</td></tr><tr><td>3 加减类运算符</td><td>+  - ‘</td></tr><tr><td>4 关系运算符</td><td>&#x3D;&#x3D; !&#x3D;  &lt;  &lt;&#x3D;  &gt;  &gt;&#x3D;</td></tr><tr><td>5 逻辑运算符</td><td>&amp;&amp;  逻辑或（符号markdown无法显示就用文字代替了）</td></tr></tbody></table><h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><p>和python一样，但编写方式有些不同</p><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 布尔表达式 &#123;<br>   <span class="hljs-comment">/* 在布尔表达式为 true 时执行 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 布尔表达式 &#123;<br>   <span class="hljs-comment">/* 在布尔表达式为 true 时执行 */</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">/* 在布尔表达式为 false 时执行 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="if…else-if…else"><a href="#if…else-if…else" class="headerlink" title="if…else if…else"></a>if…else if…else</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 布尔表达式<span class="hljs-number">1</span> &#123;<br>   <span class="hljs-comment">/* 在布尔表达式1为 true 时执行 */</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> 布尔表达式<span class="hljs-number">2</span> &#123;<br>   <span class="hljs-comment">/* 在布尔表达式2为 true 时执行 */</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">/* 在布尔表达式1和表达式2都为 false 时执行 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> 表达式 &#123;<br>   <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:<br>      <span class="hljs-comment">/* 当表达式的值等于值1时执行 */</span><br>      <span class="hljs-keyword">break</span><br>   <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>      <span class="hljs-comment">/* 当表达式的值等于值2时执行 */</span><br>      <span class="hljs-keyword">break</span><br>   <span class="hljs-keyword">default</span>:<br>      <span class="hljs-comment">/* 当以上都不满足时执行 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Type-Swith"><a href="#Type-Swith" class="headerlink" title="Type Swith"></a>Type Swith</h3><p>用于判断某个interface变量的实际类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> x.(<span class="hljs-keyword">type</span>)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-keyword">type</span>:<br>       statement(s);      <br>    <span class="hljs-keyword">case</span> <span class="hljs-keyword">type</span>:<br>       statement(s); <br>    <span class="hljs-comment">/* 你可以定义任意个数的case */</span><br>    <span class="hljs-keyword">default</span>: <span class="hljs-comment">/* 可选 */</span><br>       statement(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>例子如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125;<br>     <br>   <span class="hljs-keyword">switch</span> i := x.(<span class="hljs-keyword">type</span>) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:   <br>         fmt.Printf(<span class="hljs-string">&quot; x 的类型 :%T&quot;</span>,i)                <br>      <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:   <br>         fmt.Printf(<span class="hljs-string">&quot;x 是 int 型&quot;</span>)                       <br>      <span class="hljs-keyword">case</span> <span class="hljs-type">float64</span>:<br>         fmt.Printf(<span class="hljs-string">&quot;x 是 float64 型&quot;</span>)           <br>      <span class="hljs-keyword">case</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">float64</span>:<br>         fmt.Printf(<span class="hljs-string">&quot;x 是 func(int) 型&quot;</span>)                      <br>      <span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>, <span class="hljs-type">string</span>:<br>         fmt.Printf(<span class="hljs-string">&quot;x 是 bool 或 string 型&quot;</span> )       <br>      <span class="hljs-keyword">default</span>:<br>         fmt.Printf(<span class="hljs-string">&quot;未知型&quot;</span>)     <br>   &#125;   <br>&#125;<br><br>output:<br>x 的类型 : &lt;<span class="hljs-literal">nil</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="fullthrough"><a href="#fullthrough" class="headerlink" title="fullthrough"></a>fullthrough</h3><p>强制执行case后语句，不会判断是否为true<br>即使用了fullthrough，也可以直接用break跳出switch</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>此select非彼select。不是SQL中的那个查看</p><p>这里的select虽然类似switch，但只能作用于通道，一个case只能进行接受或发送</p><p>select会监听每个通道，只要有一个case准备好了就立马执行。如果多个准备好就随机挑选一个。如果一个都没准备好执行default。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br>  <span class="hljs-keyword">case</span> &lt;- channel1:<br>    <span class="hljs-comment">// 执行的代码</span><br>  <span class="hljs-keyword">case</span> value := &lt;- channel2:<br>    <span class="hljs-comment">// 执行的代码</span><br>  <span class="hljs-keyword">case</span> channel3 &lt;- value:<br>    <span class="hljs-comment">// 执行的代码</span><br><br>    <span class="hljs-comment">// 你可以定义任意数量的 case</span><br><br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 所有通道都没有准备好，执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意</p><ul><li>每一个case都必须对应一个通道</li><li>所有channel表达式都会被求值</li><li>所有被发送的表达式都会被求值</li><li>如果有default则会在case均未准备好时执行。如果没有则会阻塞，直到有通道可以运行。Go不会重新对channel或值进行求值</li></ul><p>今儿的就学到这里吧，感觉上在语句写法上和C类似。不过可能是我一直用Python所以还有点不习惯用花括号来作为代码块的感觉。慢慢习惯吧，今儿没啥心情，感觉学不下去了，休息咯~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;go的基本组成部分&quot;&gt;&lt;a href=&quot;#go的基本组成部分&quot; class=&quot;headerlink&quot; title=&quot;go的基本组成部分&quot;&gt;&lt;/a&gt;go的基本组成部分&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;包声明&lt;/li&gt;
&lt;li&gt;引入包&lt;/li&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="学习记录" scheme="https://lx02918.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="go" scheme="https://lx02918.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/go/"/>
    
    
    <category term="学习记录" scheme="https://lx02918.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="go" scheme="https://lx02918.github.io/tags/go/"/>
    
    <category term="基本概念" scheme="https://lx02918.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    
    <category term="条件语句" scheme="https://lx02918.github.io/tags/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
</feed>
