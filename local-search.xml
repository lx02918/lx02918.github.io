<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode刷题记录——二分查找</title>
    <link href="/2024/09/09/leetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2024/09/09/leetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="35-搜索插入位置-Easy"><a href="#35-搜索插入位置-Easy" class="headerlink" title="35 搜索插入位置 Easy"></a>35 <a href="https://leetcode.cn/problems/search-insert-position/">搜索插入位置</a> <font color=#7fffd4 size=4>Easy</font></h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 5</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 2</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 7</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不多说，都会</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[mid] == target:<br>                <span class="hljs-keyword">return</span> mid<br>            <span class="hljs-keyword">elif</span> nums[mid] &lt; target:<br>                left = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> left<br></code></pre></td></tr></table></figure><h1 id="74-搜索二维矩阵-Medium"><a href="#74-搜索二维矩阵-Medium" class="headerlink" title="74 搜索二维矩阵 Medium"></a>74 <a href="https://leetcode.cn/problems/search-a-2d-matrix/">搜索二维矩阵</a> <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p><ul><li>每行中的整数从左到右按非严格递增顺序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,3,5,7],[10,11,16,20],[23,30,34,60]]</span>, target = <span class="hljs-number">3</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,3,5,7],[10,11,16,20],[23,30,34,60]]</span>, target = <span class="hljs-number">13</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>-104 &lt;= matrix[i][j], target &lt;= 104</code></li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>其实和前一题一样，但有几个需要注意的点</p><ol><li>由于是二维数组，我们的mid是线性索引，所以需要一个额外变量表示mid位置的元素</li><li>三个条件判断需要用到的是额外变量而不是mid索引指向</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchMatrix</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> matrix <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> matrix[<span class="hljs-number">0</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        rows, cols = <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>        left, right = <span class="hljs-number">0</span>, rows * cols - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            mid_value = matrix[mid // cols][mid % cols]<br>            <span class="hljs-keyword">if</span> mid_value == target:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span> mid_value &lt; target:<br>                left = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(log(n * m))，空间复杂度O(1)，执行时间44ms，消耗内存16.8MB</p><h1 id="162-寻找峰值-Medium"><a href="#162-寻找峰值-Medium" class="headerlink" title="162 寻找峰值 Medium"></a>162 <a href="https://leetcode.cn/problems/find-peak-element/">寻找峰值</a> <font color=#ff7f50 size=4>Medium</font></h1><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p><p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,1</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">3</span> 是峰值元素，你的函数应该返回其索引 <span class="hljs-number">2</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,2,1,3,5,6,4]</span><br>输出：<span class="hljs-number">1</span> 或 <span class="hljs-number">5</span> <br>解释：你的函数可以返回索引 <span class="hljs-number">1</span>，其峰值元素为 <span class="hljs-number">2</span>；<br>     或者返回索引 <span class="hljs-number">5</span>， 其峰值元素为 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li>对于所有有效的 <code>i</code> 都有 <code>nums[i] != nums[i + 1]</code></li></ul><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>逻辑上都差不多，需要注意的是严格大于两边我们只取大于小于右边作为主要条件</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findPeakElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>]:<br>                right = mid<br>            <span class="hljs-keyword">else</span>:<br>                left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> left<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(log n)，空间复杂度O(1)，执行时间33ms，消耗内存16.6MB</p><h1 id="33-搜索旋转排序数组-Medium"><a href="#33-搜索旋转排序数组-Medium" class="headerlink" title="33 搜索旋转排序数组 Medium"></a>33 <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a> <font color=#ff7f50 size=4>Medium</font></h1><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span>, target = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span>, target = <span class="hljs-number">3</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这里唯一需要注意的就是我们需要去判断有序区间，别的都是正常二分</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[mid] == target:<br>                <span class="hljs-keyword">return</span> mid<br>            <span class="hljs-keyword">if</span> nums[left] &lt;= nums[mid]:<br>                <span class="hljs-keyword">if</span> nums[left] &lt;= target &lt;= nums[mid]:<br>                    right = mid - <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    left = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> nums[mid] &lt;= target &lt;= nums[right]:<br>                    left = mid + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(log n)，空间复杂度O(1)，执行时间45ms，消耗内存16.7MB</p><h1 id="34-在排序数组中查找元素的第一个和最后一个位置-Medium"><a href="#34-在排序数组中查找元素的第一个和最后一个位置-Medium" class="headerlink" title="34 在排序数组中查找元素的第一个和最后一个位置 Medium"></a>34 <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a> <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span>, target = 0<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>nums</code> 是一个非递减数组</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>需要两个额外变量存储索引，需要边界条件确定不存在的情况</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchRange</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[mid] &lt; target:<br>                left = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                right = mid - <span class="hljs-number">1</span><br>        first = left<br>        <span class="hljs-keyword">if</span> first == <span class="hljs-built_in">len</span>(nums) <span class="hljs-keyword">or</span> nums[first] != target:<br>            <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]<br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[mid] &gt; target:<br>                right = mid - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                left = mid + <span class="hljs-number">1</span><br>        last = right<br>        <span class="hljs-keyword">return</span> [first, last]<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(log n)，空间复杂度O(1)，执行时间43ms，消耗内存17.7MB</p><h1 id="153-寻找旋转排序数组中的最小值-Medium"><a href="#153-寻找旋转排序数组中的最小值-Medium" class="headerlink" title="153 寻找旋转排序数组中的最小值 Medium"></a>153 <a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a> <font color=#ff7f50 size=4>Medium</font></h1><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span><br>输出：<span class="hljs-number">0</span><br>解释：原数组为 <span class="hljs-string">[0,1,2,4,5,6,7]</span> ，旋转 <span class="hljs-number">3</span> 次得到输入数组。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[11,13,15,17]</span><br>输出：<span class="hljs-number">11</span><br>解释：原数组为 <span class="hljs-string">[11,13,15,17]</span> ，旋转 <span class="hljs-number">4</span> 次得到输入数组。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li><li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li></ul><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>没啥差别和找峰值那个差不多，一个找索引一个找值</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMin</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[mid] &gt; nums[right]:<br>                left = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                right = mid<br>        <span class="hljs-keyword">return</span> nums[left]<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(log n)，空间复杂度O(1)，执行时间36ms，消耗内存16.7MB</p><h1 id="4-寻找两个正序数组的中位数-Hard"><a href="#4-寻找两个正序数组的中位数-Hard" class="headerlink" title="4 寻找两个正序数组的中位数 Hard"></a>4 <a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a> <font color=#ff0000 size=4>Hard</font></h1><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,3]</span>, nums2 = <span class="hljs-comment">[2]</span><br>输出：2.00000<br>解释：合并数组 = <span class="hljs-comment">[1,2,3]</span> ，中位数 2<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">2.50000</span><br>解释：合并数组 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] ，中位数 <span class="hljs-comment">(2 + 3)</span> / <span class="hljs-number">2</span> = <span class="hljs-number">2.5</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>两个数组和成一个数组然后去处理，排序后直接分奇偶</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMedianSortedArrays</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:<br>        nums = nums1 + nums2<br>        nums.sort()<br>        length = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> length % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> (nums[length // <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] + nums[length // <span class="hljs-number">2</span>]) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> nums[length // <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O((n + m) log(n + m))，空间复杂度O(n + m)，执行时间41ms，消耗内存16.6MB</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>陌陌笔试——推荐算法-计算智能算法笔试</title>
    <link href="/2024/09/06/%E9%99%8C%E9%99%8C%E7%AC%94%E8%AF%95/"/>
    <url>/2024/09/06/%E9%99%8C%E9%99%8C%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说实话，陌陌这次的笔试真的真的让人感觉到了原来我真的会点东西啊，废话不多说，直接上题目。</p><p>对了，前提需要说一下，代码为核心代码模式，且需要将结果设为result，最终函数返回1，后续会人工判卷（有一说一我自己是觉得人工判卷相对来说会比系统自动要好一些，最起码有主观看法）。</p><h1 id="寻找支配点"><a href="#寻找支配点" class="headerlink" title="寻找支配点"></a>寻找支配点</h1><p>P为给定的二维平面整数点集。定义P中某点x，如果x满足P中任意点都不在x的右上方区域内（横纵坐标都大于x），则称其为一个支配点。</p><p>如下图所示，蓝色点位该点集中的支配点集合</p><figure>  <img src="/2024/09/06/%E9%99%8C%E9%99%8C%E7%AC%94%E8%AF%95/IMG_7685.png" class="" title="寻找支配点">  <figcaption>寻找支配点</figcaption></figure><p>请实现代码，找到给定的人以及和P中的所有支配点并输出。（所有点的横纵坐标不重复）</p><p>输入：二维数组，表示点集P</p><p>输出：二维数组，n个支配点的点集Q</p><p>示例：</p><p>输入 P&#x3D;[[1, 2], [5, 3], [4, 6], [7, 5], [9, 0]]</p><p>输出 [[4, 6], [7, 5], [9, 0]]</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">self , P: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        P.sort(key = <span class="hljs-keyword">lambda</span> p: (-p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>]))<br>        result = []<br>        max_y = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> P:<br>            <span class="hljs-keyword">if</span> y &gt; max_y:<br>                result.append([x, y])<br>        <span class="hljs-variable language_">self</span>.result = result<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="非极大值抑制"><a href="#非极大值抑制" class="headerlink" title="非极大值抑制"></a>非极大值抑制</h1><p>非极大值抑制（Non-Maximum Suppression，NMS）是一种用于目标检测的算法，旨在从多个重叠的候选框中选择出最优的框。其基本思想是抑制那些不是局部最大值的元素，从而减少冗余的检测结果。</p><h2 id="NMS的工作原理"><a href="#NMS的工作原理" class="headerlink" title="NMS的工作原理"></a>NMS的工作原理</h2><ol><li><strong>局部最大搜索</strong>：NMS算法通过对候选框的得分进行排序，选择得分最高的框作为参考框。</li><li><strong>计算重叠度</strong>：对于其他候选框，计算它们与当前参考框的重叠度（交并比，IoU）。如果某个候选框的IoU大于设定的阈值（通常在0.3到0.5之间），则认为它与参考框指向同一目标，因而将其剔除。</li><li><strong>重复过程</strong>：从剩余的候选框中再次选择得分最高的框，重复上述步骤，直到没有候选框可以被剔除为止。</li></ol><p>NMS在计算机视觉领域的应用非常广泛，包括视频目标跟踪、数据挖掘、3D重建和目标识别等</p><p>(以上资料来源于网络)</p><p>输入：</p><p>boxes为二维数组，其中每个元素是一维数组[x1, y1, x2, y2]，分别表示框的左上角和右下角坐标。scores是一个一维数组，每个元素表示每个框的置信度。两个的元素个数是相互对应的，iou_threshold表示用于移除重叠框的交并比阈值。</p><p>输出：</p><p>一个一维数组，表示所有留下框在原始列表中的下表，按照从小到大排序。</p><p>提示：</p><p>框面积计算公式为（y2 - y1) * (x2 - x1)</p><p>交并比的计算公式为：两框的交集面积除以并集面积</p><p>示例：</p><p>输入：</p><p>boxes &#x3D; [[x11, y11, x21, y21], [x12, y12, x22, y22], [x13, y13, x23, y23]], scores &#x3D; [0.75, 0.7, 0.8], iou_threshold &#x3D; 0.7</p><p>输出：</p><p>[0, 2]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">self, boxes: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], sorces: <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>], iou_threshold: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_iou</span>(<span class="hljs-params">box1, box2</span>):<br>            x1 = <span class="hljs-built_in">max</span>(box1[<span class="hljs-number">0</span>], box2[<span class="hljs-number">0</span>])<br>            y1 = <span class="hljs-built_in">max</span>(box1[<span class="hljs-number">1</span>], box2[<span class="hljs-number">1</span>])<br>            x2 = <span class="hljs-built_in">min</span>(box1[<span class="hljs-number">2</span>], box2[<span class="hljs-number">2</span>])<br>            y2 = <span class="hljs-built_in">min</span>(box1[<span class="hljs-number">3</span>], box2[<span class="hljs-number">3</span>])<br>            <br>            intersection = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, x2 - x1) * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, y2 - y1)<br>            area1 = (box1[<span class="hljs-number">2</span>] - box1[<span class="hljs-number">0</span>]) * (box1[<span class="hljs-number">3</span>] - box1[<span class="hljs-number">1</span>])<br>            area2 = (box2[<span class="hljs-number">2</span>] - box2[<span class="hljs-number">0</span>]) * (box2[<span class="hljs-number">3</span>] - box2[<span class="hljs-number">1</span>])<br>            union = area1 + area2 - intersection<br>            <br>            <span class="hljs-keyword">return</span> intersection / union <span class="hljs-keyword">if</span> union &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(boxes)<br>        indices = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(n))<br>        indices.sort(key = <span class="hljs-keyword">lambda</span> i: sorces[i], reverse = <span class="hljs-literal">True</span>)<br>        <br>        result = []<br>        <span class="hljs-keyword">while</span> indices:<br>            idx = indices[<span class="hljs-number">0</span>]<br>            result.append(idx)<br>            indices = indices[<span class="hljs-number">1</span>:]<br>            <br>            indices = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> indices <span class="hljs-keyword">if</span> calculate_iou(boxes[idx], boxes[<span class="hljs-number">0</span>]) &lt;= iou_threshold]<br>            <br>            result.sort()<br>            result = result<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="序列置换"><a href="#序列置换" class="headerlink" title="序列置换"></a>序列置换</h1><p>给一个长度为N（N&lt;1000）的正整数序列（1~N），我们称之为A。将上述序列随机重新排列后的序列称之为B序列。使用B序列作为一个置换，来对A序列进行操作。置换是指将A序列中的第B[i]个元素，挪到第i个位置。请实现一个函数，输入将A序列置换K次之后的序列。注意K可能会非常大($K &lt; 10^8$)</p><p>输入：A序列、B序列以及K</p><p>输出：置换后序列</p><p>示例：</p><p>输入：</p><p>A &#x3D; [1, 2, 3], B &#x3D; [3, 1, 2], k &#x3D; 2</p><p>输出：[2, 3, 1]</p><p>说明：</p><p>A序列经过B序列置换后变为312，再经过231</p><p>Q1：请简述算法思路和时间空间复杂度</p><p>Q2：编程实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">self, A: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], B: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(A)<br>        result = [<span class="hljs-number">0</span>] * n<br>        visited = [<span class="hljs-literal">False</span>] * n<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:<br>                cycle = []<br>                j = i<br>                <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> visited[j]:<br>                    visited[j] = <span class="hljs-literal">True</span><br>                    cycle.append(j)<br>                    j = B[j] - <span class="hljs-number">1</span><br>                cycle_length = <span class="hljs-built_in">len</span>(cycle)<br>                <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cycle_length):<br>                    result[cycle[(m + K) % cycle_length]] = A[cycle[m]]<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>构建循环：遍历A的每个元素，使用i作为索引如果没有被访问则从这里开始，沿着B数组定义的置换元素构建一个置换循环。使用cycle记录循环中给所有元素的索引</li><li>处理置换循环：遍历cycle，记长度为cycle_length，对每个元素都置换到新位置，位置是计算得出的</li></ol><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这次的题相对来说其实属于easy和medium范畴了。但是由于没有设定结果所以也没办法看自己最终能够通过多少，不过我的思路应该是大差不差的，如果有什么问题还请大家在评论里指出，啾咪💞</p>]]></content>
    
    
    <categories>
      
      <category>笔试记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔试</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——Kadane算法</title>
    <link href="/2024/09/04/leetcode-Kadane%E7%AE%97%E6%B3%95/"/>
    <url>/2024/09/04/leetcode-Kadane%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="53-最大子数组和-Medium"><a href="#53-最大子数组和-Medium" class="headerlink" title="53 最大子数组和 Medium"></a>53 <a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a> <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong></p><p>是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[5,4,-1,7,8]</span><br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接动态规划，记录每个位置的最大子数组和，进而推导出全局最大子数组和</p><p>状态转移方程$dp[i] &#x3D; max(nums[i], nums[i] + dp[i - 1])$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [<span class="hljs-number">0</span>] * n<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            dp[i] = <span class="hljs-built_in">max</span>(nums[i], nums[i] + dp[i - <span class="hljs-number">1</span>])<br>        res = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            res = <span class="hljs-built_in">max</span>(res, dp[i])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="918-环形子数组的最大和-Medium"><a href="#918-环形子数组的最大和-Medium" class="headerlink" title="918 环形子数组的最大和 Medium"></a>918 <a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">环形子数组的最大和</a> <font color=#ff7f50 size=4>Medium</font></h1><p>给定一个长度为 <code>n</code> 的<strong>环形整数数组</strong> <code>nums</code> ，返回 <em><code>nums</code> 的非空 <strong>子数组</strong> 的最大可能和</em> 。</p><p><strong>环形数组</strong> 意味着数组的末端将会与开头相连呈环状。形式上， <code>nums[i]</code> 的下一个元素是 <code>nums[(i + 1) % n]</code> ， <code>nums[i]</code> 的前一个元素是 <code>nums[(i - 1 + n) % n]</code> 。</p><p><strong>子数组</strong> 最多只能包含固定缓冲区 <code>nums</code> 中的每个元素一次。形式上，对于子数组 <code>nums[i], nums[i + 1], ..., nums[j]</code> ，不存在 <code>i &lt;= k1, k2 &lt;= j</code> 其中 <code>k1 % n == k2 % n</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,-2,3,-2]</span><br>输出：3<br>解释：从子数组 <span class="hljs-comment">[3]</span> 得到最大和 3<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,-3,5]</span><br>输出：10<br>解释：从子数组 <span class="hljs-comment">[5,5]</span> 得到最大和 5 + 5 = 10<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,-2,2,-3]</span><br>输出：3<br>解释：从子数组 <span class="hljs-comment">[3]</span> 和 <span class="hljs-comment">[3,-2,2]</span> 都可以得到最大和 3<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 3 * 104</code></li><li><code>-3 * 104 &lt;= nums[i] &lt;= 3 * 104</code></li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这题还是用<code>Kadane</code>算法去计算子数组的最大和，但需要注意几个问题。</p><p>首先我们在第一个的基础上额外用两个变量去存储当前位置的前一个位置的和（最大或最小）</p><p>其次我们还需要注意<code>nums</code>可能全为负</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubarraySumCircular</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        <span class="hljs-comment"># 使用Kadane算法找到非环形子数组的最大和</span><br>        max_sum = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)<br>        current_max = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            current_max = <span class="hljs-built_in">max</span>(num, current_max + num)<br>            max_sum = <span class="hljs-built_in">max</span>(max_sum, current_max)<br>        <br>        <span class="hljs-comment"># 找到非环形子数组的最小和</span><br>        min_sum = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        current_min = <span class="hljs-number">0</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            res += num<br>            current_min = <span class="hljs-built_in">min</span>(num, current_min + num)<br>            min_sum = <span class="hljs-built_in">min</span>(min_sum, current_min)<br>        <br>        <span class="hljs-comment"># 如果最大和大于0，则比较非环形最大和与环形最大和（总和减去最小和）</span><br>        <span class="hljs-keyword">if</span> max_sum &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(max_sum, res - min_sum)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果所有数都是负数，则返回非环形最大和</span><br>            <span class="hljs-keyword">return</span> max_sum<br><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(1)，执行时间171ms，消耗内存20.4MB</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>Kadane算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——分治</title>
    <link href="/2024/09/03/leetcode-%E5%88%86%E6%B2%BB/"/>
    <url>/2024/09/03/leetcode-%E5%88%86%E6%B2%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="108-将有序数组转换为二叉搜索树-Easy"><a href="#108-将有序数组转换为二叉搜索树-Easy" class="headerlink" title="108 将有序数组转换为二叉搜索树 Easy"></a>108 <a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a> <font color=#7fffd4 size=4>Easy</font></h1><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 </p><p>平衡</p><p> 二叉搜索树。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-10</span>,<span class="hljs-string">-3</span>,0,5,9]<br>输出：[0,<span class="hljs-string">-3</span>,9,<span class="hljs-string">-10</span>,null,5]<br>解释：[0,<span class="hljs-string">-10</span>,5,null,<span class="hljs-string">-3</span>,null,9] 也将被视为正确答案：<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3]</span><br>输出：<span class="hljs-comment">[3,1]</span><br>解释：<span class="hljs-comment">[1,null,3]</span> 和 <span class="hljs-comment">[3,1]</span> 都是高度平衡二叉搜索树。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里需要回顾下我们之前看过的二叉搜索树的概念，详细请见<a href="https://lx02918.github.io/2024/08/21/leetcode-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">leetcode刷题记录——二叉搜索树</a></p><p> 然后借助我们的概念，root节点就是整个nums的中间位置，然后递归就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedArrayToBST</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        mid = <span class="hljs-built_in">len</span>(nums) // <span class="hljs-number">2</span><br>        root = TreeNode(nums[mid])<br>        root.left = <span class="hljs-variable language_">self</span>.sortedArrayToBST(nums[:mid])<br>        root.right = <span class="hljs-variable language_">self</span>.sortedArrayToBST(nums[mid+<span class="hljs-number">1</span>:])<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(log n)，执行时间43ms，消耗内存17.7MB</p><h1 id="148-排序链表-Medium"><a href="#148-排序链表-Medium" class="headerlink" title="148 排序链表 Medium"></a>148 <a href="https://leetcode.cn/problems/sort-list/">排序链表</a> <font color=#ff7f50 size=4>Medium</font></h1><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">4,2,1,3</span>]<br>输出：[<span class="hljs-number">1,2,3,4</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [-<span class="hljs-number">1,5,3,4</span>,<span class="hljs-number">0</span>]<br>输出：[-<span class="hljs-number">1,0,3,4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先需要明确的一点是我们需要用到两个方法，一个将链表拆分为两部分，一个用来合并链表</p><p>拆分部分需要用到快慢指针，合并部分需要用到虚拟节点和尾节点</p><p>其余直接看代码，写了注释</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortList</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:<br>            <span class="hljs-keyword">return</span> head<br>        <span class="hljs-comment"># 使用快慢指针找到链表中间节点</span><br>        slow, fast = head, head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:<br>            slow = slow.<span class="hljs-built_in">next</span><br>            fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 将链表分为两部分</span><br>        second = slow.<span class="hljs-built_in">next</span><br>        slow.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 递归地对两部分链表进行排序</span><br>        left = <span class="hljs-variable language_">self</span>.sortList(head)<br>        right = <span class="hljs-variable language_">self</span>.sortList(second)<br>        <span class="hljs-comment"># 合并链表</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.merge(left, right)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, left, right</span>):<br>        dummy = tail = ListNode(<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 合并有序链表</span><br>        <span class="hljs-keyword">while</span> left <span class="hljs-keyword">and</span> right:<br>            <span class="hljs-keyword">if</span> left.val &lt; right.val:<br>                tail.<span class="hljs-built_in">next</span> = left<br>                left = left.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                tail.<span class="hljs-built_in">next</span> = right<br>                right = right.<span class="hljs-built_in">next</span><br>            tail = tail.<span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 剩余节点连接到合并后的尾部</span><br>        tail.<span class="hljs-built_in">next</span> = left <span class="hljs-keyword">if</span> left <span class="hljs-keyword">else</span> right<br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(nlog n)，空间复杂度O(log n)，执行时间294ms，消耗内存31.4MB</p><h1 id="427-建立四叉树-Medium"><a href="#427-建立四叉树-Medium" class="headerlink" title="427 建立四叉树 Medium"></a>427 <a href="https://leetcode.cn/problems/construct-quad-tree/">建立四叉树</a> <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个 <code>n * n</code> 矩阵 <code>grid</code> ，矩阵由若干 <code>0</code> 和 <code>1</code> 组成。请你用四叉树表示该矩阵 <code>grid</code> 。</p><p>你需要返回能表示矩阵 <code>grid</code> 的 四叉树 的根结点。</p><p>四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：</p><ul><li><code>val</code>：储存叶子结点所代表的区域的值。1 对应 <strong>True</strong>，0 对应 <strong>False</strong>。注意，当 <code>isLeaf</code> 为 <strong>False</strong> 时，你可以把 <strong>True</strong> 或者 <strong>False</strong> 赋值给节点，两种值都会被判题机制 <strong>接受</strong> 。</li><li><code>isLeaf</code>: 当这个节点是一个叶子结点时为 <strong>True</strong>，如果它有 4 个子节点则为 <strong>False</strong> 。</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">    public</span> boolean val;<br>    public boolean isLeaf;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">topLeft</span>;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">topRight</span>;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">bottomLeft</span>;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">bottomRight</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以按以下步骤为二维区域构建四叉树：</p><ol><li>如果当前网格的值相同（即，全为 <code>0</code> 或者全为 <code>1</code>），将 <code>isLeaf</code> 设为 True ，将 <code>val</code> 设为网格相应的值，并将四个子节点都设为 Null 然后停止。</li><li>如果当前网格的值不同，将 <code>isLeaf</code> 设为 False， 将 <code>val</code> 设为任意值，然后如下图所示，将当前网格划分为四个子网格。</li><li>使用适当的子网格递归每个子节点。</li></ol><p><img src="https://assets.leetcode.com/uploads/2020/02/11/new_top.png" alt="img"></p><p>如果你想了解更多关于四叉树的内容，可以参考 <a href="https://en.wikipedia.org/wiki/Quadtree">wiki</a> 。</p><p><strong>四叉树格式：</strong></p><p>你不需要阅读本节来解决这个问题。只有当你想了解输出格式时才会这样做。输出为使用层序遍历后四叉树的序列化形式，其中 <code>null</code> 表示路径终止符，其下面不存在节点。</p><p>它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 <code>[isLeaf, val]</code> 。</p><p>如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 True ，则表示它在列表 <code>[isLeaf, val]</code> 中的值为 <strong>1</strong> ；如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 False ，则表示值为 <strong>0</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/02/11/grid1.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[0,1],[1,0]]</span><br>输出：<span class="hljs-string">[[0,1],[1,0],[1,1],[1,1],[1,0]]</span><br>解释：此示例的解释如下：<br>请注意，在下面四叉树的图示中，<span class="hljs-number">0</span> 表示 <span class="hljs-literal">false</span>，<span class="hljs-number">1</span> 表示 True 。<br></code></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/02/12/e1tree.png" alt="img"></p><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/02/12/e2mat.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：grid = <span class="hljs-comment">[<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>,<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>,<span class="hljs-comment">[1,1,1,1,1,1,1,1]</span>,<span class="hljs-comment">[1,1,1,1,1,1,1,1]</span>,<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>,<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>,<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>,<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[1,0]</span>,null,null,null,null,<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[1,1]</span>]</span><br>解释：网格中的所有值都不相同。我们将网格划分为四个子网格。<br>topLeft，bottomLeft 和 bottomRight 均具有相同的值。<br>topRight 具有不同的值，因此我们将其再分为 4 个子网格，这样每个子网格都具有相同的值。<br>解释如下图所示：<br></code></pre></td></tr></table></figure><p> <img src="https://assets.leetcode.com/uploads/2020/02/12/e2tree.png" alt="img"></p><p><strong>提示：</strong></p><ol><li><code>n == grid.length == grid[i].length</code></li><li><code>n == 2x</code> 其中 <code>0 &lt;= x &lt;= 6</code></li></ol><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>主要用到两个函数，<code>same</code>和<code>dfs</code>。<code>same</code>函数用于检查二维数组中所有元素是否相同，<code>dfs</code>函数用于递归构建四叉树，所用到的四个参数主要用于处理当前矩阵区域的起始行结束行起始列结束列。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">construct</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-string">&#x27;Node&#x27;</span>:<br>        <span class="hljs-comment"># 辅助函数：检查从 (a, c) 到 (b, d) 的矩形区域内的所有元素是否相同</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">same</span>(<span class="hljs-params">a, b, c, d</span>):<br>            cur = grid[a][c]  <span class="hljs-comment"># 获取区域左上角的值</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(a, b):<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c, d):<br>                    <span class="hljs-keyword">if</span> grid[i][j] != cur:  <span class="hljs-comment"># 如果发现不同值，返回 False</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <span class="hljs-comment"># 区域内所有元素相同，返回 True</span><br>        <br>        <span class="hljs-comment"># 深度优先搜索函数：递归构建四叉树</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">rs, re, ls, le</span>):<br>            <span class="hljs-keyword">if</span> same(rs, re, ls, le):  <span class="hljs-comment"># 如果当前区域内的所有元素相同</span><br>                node = Node(grid[rs][ls], <span class="hljs-literal">True</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>)  <span class="hljs-comment"># 创建叶子节点</span><br>            <span class="hljs-keyword">else</span>:<br>                node = Node(grid[rs][ls], <span class="hljs-literal">False</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>)  <span class="hljs-comment"># 创建非叶子节点</span><br>                row_middle = (rs + re) // <span class="hljs-number">2</span>  <span class="hljs-comment"># 计算中间行索引</span><br>                col_middle = (ls + le) // <span class="hljs-number">2</span>  <span class="hljs-comment"># 计算中间列索引</span><br>                <span class="hljs-comment"># 递归构建四个子节点</span><br>                node.topLeft = dfs(rs, row_middle, ls, col_middle)<br>                node.topRight = dfs(rs, row_middle, col_middle, le)<br>                node.bottomLeft = dfs(row_middle, re, ls, col_middle)<br>                node.bottomRight = dfs(row_middle, re, col_middle, le)<br>            <span class="hljs-keyword">return</span> node  <span class="hljs-comment"># 返回当前构建的节点</span><br>        <br>        l = <span class="hljs-built_in">len</span>(grid)  <span class="hljs-comment"># 获取输入二维数组的长度</span><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, l, <span class="hljs-number">0</span>, l)  <span class="hljs-comment"># 从整个矩阵的左上角到右下角开始递归构建四叉树</span><br><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度$O(n^2logn)$，空间复杂度$O(logn)$，执行时间89ms，消耗内存17.35MB</p><h1 id="23-合并-K-个升序链表-Hard"><a href="#23-合并-K-个升序链表-Hard" class="headerlink" title="23 合并 K 个升序链表 Hard"></a>23 <a href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并 K 个升序链表</a> <font color=#ff0000 size=4>Hard</font></h1><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：lists = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：lists = <span class="hljs-string">[[]]</span><br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>整体思路上借助最小堆的特性来做，堆中的元素需要包含节点的值，节点的唯一标识，节点本身</p><p>关于最小堆的特性：</p><ul><li>最小堆是一种完全二叉树，这意味着除了最后一层外，其他层都是满的，并且最后一层的节点都尽量靠左排列。</li><li>对于任意节点 <code>i</code>，其左子节点 <code>2*i + 1</code> 和右子节点 <code>2*i + 2</code> 的值都大于或等于节点 <code>i</code> 的值。</li></ul><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params">self, lists: <span class="hljs-type">List</span>[<span class="hljs-type">Optional</span>[ListNode]]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        p = dummy<br>        pq = []<br>        <br>        <span class="hljs-comment"># 将每个链表的头节点压入堆中</span><br>        <span class="hljs-keyword">for</span> head <span class="hljs-keyword">in</span> lists:<br>            <span class="hljs-keyword">if</span> head:<br>                heapq.heappush(pq, (head.val, <span class="hljs-built_in">id</span>(head), head))<br>        <br>        <span class="hljs-comment"># 当堆不为空时，执行以下操作</span><br>        <span class="hljs-keyword">while</span> pq:<br>            <span class="hljs-comment"># 从堆中弹出值最小的节点</span><br>            node = heapq.heappop(pq)[<span class="hljs-number">2</span>]<br>            p.<span class="hljs-built_in">next</span> = node<br>            <br>            <span class="hljs-comment"># 如果该节点有下一个节点，则将下一个节点压入堆中</span><br>            <span class="hljs-keyword">if</span> node.<span class="hljs-built_in">next</span>:<br>                heapq.heappush(pq, (node.<span class="hljs-built_in">next</span>.val, <span class="hljs-built_in">id</span>(node.<span class="hljs-built_in">next</span>), node.<span class="hljs-built_in">next</span>))<br>            <br>            p = p.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度$O(nlogk)$，空间复杂度O(n + k)，执行时间49ms，消耗内存18.8MB</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——回溯</title>
    <link href="/2024/08/29/leetcode-%E5%9B%9E%E6%BA%AF/"/>
    <url>/2024/08/29/leetcode-%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="17-电话号码的字母组合-Medium"><a href="#17-电话号码的字母组合-Medium" class="headerlink" title="17 电话号码的字母组合 Medium"></a>17 电话号码的字母组合 <font color=#ff7f50 size=4>Medium</font></h1><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：digits <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;2&quot;</span><br>输出：[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先建立好映射，初始化我们需要存储的数组一个存储结果一个辅助我们的过程</p><p>后续使用回溯算法进行递归就OK了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-built_in">dict</span> = [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>, <span class="hljs-string">&#x27;ghi&#x27;</span>, <span class="hljs-string">&#x27;jkl&#x27;</span>, <span class="hljs-string">&#x27;mno&#x27;</span>, <span class="hljs-string">&#x27;pqrs&#x27;</span>, <span class="hljs-string">&#x27;tuv&#x27;</span>, <span class="hljs-string">&#x27;wxyz&#x27;</span>]<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.total = []<br>        <span class="hljs-variable language_">self</span>.res = []<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCombinations</span>(<span class="hljs-params">self, digits: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> digits:<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.total<br>        <span class="hljs-comment"># 从第一个数字开始  </span><br>        <span class="hljs-variable language_">self</span>.backtrack(digits, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.total<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, digits: <span class="hljs-built_in">str</span>, start: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.res) == <span class="hljs-built_in">len</span>(digits):<br>            <span class="hljs-comment"># 到达回溯树底部</span><br>            <span class="hljs-variable language_">self</span>.total.append(<span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-variable language_">self</span>.res))<br>            <span class="hljs-keyword">return</span><br>        digit = <span class="hljs-built_in">ord</span>(digits[start]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;0&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">dict</span>[digit]:<br>            <span class="hljs-comment"># 做选择</span><br>            <span class="hljs-variable language_">self</span>.res.append(i)<br>            <span class="hljs-comment"># 递归下一层</span><br>            <span class="hljs-variable language_">self</span>.backtrack(digits, start + <span class="hljs-number">1</span>)<br>            <span class="hljs-comment"># 撤销选择</span><br>            <span class="hljs-variable language_">self</span>.res.pop()<br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度$O(4 ^n)$，空间复杂度$O(n * 4 ^ n)$，执行时间24ms，消耗内存16.4MB</p><h1 id="77-组合-Medium"><a href="#77-组合-Medium" class="headerlink" title="77 组合 Medium"></a>77 组合 <font color=#ff7f50 size=4>Medium</font></h1><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 4, k = 2<br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>依旧是模板题，不过要注意的是，起始位置为1，存储为list</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        res = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">first = <span class="hljs-number">1</span>, curr = []</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(curr) == k:<br>                res.append(curr[:])<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(first, n + <span class="hljs-number">1</span>):<br>                curr.append(i)<br>                backtrack(i + <span class="hljs-number">1</span>, curr)<br>                curr.pop()<br>        backtrack(<span class="hljs-number">1</span>, [])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(k * C(n, k))，空间复杂度O(k * C(n, k))，执行时间190ms，消耗内存57.4MB</p><p>这里的C(n, k)涉及到组合公式（说实话我都不太会算了，高中学完，大学学完概率论就不咋用了，隐隐约约记得高中那会还总结了一个快速算法，排列问题也有一个）</p><p>公式为 $C(n, k) &#x3D; \frac{n!}{k!(n - k)!}$</p><h1 id="46-全排列-Medium"><a href="#46-全排列-Medium" class="headerlink" title="46 全排列 Medium"></a>46 全排列 <font color=#ff7f50 size=4>Medium</font></h1><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>还是模板，只不过这里在回溯部分需要改为换位置</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        res = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">first = <span class="hljs-number">0</span></span>):<br>            <span class="hljs-keyword">if</span> first == <span class="hljs-built_in">len</span>(nums):<br>                res.append(nums[:])<br>                <span class="hljs-keyword">return</span> <br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(first, <span class="hljs-built_in">len</span>(nums)):<br>                nums[first], nums[i] = nums[i], nums[first]<br>                backtrack(first + <span class="hljs-number">1</span>)<br>                nums[first], nums[i] = nums[i], nums[first]<br>                <br>        backtrack()<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n * n!)，空间复杂度O(n * n!)，执行时间27ms，消耗内存16.7MB</p><h1 id="组合总和-Medium"><a href="#组合总和-Medium" class="headerlink" title="组合总和 Medium"></a>组合总和 <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和<span class="hljs-number"> 3 </span>可以形成一组候选，2 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。注意<span class="hljs-number"> 2 </span>可以使用多次。<br>7 也是一个候选，<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 7 </span>。<br>仅有这两种组合。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[2,3,5]</span>, target = 8<br>输出: <span class="hljs-comment">[<span class="hljs-comment">[2,2,2,2]</span>,<span class="hljs-comment">[2,3,3]</span>,<span class="hljs-comment">[3,5]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[2]</span>, target = 1<br>输出: <span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>还是模板题，这里需要注意的是，我们的 <code>backtrack</code> 函数需要涉及到四个东西，数组 <code>candidates</code> 结果 <code>target</code> 起始点 <code>first</code> 加和 <code>sum</code></p><p>别的其实和第一题如出一辙</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.res = []<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params">self, candidates: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> candidates:<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.res<br>        <span class="hljs-variable language_">self</span>.backtrack(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.res<br>    track = []<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, candidates: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span>, first: <span class="hljs-built_in">int</span>, <span class="hljs-built_in">sum</span>: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> == target:<br>            <span class="hljs-variable language_">self</span>.res.append(<span class="hljs-variable language_">self</span>.track.copy())<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> &gt; target:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(first, <span class="hljs-built_in">len</span>(candidates)):<br>            <span class="hljs-variable language_">self</span>.track.append(candidates[i])<br>            <span class="hljs-built_in">sum</span> += candidates[i]<br>            <span class="hljs-variable language_">self</span>.backtrack(candidates, target, i, <span class="hljs-built_in">sum</span>)<br>            <span class="hljs-built_in">sum</span> -= candidates[i]<br>            <span class="hljs-variable language_">self</span>.track.pop()<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n^(target&#x2F;min(candidates)))，空间复杂度O(target&#x2F;min(candidates))，执行时间62ms，消耗内存16.6MB</p><h1 id="52-N-皇后-II-Hard"><a href="#52-N-皇后-II-Hard" class="headerlink" title="52 N 皇后 II Hard"></a>52 N 皇后 II <font color=#ff0000 size=4>Hard</font></h1><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n × n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回 <strong>n 皇后问题</strong> 不同的解决方案的数量。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>输出：<span class="hljs-number">2</span><br>解释：如上图所示，<span class="hljs-number">4</span> 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这道题唯一需要注意的就是在该位置能不能放皇后，由于我们遍历过程中左下右下并未涉及到，所以我们只需要看右上左上有没有皇后就可以</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">totalNQueens</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        board = [<span class="hljs-string">&#x27;.&#x27;</span> * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-variable language_">self</span>.backtrack(board, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.res<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, board, row</span>):<br>        <span class="hljs-keyword">if</span> row == <span class="hljs-built_in">len</span>(board):<br>            <span class="hljs-variable language_">self</span>.res += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span><br>        n = <span class="hljs-built_in">len</span>(board[row])<br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.isValid(board, row, col):<br>                <span class="hljs-keyword">continue</span><br>            board[row] = board[row][:col] + <span class="hljs-string">&#x27;Q&#x27;</span> + board[row][col + <span class="hljs-number">1</span>:]<br>            <span class="hljs-variable language_">self</span>.backtrack(board, row + <span class="hljs-number">1</span>)<br>            board[row] = board[row][:col] + <span class="hljs-string">&#x27;.&#x27;</span> + board[row][col + <span class="hljs-number">1</span>:]<br>            <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, board, row, col</span>):<br>        n = <span class="hljs-built_in">len</span>(board)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, row + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> board[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> i, j, <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<span class="hljs-built_in">range</span>(row - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), <span class="hljs-built_in">range</span>(col + <span class="hljs-number">1</span>, n)):<br>            <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<span class="hljs-built_in">range</span>(row - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), <span class="hljs-built_in">range</span>(col - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)):<br>            <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(N!)，空间复杂度O(N)，执行时间101ms，消耗内存16.4MB</p><h1 id="22-括号生成-Medium"><a href="#22-括号生成-Medium" class="headerlink" title="22 括号生成 Medium"></a>22 括号生成 <font color=#ff7f50 size=4>Medium</font></h1><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：[<span class="hljs-string">&quot;()&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>没啥好说的，就是套模板，直接看代码</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateParenthesis</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        res = []<br>        <span class="hljs-variable language_">self</span>.dfs(n, n, <span class="hljs-string">&#x27;&#x27;</span>, res)<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">self, left, right, path, res</span>):<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> right == <span class="hljs-number">0</span>:<br>            res.append(path)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> left &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.dfs(left - <span class="hljs-number">1</span>, right, path + <span class="hljs-string">&#x27;(&#x27;</span>, res)<br>        <span class="hljs-keyword">if</span> right &gt; left:<br>            <span class="hljs-variable language_">self</span>.dfs(left, right - <span class="hljs-number">1</span>, path + <span class="hljs-string">&#x27;)&#x27;</span>, res)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度$(O(4^n &#x2F; \sqrt{n})$，空间复杂度O(n)，执行时间44ms，消耗内存16.6MB</p><h1 id="79-单词搜索-Medium"><a href="#79-单词搜索-Medium" class="headerlink" title="79 单词搜索 Medium"></a>79 单词搜索 <font color=#ff7f50 size=4>Medium</font></h1><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;SEE&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCB&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li></ul><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>注意需要寻找四个方向看有没有，然后注意需要借助一个符号标记已经遍历过</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.found = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">exist</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]], word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        row, col = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(col):<br>                <span class="hljs-variable language_">self</span>.dfs(board, i, j, word, <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.found:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">self, board, i, j, word, k</span>):<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-built_in">len</span>(word):<br>            <span class="hljs-variable language_">self</span>.found = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">return</span> <br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.found:<br>            <span class="hljs-keyword">return</span> <br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= <span class="hljs-built_in">len</span>(board) <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &gt;= <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>]) <span class="hljs-keyword">or</span> word[k] != board[i][j]:<br>            <span class="hljs-keyword">return</span><br>        tmp = board[i][j]<br>        board[i][j] = <span class="hljs-string">&#x27;#&#x27;</span><br>        <span class="hljs-variable language_">self</span>.dfs(board, i + <span class="hljs-number">1</span>, j, word, k + <span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">self</span>.dfs(board, i - <span class="hljs-number">1</span>, j, word, k + <span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">self</span>.dfs(board, i, j + <span class="hljs-number">1</span>, word, k + <span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">self</span>.dfs(board, i, j - <span class="hljs-number">1</span>, word, k + <span class="hljs-number">1</span>)<br>        board[i][j] = tmp<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度$ O(m * n * 4^L)$，空间复杂度O(L)，执行时间3876ms，消耗内存16.4MB</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">result = []<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">路径, 选择列表</span>):<br>    <span class="hljs-keyword">if</span> 满足结束条件:<br>        result.add(路径)<br>        <span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>        做选择<br>        backtrack(路径, 选择列表)<br>        撤销选择<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——字典树</title>
    <link href="/2024/08/28/leetcode-%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <url>/2024/08/28/leetcode-%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="208-实现-Tire（前缀树）-Medium"><a href="#208-实现-Tire（前缀树）-Medium" class="headerlink" title="208 实现 Tire（前缀树） Medium"></a>208 实现 Tire（前缀树） <font color=#ff7f50 size=4>Medium</font></h1><p>**<a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a>**（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>示例：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">输入<br>[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]<br>[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]<br>输出<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>]<br><br>解释<br>Trie trie = <span class="hljs-built_in">new</span> Trie();<br>trie.<span class="hljs-keyword">insert</span>(&quot;apple&quot;);<br>trie.<span class="hljs-keyword">search</span>(&quot;apple&quot;);   // 返回 <span class="hljs-keyword">True</span><br>trie.<span class="hljs-keyword">search</span>(&quot;app&quot;);     // 返回 <span class="hljs-keyword">False</span><br>trie.startsWith(&quot;app&quot;); // 返回 <span class="hljs-keyword">True</span><br>trie.<span class="hljs-keyword">insert</span>(&quot;app&quot;);<br>trie.<span class="hljs-keyword">search</span>(&quot;app&quot;);     // 返回 <span class="hljs-keyword">True</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li><li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 104</code> 次</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先需要解释下什么是Tire结构，该结构的每个几点存储了对其子节点的链接，每个节点代表一个字符。根节点不包含字符，除根节点外的每个节点都与一个字符相关联。除此之外，节点通常还包含一个标志，表示该结点是否是某个字符串的结束。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>使用字典去存储，并用一个bool型变量去标记是否是单词的结尾</p><h3 id="插入字符"><a href="#插入字符" class="headerlink" title="插入字符"></a>插入字符</h3><p>从根节点开始遍历，如果不存在就创建一个新的子节点。遍历完成后标记最后一个节点为字符串的结束。</p><h3 id="搜索字符串"><a href="#搜索字符串" class="headerlink" title="搜索字符串"></a>搜索字符串</h3><p>这里和前面一样，只不过存在返回一个True不存在返回False，但需要保证最后一个节点被标记为字符串的结束</p><h3 id="前缀搜索"><a href="#前缀搜索" class="headerlink" title="前缀搜索"></a>前缀搜索</h3><p>能够完整遍历，但不需要检查最后一个节点是否被标记为结束</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.children = &#123;&#125;<br>        <span class="hljs-variable language_">self</span>.is_end_of_word = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        current = <span class="hljs-variable language_">self</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                current.children[char] = Trie()<br>            current = current.children[char]<br>        current.is_end_of_word = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        current = <span class="hljs-variable language_">self</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            current = current.children[char]<br>        <span class="hljs-keyword">return</span> current.is_end_of_word<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">startsWith</span>(<span class="hljs-params">self, prefix: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        current = <span class="hljs-variable language_">self</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> prefix:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            current = current.children[char]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度均为O(n)，空间复杂度为O(m * n)，执行时间133ms，消耗内存31.3MB</p><h1 id="211-添加与搜索单词-数据结构设计-Medium"><a href="#211-添加与搜索单词-数据结构设计-Medium" class="headerlink" title="211 添加与搜索单词 - 数据结构设计 Medium"></a>211 添加与搜索单词 - 数据结构设计 <font color=#ff7f50 size=4>Medium</font></h1><p>请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。</p><p>实现词典类 <code>WordDictionary</code> ：</p><ul><li><code>WordDictionary()</code> 初始化词典对象</li><li><code>void addWord(word)</code> 将 <code>word</code> 添加到数据结构中，之后可以对它进行匹配</li><li><code>bool search(word)</code> 如果数据结构中存在字符串与 <code>word</code> 匹配，则返回 <code>true</code> ；否则，返回 <code>false</code> 。<code>word</code> 中可能包含一些 <code>&#39;.&#39;</code> ，每个 <code>.</code> 都可以表示任何一个字母。</li></ul><p><strong>示例：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">输入：<br>[&quot;WordDictionary&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;]<br>[[],[&quot;bad&quot;],[&quot;dad&quot;],[&quot;mad&quot;],[&quot;pad&quot;],[&quot;bad&quot;],[&quot;.ad&quot;],[&quot;b..&quot;]]<br>输出：<br>[<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>]<br><br>解释：<br>WordDictionary wordDictionary = <span class="hljs-built_in">new</span> WordDictionary();<br>wordDictionary.addWord(&quot;bad&quot;);<br>wordDictionary.addWord(&quot;dad&quot;);<br>wordDictionary.addWord(&quot;mad&quot;);<br>wordDictionary.<span class="hljs-keyword">search</span>(&quot;pad&quot;); // 返回 <span class="hljs-keyword">False</span><br>wordDictionary.<span class="hljs-keyword">search</span>(&quot;bad&quot;); // 返回 <span class="hljs-keyword">True</span><br>wordDictionary.<span class="hljs-keyword">search</span>(&quot;.ad&quot;); // 返回 <span class="hljs-keyword">True</span><br>wordDictionary.<span class="hljs-keyword">search</span>(&quot;b..&quot;); // 返回 <span class="hljs-keyword">True</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word.length &lt;= 25</code></li><li><code>addWord</code> 中的 <code>word</code> 由小写英文字母组成</li><li><code>search</code> 中的 <code>word</code> 由 ‘.’ 或小写英文字母组成</li><li>最多调用 <code>104</code> 次 <code>addWord</code> 和 <code>search</code></li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>和前一题的思路基本上一致，但由于在 <code>search</code> 中我们需要分辨含有 <code>.</code> 的特殊节点，所以我们采用dfs去做，如果我们能够匹配到就返回，不能满足就下一个，所有都不满足就False</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.children = [<span class="hljs-literal">None</span>] * <span class="hljs-number">26</span><br>        <span class="hljs-variable language_">self</span>.isEnd = <span class="hljs-literal">False</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WordDictionary</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.root = Node()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addWord</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        node = <span class="hljs-variable language_">self</span>.root<br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>            index = <span class="hljs-built_in">ord</span>(char) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.children[index]:<br>                node.children[index] = Node()<br>            node = node.children[index]<br>        node.isEnd = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">word, index, root</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(word): <span class="hljs-keyword">return</span> root.isEnd<br>            <span class="hljs-keyword">if</span> word[index]  != <span class="hljs-string">&#x27;.&#x27;</span>:<br>                i = <span class="hljs-built_in">ord</span>(word[index]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>                <span class="hljs-keyword">return</span> dfs(word, index + <span class="hljs-number">1</span>, root.children[i])<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> root.children:<br>                    <span class="hljs-keyword">if</span> dfs(word, index + <span class="hljs-number">1</span>, child):<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> dfs(word, <span class="hljs-number">0</span>, <span class="hljs-variable language_">self</span>.root)<br><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度 <code>addWord</code> 为O(n)，<code>search</code> 最坏是O(n * 26)，最好是O(n)，执行时间为1916ms，消耗内存75.7MB</p><h1 id="212-单词搜索-II-Hard"><a href="#212-单词搜索-II-Hard" class="headerlink" title="212 单词搜索 II Hard"></a>212 单词搜索 II <font color=#ff0000 size=4>Hard</font></h1><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个单词（字符串）列表 <code>words</code>， <em>返回所有二维网格上的单词</em> 。</p><p>单词必须按照字母顺序，通过 <strong>相邻的单元格</strong> 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" alt="212.1"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>],[<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;t&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>],[<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>],[<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;v&quot;</span>]], words = [<span class="hljs-string">&quot;oath&quot;</span>,<span class="hljs-string">&quot;pea&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;rain&quot;</span>]<br>输出：[<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;oath&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg" alt="212.2"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>]], words = [<span class="hljs-string">&quot;abcb&quot;</span>]<br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 12</code></li><li><code>board[i][j]</code> 是一个小写英文字母</li><li><code>1 &lt;= words.length &lt;= 3 * 104</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>words[i]</code> 由小写英文字母组成</li><li><code>words</code> 中的所有字符串互不相同</li></ul><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>首先建立一个 TrieNode，再构建一个 Trie 树</p><p>再构建一个DFS，遍历当前节点的四个方位，并存储到结果集中，最终转换为列表返回</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TireNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.children = &#123;&#125; <span class="hljs-comment"># 存储 TireNode 的子节点</span><br>        <span class="hljs-variable language_">self</span>.is_end_of_word = <span class="hljs-literal">False</span> <span class="hljs-comment"># 是否是结尾</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findWords</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]], words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        <span class="hljs-comment"># 创建 Tire</span><br>        trie = TireNode()<br>        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>            node = trie<br>            <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>                <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> node.children:<br>                    node.children[char] = TireNode()<br>                node = node.children[char]<br>            node.is_end_of_word = <span class="hljs-literal">True</span><br>            <br>        result = <span class="hljs-built_in">set</span>() <span class="hljs-comment"># 存储搜索到的单词</span><br>        rows, cols = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">row, col, node, path</span>):<br>            <span class="hljs-comment"># 检查边界条件和当前字符是否已被访问</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (<span class="hljs-number">0</span> &lt;= row &lt; rows <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= col &lt; cols) <span class="hljs-keyword">or</span> board[row][col] == <span class="hljs-string">&#x27;#&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <br>            char = board[row][col]<br>            <span class="hljs-comment"># 如果当前字符不在子节点中,直接返回</span><br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> node.children:<br>                <span class="hljs-keyword">return</span> <br>            <span class="hljs-comment"># 获取当前字符对应的字 TireNode</span><br>            child = node.children[char]<br>            <span class="hljs-comment"># 是结尾就加入结果集</span><br>            <span class="hljs-keyword">if</span> child.is_end_of_word:<br>                result.add(path + char)<br>                <span class="hljs-comment"># 如果没有子节点，直接返回</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> child.children:<br>                    <span class="hljs-keyword">return</span> <br>            <span class="hljs-comment"># 标记当前字符为已访问字符    </span><br>            board[row][col] = <span class="hljs-string">&#x27;#&#x27;</span><br>            <span class="hljs-comment"># 上下左右依次DFS</span><br>            dfs(row + <span class="hljs-number">1</span>, col, child, path + char)<br>            dfs(row - <span class="hljs-number">1</span>, col, child, path + char)<br>            dfs(row, col + <span class="hljs-number">1</span>, child, path + char)<br>            dfs(row, col - <span class="hljs-number">1</span>, child, path + char)<br>            <span class="hljs-comment"># 恢复原字符</span><br>            board[row][col] = char<br>        <br>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows):<br>            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols):<br>                dfs(row, col, trie, <span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(result)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(N * L + M * N * 4^L)，空间复杂度O(N * L + L + K)，<code>N</code> 是单词数量，<code>L</code> 是单词的平均长度，<code>M</code> 和 <code>N</code> 是字符网格的行数和列数，<code>K</code> 是找到的单词数量。执行时间2852ms，消耗内存18.6MB</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这三道题我是推荐以第三题为主，因为他的整个流程更加全面，能够很好的对此类题构建出一个模板来，所以我这里也更推荐采用第三题作为主力研究对象。</p><p>我自己大致总结了一下做题的模板和方法：</p><h2 id="操作实现方法"><a href="#操作实现方法" class="headerlink" title="操作实现方法"></a>操作实现方法</h2><p><strong>初始化</strong>：</p><ul><li>使用一个字典来存储子节点。</li><li>用一个布尔变量 <code>is_end_of_word</code> 标记当前节点是否是单词的结束节点。</li></ul><p><strong>插入操作</strong>：</p><ul><li>从根节点开始，逐字符检查字典树中是否存在对应的子节点。</li><li>如果不存在，则创建一个新节点；遍历完所有字符后，将最后一个节点标记为单词结束。</li></ul><p><strong>搜索操作</strong>：</p><ul><li>从根节点逐字符遍历字典树。如果找到对应节点且最终节点被标记为单词结束，则返回 <code>True</code>；否则返回 <code>False</code>。</li></ul><p><strong>前缀搜索操作</strong>：</p><ul><li>从根节点逐字符遍历字典树，只要能成功遍历完整个前缀即可返回 <code>True</code>，无需检查最终节点是否为单词结束。</li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.children = &#123;&#125;<br>        <span class="hljs-variable language_">self</span>.is_end_of_word = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        current = <span class="hljs-variable language_">self</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                current.children[char] = Trie()<br>            current = current.children[char]<br>        current.is_end_of_word = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        current = <span class="hljs-variable language_">self</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            current = current.children[char]<br>        <span class="hljs-keyword">return</span> current.is_end_of_word<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">startsWith</span>(<span class="hljs-params">self, prefix: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        current = <span class="hljs-variable language_">self</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> prefix:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> current.children:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            current = current.children[char]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>整体上来看，都是基于字典树的基本结构，操作上主要是通过遍历和检查节点是否存在来完成插入、查找和前缀匹配的功能。</p><p>同时可以看到核心代码几乎完全复用，体现了字典树操作的模块化与通用性。</p><p>在这里还需要补充一个点，<code>ord</code>函数。该函数的作用是将单个字符转换为其对应的Unicode整数表示。这个函数的功能可以概括如下：</p><ol><li>字符到整数的转换：<code>ord()</code>函数接受一个单个字符作为输入，并返回该字符的Unicode码点（整数值）</li><li>Unicode支持：<code>ord()</code>函数可以处理任何Unicode字符，不仅限于ASCII字符</li><li>单字符输入：<code>ord()</code>函数只接受单个字符作为参数。如果尝试传入多个字符，会导致错误</li></ol>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>字典树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——图的广度优先遍历</title>
    <link href="/2024/08/27/leetcode-%E5%9B%BE-BFS/"/>
    <url>/2024/08/27/leetcode-%E5%9B%BE-BFS/</url>
    
    <content type="html"><![CDATA[<h1 id="909-蛇形棋-Medium"><a href="#909-蛇形棋-Medium" class="headerlink" title="909 蛇形棋 Medium"></a>909 蛇形棋 <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>board</code> ，方格按从 <code>1</code> 到 <code>n2</code> 编号，编号遵循 <a href="https://baike.baidu.com/item/%E7%89%9B%E8%80%95%E5%BC%8F%E8%BD%AC%E8%A1%8C%E4%B9%A6%E5%86%99%E6%B3%95/**17195786**">转行交替方式</a> ，从左下角开始 （即，从 <code>board[n - 1][0]</code> 开始）每一行交替方向。</p><p>玩家从棋盘上的方格 <code>1</code> （总是在最后一行、第一列）开始出发。</p><p>每一回合，玩家需要从当前方格 <code>curr</code> 开始出发，按下述要求前进：</p><p>选定目标方格 <code>next</code> ，目标方格的编号符合范围 <code>[curr + 1, min(curr + 6, n_2)]</code> 。</p><p>该选择模拟了掷 <strong>六面体骰子</strong> 的情景，无论棋盘大小如何，玩家最多只能有 <code>6</code> 个目的地。</p><p>传送玩家：如果目标方格 <code>next</code> 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 <code>next</code> 。 </p><p>当玩家到达编号 $n_2$ 的方格时，游戏结束。</p><p><code>r</code> 行 <code>c</code> 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 <code>board[r][c] != -1</code>，那个蛇或梯子的目的地将会是 <code>board[r][c]</code>。编号为 <code>1</code> 和 $n_2$ 的方格不是任何蛇或梯子的起点。</p><p>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 <strong>不能</strong> 继续移动。</p><p>举个例子，假设棋盘是 <code>[[-1,4],[-1,3]]</code> ，第一次移动，玩家的目标方格是 <code>2</code> 。那么这个玩家将会顺着梯子到达方格 <code>3</code> ，但 <strong>不能</strong> 顺着方格 3 上的梯子前往方格 <code>4</code> 。<br>返回达到编号为 $n_2$ 的方格所需的最少移动次数，如果不可能，则返回 <code>-1</code>。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2018/09/23/snakes.png" alt="909.1"></p><pre><code class="hljs">输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]输出：4解释：首先，从方格 1 [第 5 行，第 0 列] 开始。 先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 最后决定移动到方格 36 , 游戏结束。 可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。 </code></pre><p>示例 2：</p><pre><code class="hljs">输入：board = [[-1,-1],[-1,3]]输出：1</code></pre><p>提示：</p><p><code>n == board.length == board[i].length</code></p><p><code>2 &lt;= n &lt;= 20</code></p><p><code>board[i][j]</code> 的值是 <code>-1</code> 或在范围 <code>[1, n2]</code> 内</p><p>编号为 <code>1</code> 和 $n_2$ 的方格上没有蛇或梯子</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里我的想法是先对棋盘进行处理，后续就不用管奇偶行怎么变化了。</p><p>然后用一个 <code>snake</code> 参数来存储棋盘中有效位置和其映射，这个主要是用于对梯子和蛇进行标记。</p><p>循环部分符合BFS的模板就不多说了，直接看代码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">snakesAndLadders</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        snt = []<br>        <span class="hljs-keyword">for</span> j, bd <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(board[::-<span class="hljs-number">1</span>]):<br>            snt.append(bd <span class="hljs-keyword">if</span> j % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> bd[::-<span class="hljs-number">1</span>])<br>        snake = &#123;&#125;<br>        n = <span class="hljs-built_in">len</span>(board)<br>        <br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                cur = n * x + y + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> snt[x][y] != -<span class="hljs-number">1</span>:<br>                    snake[cur] = snt[x][y]<br>        start = &#123;<span class="hljs-number">1</span>&#125;<br>        visited = &#123;<span class="hljs-number">1</span>&#125;<br>        step = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> start:<br>            <span class="hljs-built_in">next</span> = <span class="hljs-built_in">set</span>()<br>            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> start:<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>):<br>                    newnum = num + j<br>                    <span class="hljs-keyword">if</span> newnum <span class="hljs-keyword">in</span> snake:<br>                        newnum = snake[newnum]<br>                    <span class="hljs-keyword">if</span> newnum == n * n:<br>                        <span class="hljs-keyword">return</span> step<br>                    <span class="hljs-keyword">if</span> newnum <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>                        <span class="hljs-built_in">next</span>.add(newnum)<br>                        visited.add(newnum)<br>            step += <span class="hljs-number">1</span><br>            start = <span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n²)，空间复杂度O(n²)，执行时间65ms，消耗内存16.6MB</p><h1 id="433-最小基因变化-Medium"><a href="#433-最小基因变化-Medium" class="headerlink" title="433 最小基因变化 Medium"></a>433 最小基因变化 <font color=#ff7f50 size=4>Medium</font></h1><p>基因序列可以表示为一条由 <code>8</code> 个字符组成的字符串，其中每个字符都是 <code>&#39;A&#39;</code>、<code>&#39;C&#39;</code>、<code>&#39;G&#39;</code> 和 <code>&#39;T&#39;</code> 之一。</p><p>假设我们需要调查从基因序列 <code>start</code> 变为 <code>end</code> 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。</p><p>例如，<code>&quot;AACCGGTT&quot; --&gt; &quot;AACCGGTA&quot;</code> 就是一次基因变化。<br>另有一个基因库 <code>bank</code> 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 <code>bank</code> 中）</p><p>给你两个基因序列 <code>start</code> 和 <code>end</code> ，以及一个基因库 <code>bank</code> ，请你找出并返回能够使 <code>start</code> 变化为 <code>end</code> 所需的最少变化次数。如果无法完成此基因变化，返回 <code>-1</code> 。</p><p>注意：起始基因序列 <code>start</code> 默认是有效的，但是它并不一定会出现在基因库中。</p><p>示例 1：</p><pre><code class="hljs">输入：start = &quot;AACCGGTT&quot;, end = &quot;AACCGGTA&quot;, bank = [&quot;AACCGGTA&quot;]输出：1</code></pre><p>示例 2：</p><pre><code class="hljs">输入：start = &quot;AACCGGTT&quot;, end = &quot;AAACGGTA&quot;, bank = [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]输出：2</code></pre><p>示例 3：</p><pre><code class="hljs">输入：start = &quot;AAAAACCC&quot;, end = &quot;AACCCCCC&quot;, bank = [&quot;AAAACCCC&quot;,&quot;AAACCCCC&quot;,&quot;AACCCCCC&quot;]输出：3</code></pre><p>提示：</p><p><code>start.length == 8</code></p><p><code>end.length == 8</code></p><p><code>0 &lt;= bank.length &lt;= 10</code></p><p><code>bank[i].length == 8</code></p><p><code>start</code>、<code>end</code> 和 <code>bank[i]</code> 仅由字符 <code>[&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;]</code> 组成</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先排除我们 <code>end</code> 和 <code>bank</code> 不匹配的情况。然后后续我们进行匹配，只需要ACGT里面匹配到就可以构建新的 <code>gene</code> 同时我们需要判断 <code>gene</code> 是否在 <code>bank</code> 中，只要在里面就一个添加一个删除。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minMutation</span>(<span class="hljs-params">self, startGene: <span class="hljs-built_in">str</span>, endGene: <span class="hljs-built_in">str</span>, bank: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> endGene <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> bank:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        bank = <span class="hljs-built_in">set</span>(bank)<br>        queue = deque([startGene])<br>        step = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> queue:<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                gene = queue.popleft()<br>                <span class="hljs-keyword">if</span> gene == endGene:<br>                    <span class="hljs-keyword">return</span> step<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(gene)):<br>                    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;ACGT&#x27;</span>:<br>                        <span class="hljs-keyword">if</span> c == gene[i]:<br>                            <span class="hljs-keyword">continue</span><br>                        new_gene = gene[ : i] + c + gene[i + <span class="hljs-number">1</span>:]<br>                        <span class="hljs-keyword">if</span> new_gene <span class="hljs-keyword">in</span> bank:<br>                            queue.append(new_gene)<br>                            bank.remove(new_gene)<br>            step += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n²)，空间复杂度O(n²)，执行时间41ms，消耗内存16.5MB</p><h1 id="127-单词接龙-Hard"><a href="#127-单词接龙-Hard" class="headerlink" title="127 单词接龙 Hard"></a>127 单词接龙 <font color=#ff0000 size=4>Hard</font></h1><p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列 <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code>：</p><p>每一对相邻的单词只差一个字母。</p><p> 对于 <code>1 &lt;= i &lt;= k</code> 时，每个 <code>si</code> 都在 <code>wordList</code> 中。注意， <code>beginWord</code> 不需要在 <code>wordList</code> 中。</p><p><code>sk == endWord</code></p><p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> 和一个字典 <code>wordList</code> ，返回 从 <code>beginWord</code> 到 endWord 的 <em><strong>最短转换序列</strong></em> 中的 <em><strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回 <code>0</code> 。</p><p>示例 1：</p><pre><code class="hljs">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]输出：5解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</code></pre><p>示例 2：</p><pre><code class="hljs">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]输出：0解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</code></pre><p>提示：</p><p><code>1 &lt;= beginWord.length &lt;= 10</code></p><p><code>endWord.length == beginWord.length</code></p><p><code>1 &lt;= wordList.length &lt;= 5000</code></p><p><code>wordList[i].length == beginWord.length</code></p><p><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</p><p><code>beginWord != endWord</code></p><p><code>wordList</code> 中的所有字符串 <strong>互不相同</strong></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>和上一题几乎一模一样，把元素从ACGT改为26个字母，step初始化为1（因为步数在计算的时候是不包括最开始的变量本身，所以初始化为1）。最后把没匹配到的从-1改为0，搞定。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">ladderLength</span>(<span class="hljs-params">self, beginWord: <span class="hljs-built_in">str</span>, endWord: <span class="hljs-built_in">str</span>, wordList: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> endWord <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> wordList:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        word = <span class="hljs-built_in">set</span>(wordList)<br>        queue = deque([beginWord])<br>        step = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> queue:<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                gene = queue.popleft()<br>                <span class="hljs-keyword">if</span> gene == endWord:<br>                    <span class="hljs-keyword">return</span> step<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(gene)):<br>                    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>:<br>                        <span class="hljs-keyword">if</span> c == gene[i]:<br>                            <span class="hljs-keyword">continue</span><br>                        new_gene = gene[ : i] + c + gene[i + <span class="hljs-number">1</span>:]<br>                        <span class="hljs-keyword">if</span> new_gene <span class="hljs-keyword">in</span> word:<br>                            queue.append(new_gene)<br>                            word.remove(new_gene)<br>            step += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n²)，空间复杂度O(n²)，执行时间373ms，消耗内存17.1MB</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>京东笔试——算法工程师第三批</title>
    <link href="/2024/08/26/%E4%BA%AC%E4%B8%9C%E7%AC%94%E8%AF%95/"/>
    <url>/2024/08/26/%E4%BA%AC%E4%B8%9C%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><p>给你一个整数，请你判断0 ~ N之间有多少个数是100的正整数倍。</p><p><strong>输入描述</strong>：</p><p>输入的第一行给出一个整数N 输出描述：输出0~N之间有多少个数是100的整数倍。</p><p><strong>输出描述</strong>：</p><p>输出0 ~ N之间有多少个数是100的整数倍。</p><p>示例1：</p><p>输入：2000</p><p>输出：20</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>签到题，直接用 <code>N</code> 去掉最后两位就可以，能够避免出现负数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_multiples_of_100</span>(<span class="hljs-params">N</span>):<br>    N = <span class="hljs-built_in">int</span>(N)<br>    <br>    <span class="hljs-keyword">if</span> N &lt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <br>    N_str = <span class="hljs-built_in">str</span>(N)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(N_str) &lt; <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    result = <span class="hljs-built_in">int</span>(N_str[:-<span class="hljs-number">2</span>])<br>    <br>    <span class="hljs-keyword">return</span> result<br><br>N = <span class="hljs-built_in">input</span>().strip()<br><span class="hljs-built_in">print</span>(count_multiples_of_100(N))<br></code></pre></td></tr></table></figure><h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><p>给定一个大小为 <code>n * m</code> 的网格板，网格板是由 <code>n * m</code> 个 <code>1 * 1</code> 的单元格组成，最初所有单元格都是 <strong>白色</strong> 的；现在给出K个操作：</p><p>$c x y$ 将位置为$(x, y)$ 的单元格涂成黑色</p><p>$l x y$ 将位置为 $(x, y)$ 的单元格向左寻找第一个白色单元格，将其涂成黑色</p><p>$r x y$ 将位置为 $(x, y)$ 的单元格向右寻找第一个白色单元格，将其涂成黑色</p><p>$u x y$ 将位置为 $(x, y)$ 的单元格向上寻找第一个白色单元格，将其涂成黑色</p><p>$d x y$ 将位置为 $(x, y)$ 的单元格向下寻找第一个白色单元格，将其涂成黑色</p><p>注意：网格板左上角的单元格是 $(1, 1)$</p><p><strong>输入描述</strong>：<br>第一行给定 <code>n, m, k</code> 分别代表网格板大小和操作次数</p><p>后续给出为每次操作的命令 $s_i, x_i, y_i$</p><p>1 &lt;&#x3D; n, m &lt;&#x3D; 100</p><p>1 &lt;&#x3D; k &lt;&#x3D; $10^4$<br>1 &lt;&#x3D; $x_i, y_i$ &lt;&#x3D; $n, m$</p><p><strong>输出描述</strong>：</p><p>对于以 <code>l, r, u, d</code> 为操作的给出对应的坐标。没有坐标输出 <code>-1</code>。</p><p>示例1：</p><p>输入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">5</span> <span class="hljs-number">5</span> <span class="hljs-number">20</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">r</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">u</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">l</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">u</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">r</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">d</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">d</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">c</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1</span><br>3 2<br>4 3<br><span class="hljs-deletion">-1</span><br>1 2<br>4 3<br>5 4<br></code></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>初始化网格之后我们需要将所有元素初始化为False。</p><p>定义一个函数 <code>find</code> ，借助这个函数对x， y进行操作。需要使用到两个方向增量 d1, d2。</p><p>跳出条件为到达边界或找到未占位的我位置。</p><p>操作上按照四个方向进行操作，同时遇到 <code>c</code> 直接变为 True</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [[<span class="hljs-literal">False</span>] * <span class="hljs-number">105</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">105</span>)]<br><br>n, m, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x, y, d1, d2</span>):<br>    x += d1<br>    y += d2<br>    <span class="hljs-keyword">while</span> y &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> y &lt;= m <span class="hljs-keyword">and</span> x &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> x &lt;= m:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> a[x][y]:<br>            <span class="hljs-built_in">print</span>(x, y)<br>            <span class="hljs-keyword">return</span><br>        x += d1<br>        y += d2<br>    <span class="hljs-built_in">print</span>(-<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>    op, x, y = <span class="hljs-built_in">input</span>().split()<br>    x, y = <span class="hljs-built_in">int</span>(x), <span class="hljs-built_in">int</span>(y)<br>    d1, d2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;c&#x27;</span>:<br>        a[x][y] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;l&#x27;</span>:<br>        d2 = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;r&#x27;</span>:<br>        d2 = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;u&#x27;</span>:<br>        d1 = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;d&#x27;</span>:<br>        d1 = <span class="hljs-number">1</span><br>    find(x, y, d1, d2)<br></code></pre></td></tr></table></figure><h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><p>有 <code>n</code> 根木棍排成一列，第 <code>i</code> 根木棍的长度为 $a_i$ 。</p><p>请你从中选出一个最长的子区间，使得区间内任意三根木棍都能构成一个三角形。只需要输出选中的区间端点即可。</p><p><strong>输入描述</strong>：</p><p>第一行整数 <code>n</code> ，表示木棍的数量</p><p>第二行n个整数 第 $i$ 个整数 $a_i$ ，表示第 $i$ 根木棍的长度</p><p><strong>输出描述</strong>：<br>输出两个整数，表示最长的满足条件的区间的两个端点，如果有多个满足条件的，输出左端点最小的区间。</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>区间直接考虑到我们的滑动窗口。</p><p>首先固定好我们滑动窗口的两个边界，然后不断进行遍历，更新最大长度。滑动窗口内需要在 最小值 + 次小值 &lt;&#x3D; 最大时对右侧边界进行操作。这里我们获取最小值和次小值的方法是借助了 <code>SortedList()</code>。在更新后记录边界，最后输出即可。</p><p>这题的关键点就在于滑动窗口和有序集合，有序集合可以大大减少我们的代码量。</p><p>这里举我自己的反例，我当时由于太紧张，直接考虑到指针了，虽然考虑到 <code>sort()</code> 去排序，但是我后续的思路错了，结果这道题就失误了。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sortedcontainers <span class="hljs-keyword">import</span> SortedList<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_longest_subarray</span>(<span class="hljs-params">n, sticks</span>):<br>    S = SortedList()<br>    r = n<br>    ansl, ansr = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><br>    <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> r &lt; ansr - ansl:<br>            <span class="hljs-keyword">break</span><br><br>        S.add(sticks[l - <span class="hljs-number">1</span>])<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(S) &lt; <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">continue</span><br><br>        min1 = S[<span class="hljs-number">0</span>]<br>        min2 = S[<span class="hljs-number">1</span>]<br>        maxx = S[-<span class="hljs-number">1</span>]<br><br>        <span class="hljs-keyword">while</span> min1 + min2 &lt;= maxx:<br>            S.remove(sticks[r - <span class="hljs-number">1</span>])<br>            r -= <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(S) &lt; <span class="hljs-number">3</span>:<br>                <span class="hljs-keyword">break</span><br><br>            min1 = S[<span class="hljs-number">0</span>]<br>            min2 = S[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> sticks[r] == maxx:<br>                maxx = S[-<span class="hljs-number">1</span>]<br><br>        <span class="hljs-keyword">if</span> r - l &gt;= ansr - ansl:<br>            ansl, ansr = l, r<br><br>    <span class="hljs-built_in">print</span>(ansl, ansr)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>().strip())<br>    sticks = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split()))<br>    find_longest_subarray(n, sticks)<br></code></pre></td></tr></table></figure><p>这里还是想说我自己刷题数量还是太少了，还得努力啊，到现在这么些场有些思路上再后来反思时是对的，但复看自己的代码会发现在实现上还是存在问题。不过也没有出现暑期实习的时候输入输出出问题的低级错误了🤣当时因为输入输出好几次明明核心部分都是对的结果过不去，还是那句话，菜就多练🤣</p>]]></content>
    
    
    <categories>
      
      <category>笔试记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔试</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——图</title>
    <link href="/2024/08/22/leetcode-%E5%9B%BE/"/>
    <url>/2024/08/22/leetcode-%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="200-岛屿数量-Medium"><a href="#200-岛屿数量-Medium" class="headerlink" title="200 岛屿数量 Medium"></a>200 岛屿数量 <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例 1：</p><pre><code class="hljs">输入：grid = [[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]]输出：1</code></pre><p>示例 2：</p><pre><code class="hljs">输入：grid = [[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]输出：3</code></pre><p>提示：</p><p><code>m == grid.length</code></p><p><code>n == grid[i].length</code></p><p><code>1 &lt;= m, n &lt;= 300</code></p><p><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>解决矩阵搜索问题通常直接使用DFS去做。</p><p>这道题的通用思路就是对整个矩阵进行遍历，当遇到 <code>grid[i][j]</code> 的时候开始DFS，将周围所有的 <code>1</code> 都置为 <code>0</code>，这样就能找到所有的岛屿。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numIslands</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> grid: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        m, n = <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, j</span>):<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= m <span class="hljs-keyword">or</span> j &gt;= n <span class="hljs-keyword">or</span> grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <br>            grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span><br>            <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> (i+<span class="hljs-number">1</span>,j),(i-<span class="hljs-number">1</span>,j),(i,j+<span class="hljs-number">1</span>),(i,j-<span class="hljs-number">1</span>):<br>                dfs(x, y)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                    dfs(i, j)<br>                    res += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(m * n)，空间复杂度O(m * n)，执行时间248ms，消耗内存18.6MB</p><h1 id="130-被围绕的区域-Medium"><a href="#130-被围绕的区域-Medium" class="headerlink" title="130 被围绕的区域 Medium"></a>130 被围绕的区域 <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> 组成，捕获 <strong>所有</strong> 被围绕的区域：</p><p><strong>连接</strong>：一个单元格与水平或垂直方向上相邻的单元格连接。</p><p><strong>区域</strong>：连接所有 <code>&#39;O&#39;</code> 的单元格来形成一个区域。</p><p><strong>围绕</strong>：如果您可以用 <code>&#39;X&#39;</code> 单元格 连接这个区域，并且区域中没有任何单元格位于 board<br>边缘，则该区域被 <code>&#39;X&#39;</code> 单元格围绕。</p><p>通过将输入矩阵 <code>board</code> 中的所有 <code>&#39;O&#39;</code> 替换为 <code>&#39;X&#39;</code> 来 捕获被围绕的区域。</p><p>示例 1：</p><pre><code class="hljs">输入：board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]输出：[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</code></pre><p>解释：</p><figure>  <img src="/2024/08/22/leetcode-%E5%9B%BE/130_1.png" class="" title="130.1">  <figcaption>130.1</figcaption></figure><p>在上图中，底部的区域没有被捕获，因为它在 board 的边缘并且不能被围绕。</p><p>示例 2：</p><pre><code class="hljs">输入：board = [[&quot;X&quot;]]输出：[[&quot;X&quot;]]</code></pre><p>提示：</p><p><code>m == board.length</code></p><p><code>n == board[i].length</code></p><p><code>1 &lt;= m, n &lt;= 200</code></p><p><code>board[i][j]</code> 为 <code>&#39;X&#39;</code> 或 <code>&#39;O&#39;</code>   </p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>核心思路和前一题一样，都是先对整个矩阵进行遍历，遇到我们符合条件的先将其进行标记。</p><p>这里需要注意的是，我们是将周围没有 <code>O</code> 的标记为 <code>?</code>，而后面将剩余的<code>O</code>全部标记为 <code>X</code>。同时也要注意我们是先标记为 <code>X</code> 后将 <code>?</code> 还原为 <code>O</code>，不然会导致结果错误。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>这里给出两个版本的代码，思路是一样的，一个是我之前写的，一个是我现在写的。</p><p>第一版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board:<span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, j</span>):<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= m <span class="hljs-keyword">or</span> j &gt;= n <span class="hljs-keyword">or</span> board[i][j] != <span class="hljs-string">&#x27;O&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <br>            board[i][j] = <span class="hljs-string">&#x27;B&#x27;</span><br>            <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> (i + <span class="hljs-number">1</span>), (i - <span class="hljs-number">1</span>), (i, j + <span class="hljs-number">1</span>), (i, j - <span class="hljs-number">1</span>):<br>                dfs(x, y)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">if</span> board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                dfs(i, <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> board[i][n - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                dfs(i, n - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> board[<span class="hljs-number">0</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                dfs(<span class="hljs-number">0</span>, j)<br>            <span class="hljs-keyword">if</span> board[m - <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                dfs(m - <span class="hljs-number">1</span>, j)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span><br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;B&#x27;</span>:<br>                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span><br></code></pre></td></tr></table></figure><p>第二版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">solve</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">board, i, j</span>):<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt;= m <span class="hljs-keyword">or</span> j &gt;= n <span class="hljs-keyword">or</span> board[i][j] != <span class="hljs-string">&#x27;O&#x27;</span>:<br>                <span class="hljs-keyword">return</span><br>            board[i][j] = <span class="hljs-string">&#x27;?&#x27;</span><br>            dfs(board, i + <span class="hljs-number">1</span>, j)<br>            dfs(board, i - <span class="hljs-number">1</span>, j)<br>            dfs(board, i, j + <span class="hljs-number">1</span>)<br>            dfs(board, i, j - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i == m - <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> j == n - <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                        dfs(board, i, j)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>:<br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span><br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;?&#x27;</span>:<br>                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>第一版时间复杂度O(m * n)，空间复杂度O(min(m, n))，执行时间40ms，消耗内存20.3MB<br>第二版时间复杂度O(m * n)，空间复杂度O(min(m, n))，执行时间54ms，消耗内存20.3MB</p><h1 id="133-克隆图-Medium"><a href="#133-克隆图-Medium" class="headerlink" title="133 克隆图 Medium"></a>133 克隆图 <font color=#ff7f50 size=4>Medium</font></h1><p>给你无向 <a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995?fr=aladdin">连通</a> 图中一个节点的引用，请你返回该图的 <a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a>（克隆）。</p><p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    public <span class="hljs-keyword">int</span> val;<br>    public List&lt;Node&gt; neighbors;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试用例格式：</p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p><p>邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。</p><p>示例 1：</p><figure>  <img src="/2024/08/22/leetcode-%E5%9B%BE/133_1.png" class="" title="133.1">  <figcaption>133.1</figcaption></figure><pre><code class="hljs">输入：adjList = [[2,4],[1,3],[2,4],[1,3]]输出：[[2,4],[1,3],[2,4],[1,3]]解释：图中有 4 个节点。节点 1 的值是 1，它有两个邻居：节点 2 和 4 。节点 2 的值是 2，它有两个邻居：节点 1 和 3 。节点 3 的值是 3，它有两个邻居：节点 2 和 4 。节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/22/leetcode-%E5%9B%BE/133_2.png" class="" title="133.2">  <figcaption>133.2</figcaption></figure><pre><code class="hljs">输入：adjList = [[]]输出：[[]]解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</code></pre><p>示例 3：</p><pre><code class="hljs">输入：adjList = []输出：[]解释：这个图是空的，它不含任何节点。</code></pre><p>提示：</p><p>这张图中的节点数在 <code>[0, 100]</code> 之间。</p><p><code>1 &lt;= Node.val &lt;= 100</code></p><p>每个节点值 <code>Node.val</code> 都是唯一的，</p><p>图中没有重复的边，也没有自环。</p><p>图是连通图，你可以从给定节点访问到所有节点。</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>简单来说就是使用一个 <code>DFS</code> 去遍历每个节点，然后将每个节点的值都拷贝过来。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cloneGraph</span>(<span class="hljs-params">self, node: <span class="hljs-type">Optional</span>[<span class="hljs-string">&#x27;Node&#x27;</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[<span class="hljs-string">&#x27;Node&#x27;</span>]:<br>        oldToNew = &#123;<span class="hljs-literal">None</span>: <span class="hljs-literal">None</span>&#125;<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">in</span> oldToNew:<br>                <span class="hljs-keyword">return</span> oldToNew[node]<br>            copy = Node(node.val)<br>            oldToNew[node] = copy<br>            <span class="hljs-keyword">for</span> nei <span class="hljs-keyword">in</span> node.neighbors:<br>                copy.neighbors.append(dfs(nei))<br>            <span class="hljs-keyword">return</span> copy<br>        <span class="hljs-keyword">return</span> dfs(node) <span class="hljs-keyword">if</span> node <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(V + E)，空间复杂度O(E)，执行时间44ms，消耗内存16.5MB</p><h1 id="399-除法求值-Medium"><a href="#399-除法求值-Medium" class="headerlink" title="399 除法求值 Medium"></a>399 除法求值 <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code> 共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或 <code>Bi</code> 是一个表示单个变量的字符串。</p><p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code> 的结果作为答案。</p><p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 <code>-1.0</code> 替代这个答案。</p><p>注意：输入总是有效的。你可以假设除法运算中不会出现除数为 <code>0</code> 的情况，且不存在任何矛盾的结果。</p><p>注意：未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。</p><p>示例 1：</p><pre><code class="hljs">输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]解释：条件：a / b = 2.0, b / c = 3.0问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]注意：x 是未定义的 =&gt; -1.0</code></pre><p>示例 2：</p><pre><code class="hljs">输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]输出：[3.75000,0.40000,5.00000,0.20000]示例 3：输入：equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]输出：[0.50000,2.00000,-1.00000,-1.00000]</code></pre><p>提示：</p><p><code>1 &lt;= equations.length &lt;= 20</code></p><p><code>equations[i].length == 2</code></p><p><code>1 &lt;= Ai.length, Bi.length &lt;= 5</code></p><p><code>values.length == equations.length</code></p><p><code>0.0 &lt; values[i] &lt;= 20.0</code></p><p><code>1 &lt;= queries.length &lt;= 20</code></p><p><code>queries[i].length == 2</code></p><p><code>1 &lt;= Cj.length, Dj.length &lt;= 5</code></p><p><code>Ai, Bi, Cj, Dj</code> 由小写英文字母与数字组成</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这题首先需要搞明白两个节点之间我们要怎么去算，按照数学逻辑来看我们已知 <code>a:b</code> <code>b:c</code>，我们相乘就可以得到 <code>a:c</code>。并且要得到自身到自身的值，也就是1.0。同时还需要得到当 <code>x</code> 不在我们输入的 <code>equations</code> 中的情况，所以我们的结果需要用 <code>-1.0</code> 直接填充。</p><p>明白了数理逻辑就可以直接开写，这里我们将直接转换为一个有向图，然后用BFS去做。构建图的部分直接看代码，我们重点说一下处理查询的部分。</p><p>对于我们的查询我们可以使用 <code>qx</code> and <code>qy</code> 去辅助完成，即找到 <code>qx</code> 到 <code>qy</code> 的路径并计算得到权值，如果找到了就会被添加到ans表中。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calcEquation</span>(<span class="hljs-params">self, equations: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]], values: <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>], queries: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>]:<br>        <span class="hljs-comment"># 图结构构建</span><br>        graph = &#123;&#125;<br>        <span class="hljs-keyword">for</span> (s, e), v <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(equations, values):<br>            <span class="hljs-keyword">if</span> s <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph:<br>                graph[s] = &#123;&#125; <span class="hljs-comment"># 存储neighbor的hash</span><br>            graph[s][e] = v<br>            <span class="hljs-keyword">if</span> e <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph:<br>                graph[e] = &#123;&#125;<br>            graph[e][s] = <span class="hljs-number">1</span> / v<br>            graph[s][s] = <span class="hljs-number">1.0</span><br>            graph[e][e] = <span class="hljs-number">1.0</span><br>        queue = [] <span class="hljs-comment"># BFS的队列</span><br>        n = <span class="hljs-built_in">len</span>(queries)<br>        ans = [-<span class="hljs-number">1.0</span>] * n<br>        <br>        <span class="hljs-comment"># 找最短路径</span><br>        <span class="hljs-keyword">for</span> i, (qx, qy) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(queries):<br>            <span class="hljs-keyword">if</span> qx <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph <span class="hljs-keyword">or</span> qy <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> graph: <span class="hljs-keyword">continue</span> <span class="hljs-comment"># x不在graph里面就跳过</span><br>            queue = [[qx, <span class="hljs-number">1.0</span>]] <span class="hljs-comment"># start</span><br>            visited = <span class="hljs-built_in">set</span>([qx]) <span class="hljs-comment"># 存储已经处理过的</span><br>            <span class="hljs-keyword">while</span> queue:<br>                node, mul = queue.pop(<span class="hljs-number">0</span>)<br>                <span class="hljs-comment"># 枚举并处理节点</span><br>                <span class="hljs-keyword">for</span> neighbor, weight <span class="hljs-keyword">in</span> graph[node].items():<br>                    <span class="hljs-keyword">if</span> neighbor == qy:<br>                        ans[i] = mul * weight<br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>                        visited.add(neighbor)<br>                        queue.append([neighbor, mul * weight])<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(V + E + Q)，空间复杂度O(V + E + Q)，执行时间42ms，消耗内存16.53</p><p>其中 <code>V</code> 表示节点数量， <code>E</code> 表示边的数量， <code>Q</code> 表示查询的数量。</p><h1 id="207-课程表-Medium"><a href="#207-课程表-Medium" class="headerlink" title="207 课程表 Medium"></a>207 课程表 <font color=#ff7f50 size=4>Medium</font></h1><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p><p>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>示例 1：</p><pre><code class="hljs">输入：numCourses = 2, prerequisites = [[1,0]]输出：true解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</code></pre><p>示例 2：</p><pre><code class="hljs">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]输出：false解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</code></pre><p>提示：</p><p><code>1 &lt;= numCourses &lt;= 2000</code></p><p><code>0 &lt;= prerequisites.length &lt;= 5000</code></p><p><code>prerequisites[i].length == 2</code></p><p><code>0 &lt;= ai, bi &lt; numCourses</code></p><p><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>我们使用一个入度数组和一个邻接表来完成这个题目。</p><p>首先完成入度数组和邻接表的遍历。接下来使用拓扑排序去完成排序，借助一个队列。</p><p>这里需要注意，我们的入度为0的时候就需要将其加入队列，最终如果没有数了，就表示我们这个图是没有环的，也就是课程表能够完成学习。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canFinish</span>(<span class="hljs-params">self, numCourses: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 初始化入度数组和邻接表</span><br>        in_degree = [<span class="hljs-number">0</span>] * numCourses<br>        adjacency = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses)]<br>        <br>        <span class="hljs-comment"># 构建邻接表和入度数组</span><br>        <span class="hljs-keyword">for</span> cur, pre <span class="hljs-keyword">in</span> prerequisites:<br>            adjacency[pre].append(cur)<br>            in_degree[cur] += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># 初始化队列，将所有入度为0的节点加入队列</span><br>        queue = deque()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>            <span class="hljs-keyword">if</span> in_degree[i] == <span class="hljs-number">0</span>:<br>                queue.append(i)<br>        <br>        <span class="hljs-comment"># 拓扑排序</span><br>        <span class="hljs-keyword">while</span> queue:<br>            node = queue.popleft()<br>            numCourses -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> adjacency[node]:<br>                in_degree[neighbor] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> in_degree[neighbor] == <span class="hljs-number">0</span>:<br>                    queue.append(neighbor)<br>        <br>        <span class="hljs-comment"># 如果所有节点都被访问过，说明没有环，可以完成所有课程</span><br>        <span class="hljs-keyword">return</span> numCourses == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(V + E)，空间复杂度O(V + E)，执行时间42ms，消耗内存17.5MB</p><h1 id="210-课程表-II-Medium"><a href="#210-课程表-II-Medium" class="headerlink" title="210 课程表 II Medium"></a>210 课程表 II <font color=#ff7f50 size=4>Medium</font></h1><p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code> 到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程 <code>ai</code> 前 <strong>必须</strong> 先选修 <code>bi</code> 。</p><p>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。<br>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p><p>示例 1：</p><pre><code class="hljs">输入：numCourses = 2, prerequisites = [[1,0]]输出：[0,1]解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</code></pre><p>示例 2：</p><pre><code class="hljs">输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]输出：[0,2,1,3]解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</code></pre><p>示例 3：</p><pre><code class="hljs">输入：numCourses = 1, prerequisites = []输出：[0]</code></pre><p>提示：</p><p><code>1 &lt;= numCourses &lt;= 2000</code></p><p><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></p><p><code>prerequisites[i].length == 2</code></p><p><code>0 &lt;= ai, bi &lt; numCourses</code></p><p><code>ai != bi</code></p><p>所有<code>[ai, bi]</code> <strong>互不相同</strong></p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>整体上和前一道题几乎一模一样，唯独需要一个 <code>res</code> 来装我们从 <code>queue</code> 里 <code>pop</code> 出来的变量。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findOrder</span>(<span class="hljs-params">self, numCourses: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        in_degree = [<span class="hljs-number">0</span>] * numCourses<br>        adjacency = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses)]<br>        <br>        <span class="hljs-keyword">for</span> cur, pre <span class="hljs-keyword">in</span> prerequisites:<br>            adjacency[pre].append(cur)<br>            in_degree[cur] += <span class="hljs-number">1</span><br>            <br>        queue = deque()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCourses):<br>            <span class="hljs-keyword">if</span> in_degree[i] == <span class="hljs-number">0</span>:<br>                queue.append(i)<br>        res = []<br>        <span class="hljs-keyword">while</span> queue:<br>            node = queue.popleft()<br>            res.append(node)<br>            <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> adjacency[node]:<br>                in_degree[neighbor] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> in_degree[neighbor] == <span class="hljs-number">0</span>:<br>                    queue.append(neighbor)<br>        <span class="hljs-keyword">return</span> res <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == numCourses <span class="hljs-keyword">else</span> []<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(V + E)，空间复杂度O(V + E)，执行时间38ms，消耗内存17.6MB</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——二叉搜索树</title>
    <link href="/2024/08/21/leetcode-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2024/08/21/leetcode-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="530-二叉搜索树的最小绝对差-Easy"><a href="#530-二叉搜索树的最小绝对差-Easy" class="headerlink" title="530 二叉搜索树的最小绝对差 Easy"></a>530 二叉搜索树的最小绝对差 <font color=#7fffd4 size=4>Easy</font></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题我们需要使用到二叉搜索树（BST）的一个特性：在二叉搜索树中，任意一个节点其左子树所有节点的值都小于该节点的值，其右子树所有节点的值都大于该结点的值。利用这个特性可以使得中序遍历按照从小到大的顺序访问树中所有的节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMinimumDifference</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                <span class="hljs-keyword">return</span><br>            dfs(node.left)<br>            <span class="hljs-variable language_">self</span>.res = <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.res, node.val - <span class="hljs-variable language_">self</span>.pre)<br>            <span class="hljs-variable language_">self</span>.pre = node.val<br>            dfs(node.right)<br><br>        <span class="hljs-variable language_">self</span>.res = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>.pre = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)<br>        dfs(root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间48ms，消耗内存18.4MB</p><h1 id="230-二叉搜索树中第K小的元素-Medium"><a href="#230-二叉搜索树中第K小的元素-Medium" class="headerlink" title="230 二叉搜索树中第K小的元素 Medium"></a>230 二叉搜索树中第K小的元素 <font color=#ff7f50 size=4>Medium</font></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>和前一题一样，直接利用BST的特性去做，这题会更直观的展示BST的特性的用法。</p><p>这题我自己写的和我看到的解法我都写在下面，本质上都是一样的。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthSmallest</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        stack = []<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">while</span> root:<br>                stack.append(root)<br>                root = root.left<br>            root = stack.pop()<br>            k -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> k:<br>                <span class="hljs-keyword">return</span> root.val<br>            root = root.right<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthSmallest</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.k == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span><br>            dfs(node.left)<br>            <span class="hljs-variable language_">self</span>.k -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.k == <span class="hljs-number">0</span>:<br>                <span class="hljs-variable language_">self</span>.ans = node.val<br>                <span class="hljs-keyword">return</span><br>            dfs(node.right)<br>        <span class="hljs-variable language_">self</span>.k = k<br>        dfs(root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ans<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthSmallest</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span><br>            dfs(root.left)<br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.k == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span><br>            <span class="hljs-variable language_">self</span>.k -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.k == <span class="hljs-number">0</span>: <span class="hljs-variable language_">self</span>.res = root.val<br>            dfs(root.right)<br>            <br>        <span class="hljs-variable language_">self</span>.k = k<br>        dfs(root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间52ms，消耗内存19.8MB</p><p>时间复杂度O(n)，空间复杂度O(n)，执行时间67ms，消耗内存19.8MB</p><p>时间复杂度O(n)，空间复杂度O(n)，执行时间44ms，消耗内存19.8MB</p><h1 id="98-验证二叉搜索树-Medium"><a href="#98-验证二叉搜索树-Medium" class="headerlink" title="98 验证二叉搜索树 Medium"></a>98 验证二叉搜索树 <font color=#ff7f50 size=4>Medium</font></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这道题需要引入两个边界，用于检验当前节点是否满足二叉搜索树的定义，其余和前面的思路一样</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node, l = <span class="hljs-built_in">float</span>(<span class="hljs-params"><span class="hljs-string">&#x27;-inf&#x27;</span></span>), r = <span class="hljs-built_in">float</span>(<span class="hljs-params"><span class="hljs-string">&#x27;inf&#x27;</span></span>)</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            pre = node.val<br>            <span class="hljs-keyword">if</span> pre &lt;= l <span class="hljs-keyword">or</span> pre &gt;= r:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(node.left, l, pre):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(node.right, pre, r):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> dfs(root)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间44ms，消耗内存18.5MB</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这几道题都涉及到了二叉搜索树的特性，利用BST的特性可以更好的解决问题。</p><p>所以和前一篇一样，我们针对这类题型也总结了模板</p><ol><li><p>中序遍历，适用于解决第k小，最小差值的问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>        <span class="hljs-keyword">return</span><br>    dfs(node.left)<br>    <span class="hljs-comment"># 处理当前节点</span><br>    dfs(node.right)<br></code></pre></td></tr></table></figure></li><li><p>递归，适用于判断是否为BST</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node, l, r</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">if</span> node.val &lt;= l <span class="hljs-keyword">or</span> node.val &gt;= r:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> dfs(node.left, l, node.val) <span class="hljs-keyword">and</span> dfs(node.right, node.val, r)<br></code></pre></td></tr></table></figure></li><li><p>栈，用于通过栈模拟中序遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">kthSmallest</span>(<span class="hljs-params">root, k</span>):<br>    stack = []<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">while</span> root:<br>            stack.append(root)<br>            root = root.left<br>        root = stack.pop()<br>        k -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> k:<br>            <span class="hljs-keyword">return</span> root.val<br>        root = root.right<br></code></pre></td></tr></table></figure></li></ol><p>不管怎么变，实际上都需要借助二叉搜索树的特性，借助特性就可以直接解决问题了。</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——二叉树层次遍历</title>
    <link href="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <url>/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="199-二叉树的右视图-Medium"><a href="#199-二叉树的右视图-Medium" class="headerlink" title="199 二叉树的右视图 Medium"></a>199 二叉树的右视图 <font color=#ff7f50 size=4>Medium</font></h1><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>示例 1:</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/199_1.jpg" class="" title="199.1">  <figcaption>199.1</figcaption></figure><pre><code class="hljs">输入: [1,2,3,null,5,null,4]输出: [1,3,4]</code></pre><p>示例 2:</p><pre><code class="hljs">输入: [1,null,3]输出: [1,3]</code></pre><p>示例 3:</p><pre><code class="hljs">输入: []输出: []</code></pre><p>提示:</p><p>二叉树的节点个数的范围是 <code>[0,100]</code></p><p><code>-100 &lt;= Node.val &lt;= 100 </code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里按照标题直接用DFS去遍历，保证我们首先处理的是右子树，这样遇到的第一个节点就会被压入。而当我们的有一层没有右子树的时候，就会将其左子树压入栈中。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rightSideView</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        res = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node, depth</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">if</span> depth == <span class="hljs-built_in">len</span>(res):<br>                res.append(node.val)<br>            dfs(node.right, depth + <span class="hljs-number">1</span>)<br>            dfs(node.left, depth + <span class="hljs-number">1</span>)<br>        dfs(root, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间41ms，消耗内存16.5MB</p><h1 id="637-二叉树的层平均值-Easy"><a href="#637-二叉树的层平均值-Easy" class="headerlink" title="637 二叉树的层平均值 Easy"></a>637 二叉树的层平均值 <font color=#7fffd4 size=4>Easy</font></h1><p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 $10^5$ 以内的答案可以被接受。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/637_1.jpg" class="" title="637.1">  <figcaption>637.1</figcaption></figure><pre><code class="hljs">输入：root = [3,9,20,null,null,15,7]输出：[3.00000,14.50000,11.00000]解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。因此返回 [3, 14.5, 11] 。</code></pre><p>示例 2:</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/637_2.jpg" class="" title="637.2">  <figcaption>637.2</figcaption></figure><pre><code class="hljs">输入：root = [3,9,20,15,7]输出：[3.00000,14.50000,11.00000]</code></pre><p>提示：</p><p>树中节点数量在 <code>[1, 104]</code> 范围内</p><p><code>-231 &lt;= Node.val &lt;= 231 - 1 </code></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>实际上就是每一层都需要被遍历到，当我们遇到有子节点的就把子节点存入 <code>childNode</code> 中然后再去走接下来的本层节点。后面把 <code>childNode</code> 导入我们最开始的全局变量 <code>queue</code> 中继续运行。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">averageOfLevels</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        res = []<br>        queue = [root]<br>        <span class="hljs-keyword">while</span> queue:<br>            <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>            childNode = []<br>            cnt = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> queue:<br>                <span class="hljs-built_in">sum</span> += node.val<br>            res.append(<span class="hljs-built_in">sum</span>/cnt)<br>            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> queue:<br>                <span class="hljs-keyword">if</span> node.left:<br>                    childNode.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    childNode.append(node.right)<br>            queue = childNode<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>由于第一个代码中while循环又套了两个for循环，速度太慢，我就简化了一下，只采用一个while加一个for，思路上是一样的，但注意具体的细节差异</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">averageOfLevels</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        res = []<br>        queue = [root]<br>        <span class="hljs-keyword">while</span> queue:<br>            <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>            cnt = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cnt):<br>                node = queue.pop(<span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">sum</span> += node.val<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>            res.append(<span class="hljs-built_in">sum</span>/cnt)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>第一个算法<br>时间复杂度O(n)，空间复杂度O(n)，执行时间66ms，消耗内存18.6MB<br>第二个算法<br>时间复杂度O(n^2)，空间复杂度O(n) + O(h)，执行时间41ms，消耗内存18.6MB</p><h1 id="102-二叉树的层序遍历-Medium"><a href="#102-二叉树的层序遍历-Medium" class="headerlink" title="102 二叉树的层序遍历 Medium"></a>102 二叉树的层序遍历 <font color=#ff7f50 size=4>Medium</font></h1><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/102_1.jpg" class="" title="102.1">  <figcaption>102.1</figcaption></figure><pre><code class="hljs">输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：root = [1]输出：[[1]]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：root = []输出：[]</code></pre><p>提示：</p><p>树中节点数目在范围 <code>[0, 2000]</code> 内</p><p><code>-1000 &lt;= Node.val &lt;= 1000</code></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>和前一题一样，按照题意的顺序遍历即可，只需要去掉计算平均值这个步骤就可以，用前议题已经优化后的思路会比第一种的更快（leetcode上能超越97.73%的人）</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        res = []<br>        queue = [root]<br>        <span class="hljs-keyword">while</span> queue:<br>            res.append([])<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                node = queue.pop(<span class="hljs-number">0</span>)<br>                res[-<span class="hljs-number">1</span>].append(node.val)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间29ms，消耗内存17.1MB</p><h1 id="103-二叉树的锯齿形层次遍历-Medium"><a href="#103-二叉树的锯齿形层次遍历-Medium" class="headerlink" title="103 二叉树的锯齿形层次遍历 Medium"></a>103 二叉树的锯齿形层次遍历 <font color=#ff7f50 size=4>Medium</font></h1><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>示例 1：</p> <figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/103_1.jpg" class="" title="103.1">  <figcaption>103.1</figcaption></figure><pre><code class="hljs">输入：root = [3,9,20,null,null,15,7]输出：[[3],[20,9],[15,7]]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：root = [1]输出：[[1]]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：root = []输出：[]</code></pre><p>提示：</p><p>树中节点数目在范围 <code>[0, 2000]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这题和前一道题唯一一个不同就在于对奇偶层的不同操作。当我们在处理这个时一个取余就可与做到，当奇数层时将节点正常进行添加，当偶数层时对节点值进行倒序添加。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">zigzagLevelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        res = []<br>        queue = [root]<br>        <span class="hljs-keyword">while</span> queue:<br>            res.append([])<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                node = queue.pop(<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>                    res[-<span class="hljs-number">1</span>].append(node.val)<br>                <span class="hljs-keyword">else</span>:<br>                    res[-<span class="hljs-number">1</span>].insert(<span class="hljs-number">0</span>, node.val)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间40ms，消耗内存16.6MB</p><h1 id="总结——层次遍历BFS模板"><a href="#总结——层次遍历BFS模板" class="headerlink" title="总结——层次遍历BFS模板"></a>总结——层次遍历BFS模板</h1><p>这四道题可以看出基本上都是一套思路，虽然第一题不太一样。</p><p>但看其余三道题可以看出都是同一个思路去做，在细微差别上进行部分修改添加条件。</p><p>模板如下</p><p>二叉树层次遍历(BFS)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">traversalTemplate</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[数据类型]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> []<br>        <br>        res = []<br>        queue = [root]<br>        <br>        <span class="hljs-keyword">while</span> queue:<br>            <span class="hljs-comment"># 初始化本层的结果存储</span><br>            level = []<br>            <br>            <span class="hljs-comment"># 遍历当前层的所有节点</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                node = queue.pop(<span class="hljs-number">0</span>)<br>                <br>                <span class="hljs-comment"># 处理节点的值（可根据题目要求自定义处理方式）</span><br>                level.append(node.val)<br>                <br>                <span class="hljs-comment"># 将下一层的节点加入队列</span><br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br>            <br>            <span class="hljs-comment"># 处理层结果（如果有特殊要求，可在这里进行处理）</span><br>            res.append(level)<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——二叉树</title>
    <link href="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="104-二叉树的最大深度-Easy"><a href="#104-二叉树的最大深度-Easy" class="headerlink" title="104. 二叉树的最大深度 Easy"></a>104. 二叉树的最大深度 <font color=#7fffd4 size=4>Easy</font></h1><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/104_1.jpg" class="" title="104.1">  <figcaption>104.1</figcaption></figure><pre><code class="hljs">输入：root = [3,9,20,null,null,15,7]输出：3</code></pre><p>示例 2：</p><pre><code class="hljs">输入：root = [1,null,2]输出：2</code></pre><p>提示：</p><p>树中节点的数量在 <code>[0, 104]</code> 区间内。</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题基本上没啥好说的🤣，就是两个maxDepth最后加个1</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-variable language_">self</span>.maxDepth(root.left), <span class="hljs-variable language_">self</span>.maxDepth(root.right))<br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(h)，执行时间43ms，消耗内存17.7MB</p><h1 id="100-相同的树-Easy"><a href="#100-相同的树-Easy" class="headerlink" title="100 相同的树 Easy"></a>100 相同的树 <font color=#7fffd4 size=4>Easy</font></h1><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/100_1.jpg" class="" title="100.1">  <figcaption>100.1</figcaption></figure><pre><code class="hljs">输入：p = [1,2,3], q = [1,2,3]输出：true</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/100_2.jpg" class="" title="100.2">  <figcaption>100.2</figcaption></figure><pre><code class="hljs">输入：p = [1,2], q = [1,null,2]输出：false</code></pre><p>示例 3：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/100_3.jpg" class="" title="100.3">  <figcaption>100.3</figcaption></figure><pre><code class="hljs">输入：p = [1,2,1], q = [1,1,2]输出：false</code></pre><p>提示：</p><p>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</p><p><code>-104 &lt;= Node.val &lt;= 104</code></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这里也一样，没什么好说的。我这里条件写的有点复杂，我看好一点的两个判断语句搞定，有一个一个判断语句搞定。后面直接用isSameTree就搞定（简单题你还指望我干啥，造火箭吗）</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSameTree</span>(<span class="hljs-params">self, p: <span class="hljs-type">Optional</span>[TreeNode], q: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> q:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> q:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> p.val != q.val:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.isSameTree(p.left, q.left) <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.isSameTree(p.right, q.right)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(h)，执行时间48ms，消耗内存16，2MB</p><h1 id="226-翻转二叉树-Easy"><a href="#226-翻转二叉树-Easy" class="headerlink" title="226 翻转二叉树 Easy"></a>226 翻转二叉树 <font color=#7fffd4 size=4>Easy</font></h1><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/226_1.jpg" class="" title="226.1">  <figcaption>226.1</figcaption></figure><pre><code class="hljs">输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1]</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/226_2.jpg" class="" title="226.2">  <figcaption>226.2</figcaption></figure><pre><code class="hljs">输入：root = [2,1,3]输出：[2,3,1]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：root = []输出：[]</code></pre><p>提示：</p><p>树中节点数目范围在 <code>[0, 100]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>思路上没啥难的，但是！那个梗真的好好笑，我之前真的不知道这个梗。翻评论看到半天没反应过来咋回事，一搜才知道。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invertTree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        root.left, root.right = root.right, root.left<br>        <span class="hljs-variable language_">self</span>.invertTree(root.left)<br>        <span class="hljs-variable language_">self</span>.invertTree(root.right)<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间27ms，消耗内存16.2MB</p><h1 id="101-对称二叉树-Easy"><a href="#101-对称二叉树-Easy" class="headerlink" title="101 对称二叉树 Easy"></a>101 对称二叉树 <font color=#7fffd4 size=4>Easy</font></h1><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/101_1.png" class="" title="101.1">  <figcaption>101.1</figcaption></figure><pre><code class="hljs">输入：root = [1,2,2,3,4,4,3]输出：true</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/101_2.png" class="" title="101.2">  <figcaption>101.2</figcaption></figure><pre><code class="hljs">输入：root = [1,2,2,null,3,null,3]输出：false</code></pre><p>提示：</p><p>树中节点数目在范围 <code>[1, 1000]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>递归判断，如果左子树和右子树对称，那么左子树的左子树和右子树的右子树都是对称的，左子树的右子树和右子树的左子树都是对称的。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSymmetric</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">isMirror</span>(<span class="hljs-params">left, right</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> right:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> left <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> right <span class="hljs-keyword">or</span> left.val != right.val:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> isMirror(left.left, right.right) <span class="hljs-keyword">and</span> isMirror(left.right, right.left)<br>        <span class="hljs-keyword">return</span> isMirror(root.left, root.right)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间48ms，消耗内存16.4MB</p><h1 id="105-从前序与中序遍历序列构造二叉树-Medium"><a href="#105-从前序与中序遍历序列构造二叉树-Medium" class="headerlink" title="105 从前序与中序遍历序列构造二叉树 Medium"></a>105 从前序与中序遍历序列构造二叉树 <font color=#ff7f50 size=4>Medium</font></h1><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p>xxxxxxxxxx29 1class Solution:2    def traversalTemplate(self, root: Optional[TreeNode]) -&gt; List[数据类型]:3        if not root:4            return []5        6        res &#x3D; []7        queue &#x3D; [root]8        9        while queue:10            # 初始化本层的结果存储11            level &#x3D; []12            13            # 遍历当前层的所有节点14            for i in range(len(queue)):15                node &#x3D; queue.pop(0)16                17                # 处理节点的值（可根据题目要求自定义处理方式）18                level.append(node.val)19                20                # 将下一层的节点加入队列21                if node.left:22                    queue.append(node.left)23                if node.right:24                    queue.append(node.right)25            26            # 处理层结果（如果有特殊要求，可在这里进行处理）27            res.append(level)28        29        return respython</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/105_1.jpg" class="" title="105.1">  <figcaption>105.1</figcaption></figure><pre><code class="hljs">输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]输出: [3,9,20,null,null,15,7]</code></pre><p>示例 2:</p><pre><code class="hljs">输入: preorder = [-1], inorder = [-1]输出: [-1]</code></pre><p>提示:</p><p><code>1 &lt;= preorder.length &lt;= 3000</code></p><p><code>inorder.length == preorder.length</code></p><p><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></p><p><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</p><p><code>inorder</code> 均出现在 <code>preorder</code></p><p><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</p><p><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><ol><li>根据前序遍历可以得到根节点就是 <code>TreeNode[0]</code> ，再根据中序遍历可以得到根节点的左右子树，然后递归，继续求就可以了</li><li>注意边界条件，如果前序遍历为空或中序遍历为空，那么返回空</li></ol><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">self, preorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], inorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> preorder <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> inorder:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        root = TreeNode(preorder[<span class="hljs-number">0</span>])<br>        mid = inorder.index(preorder[<span class="hljs-number">0</span>])<br>        root.left = <span class="hljs-variable language_">self</span>.buildTree(preorder[<span class="hljs-number">1</span> : mid + <span class="hljs-number">1</span>], inorder[: mid])<br>        root.right = <span class="hljs-variable language_">self</span>.buildTree(preorder[mid + <span class="hljs-number">1</span> :], inorder[mid + <span class="hljs-number">1</span> :])<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间149ms，消耗内存86.4MB</p><h1 id="106-从中序与后序遍历序列构造二叉树-Medium"><a href="#106-从中序与后序遍历序列构造二叉树-Medium" class="headerlink" title="106 从中序与后序遍历序列构造二叉树 Medium"></a>106 从中序与后序遍历序列构造二叉树 <font color=#ff7f50 size=4>Medium</font></h1><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p>示例 1:</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/106_1.jpg" class="" title="106.1">  <figcaption>106.1</figcaption></figure><pre><code class="hljs">输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]输出：[3,9,20,null,null,15,7]</code></pre><p>示例 2:</p><pre><code class="hljs">输入：inorder = [-1], postorder = [-1]输出：[-1]</code></pre><p>提示:</p><p><code>1 &lt;= inorder.length &lt;= 3000</code></p><p><code>postorder.length == inorder.length</code></p><p><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></p><p><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</p><p><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</p><p><code>inorder</code> <strong>保证</strong>是树的中序遍历</p><p><code>postorder</code> <strong>保证</strong>是树的后序遍历</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>和105一样，通过后序遍历得到根节点（最后一个就是），然后通过中序遍历得到根节点的左右子树，然后递归，继续求就可以了</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">buildTree</span>(<span class="hljs-params">self, inorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], postorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inorder <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> postorder:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        root = TreeNode(postorder[-<span class="hljs-number">1</span>])<br>        mid = inorder.index(postorder[-<span class="hljs-number">1</span>])<br>        root.left = <span class="hljs-variable language_">self</span>.buildTree(inorder[: mid], postorder[: mid])<br>        root.right = <span class="hljs-variable language_">self</span>.buildTree(inorder[mid + <span class="hljs-number">1</span> : ], postorder[mid : -<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)执行时间143ms，消耗内存86.5MB</p><h1 id="117-填充每个节点的下一个右侧节点指针ⅡMedium"><a href="#117-填充每个节点的下一个右侧节点指针ⅡMedium" class="headerlink" title="117 填充每个节点的下一个右侧节点指针ⅡMedium"></a>117 填充每个节点的下一个右侧节点指针Ⅱ<font color=#ff7f50 size=4>Medium</font></h1><p>给定一个二叉树：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  int</span> val;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*left</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*right</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code> 。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code> 。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/117_1.png" class="" title="117.1">  <figcaption>117.1</figcaption></figure><pre><code class="hljs">输入：root = [1,2,3,4,5,null,7]输出：[1,#,2,3,#,4,5,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），&#39;#&#39; 表示每层的末尾。</code></pre><p>示例 2：</p><pre><code class="hljs">输入：root = []输出：[]</code></pre><p>提示：</p><p>树中的节点数在范围 <code>[0, 6000]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>这里直接考虑DFS或BFS。</p><p>我采用的是BFS，通过一个列表来存储最终结果，通过另一个列表来存储每一层的节点。</p><p>有当前节点的左右节点就加入到队列中，然后用一个循环进行遍历将每一次节点连接起来（仅本层）</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Node&#x27;</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> root<br>        queue = [root]<br>        <span class="hljs-keyword">while</span> queue:<br>            next_queue = []<br>            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> queue:<br>                <span class="hljs-keyword">if</span> node.left:<br>                    next_queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    next_queue.append(node.right)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue) - <span class="hljs-number">1</span>):<br>                queue[i].<span class="hljs-built_in">next</span> = queue[i + <span class="hljs-number">1</span>]<br>            queue = next_queue<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间46ms，消耗内存17.4MB</p><h1 id="114-二叉树展开为链表-Medium"><a href="#114-二叉树展开为链表-Medium" class="headerlink" title="114 二叉树展开为链表 Medium"></a>114 二叉树展开为链表 <font color=#ff7f50 size=4>Medium</font></h1><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</p><p>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin">先序遍历</a> 顺序相同。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/114_1.jpg" class="" title="114.1">  <figcaption>114.1</figcaption></figure><pre><code class="hljs">输入：root = [1,2,5,3,4,null,6]输出：[1,null,2,null,3,null,4,null,5,null,6]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：root = []输出：[]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：root = [0]输出：[0]</code></pre><p>提示：</p><p>树中结点数在范围 <code>[0, 2000]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>这里需要涉及到一个函数 <strong>flatten</strong>，该函数会自动将树拉直，所以我们分别让左右子树拉直然后右子树接在左子树后面就可以了</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-variable language_">self</span>.flatten(root.left)<br>        <span class="hljs-variable language_">self</span>.flatten(root.right)<br>        <br>        left = root.left<br>        right = root.right<br>        <br>        root.left = <span class="hljs-literal">None</span><br>        root.right = left<br>        <br>        p = root<br>        <span class="hljs-keyword">while</span> p.right:<br>            p = p.right<br>        p.right = right<br>            <br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间36ms，消耗内存16.7MB</p><h1 id="112-路径之和-Easy"><a href="#112-路径之和-Easy" class="headerlink" title="112 路径之和 Easy"></a>112 路径之和 <font color=#7fffd4 size=4>Easy</font></h1><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/112_1.jpg" class="" title="112.1">  <figcaption>112.1</figcaption></figure><pre><code class="hljs">输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22输出：true解释：等于目标和的根节点到叶节点路径如上图所示。</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/112_2.jpg" class="" title="112.2">  <figcaption>112.2</figcaption></figure><pre><code class="hljs">输入：root = [1,2,3], targetSum = 5输出：false解释：树中存在两条根节点到叶子节点的路径：(1 --&gt; 2): 和为 3(1 --&gt; 3): 和为 4不存在 sum = 5 的根节点到叶子节点的路径。</code></pre><p>示例 3：</p><pre><code class="hljs">输入：root = [], targetSum = 0输出：false解释：由于树是空的，所以不存在根节点到叶子节点的路径。</code></pre><p>提示：</p><p>树中节点的数目在范围 <code>[0, 5000]</code> 内</p><p><code>-1000 &lt;= Node.val &lt;= 1000</code></p><p><code>-1000 &lt;= targetSum &lt;= 1000</code></p><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>这题的核心在于使用一个函数hashPathSum，函数有两个参数（当前子树root，剩余目标sum），最终输出一个bool变量。</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], targetSum: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> root.right <span class="hljs-keyword">and</span> root.val == targetSum:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.hasPathSum(root.left, targetSum - root.val) <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.hasPathSum(root.right, targetSum - root.val)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间41ms，消耗内存17.5MB</p><h1 id="129-求根节点到叶子节点数字之和-Medium"><a href="#129-求根节点到叶子节点数字之和-Medium" class="headerlink" title="129 求根节点到叶子节点数字之和 Medium"></a>129 求根节点到叶子节点数字之和 <font color=#ff7f50 size=4>Medium</font></h1><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p><p>每条从根节点到叶节点的路径都代表一个数字：</p><p>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。<br>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p><p><strong>叶节点</strong> 是指没有子节点的节点。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/129_1.jpg" class="" title="129.1">  <figcaption>129.1</figcaption></figure><pre><code class="hljs">输入：root = [1,2,3]输出：25解释：从根到叶子节点路径 1-&gt;2 代表数字 12从根到叶子节点路径 1-&gt;3 代表数字 13因此，数字总和 = 12 + 13 = 25</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/129_2.jpg" class="" title="129.2">  <figcaption>129.2</figcaption></figure><pre><code class="hljs">输入：root = [4,9,0,5,1]输出：1026解释：从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491从根到叶子节点路径 4-&gt;0 代表数字 40因此，数字总和 = 495 + 491 + 40 = 1026</code></pre><p>提示：</p><p>树中节点的数目在范围 <code>[1, 1000]</code> 内</p><p><code>0 &lt;= Node.val &lt;= 9</code></p><p>树的深度不超过 <code>10</code></p><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>用递归去解决，值就是原本的值*10加当前节点的值，处理方法还是很好理解的，然后分别对左右子树进行递归，搞定。</p><p>进入二叉树的条件是dfs(root, 0)</p><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumNumbers</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node, path</span>):<br>            <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br>            path = path * <span class="hljs-number">10</span> + node.val<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right:<br>                <span class="hljs-variable language_">self</span>.ans += path<br>            dfs(node.left, path)<br>            dfs(node.right, path)<br>                <br>        <span class="hljs-variable language_">self</span>.ans = <span class="hljs-number">0</span><br>        dfs(root, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ans<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间37ms，消耗内存16.4MB</p><h1 id="124-二叉树中的最大路径和-Hard"><a href="#124-二叉树中的最大路径和-Hard" class="headerlink" title="124 二叉树中的最大路径和 Hard"></a>124 二叉树中的最大路径和 <font color=#ff0000 size=4>Hard</font></h1><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/124_1.jpg" class="" title="124.1">  <figcaption>124.1</figcaption></figure><pre><code class="hljs">输入：root = [1,2,3]输出：6解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/124_2.jpg" class="" title="124.2">  <figcaption>124.2</figcaption></figure><pre><code class="hljs">输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</code></pre><p>提示：</p><p>树中节点数目范围是 <code>[1, 3 * 104]</code></p><p><code>-1000 &lt;= Node.val &lt;= 1000</code></p><h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>这里照样可以使用dfs的递归调用，不断更新最大值，最后返回最大值。</p><p>我的做法是直接使用类属性 <code>self.ans</code> 来记录最大值。这样作用域会更广，并且可以在其它类方法中使用。</p><p>不过相比于leetcode上大部分人所用的声明局部变量后通过 <code>nonlocal</code> 来转换为非局部变量，我的做法虽然可以在其它类中调用但是速度更慢一些。</p><h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-variable language_">self</span>.ans = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            left = <span class="hljs-built_in">max</span>(dfs(node.left), <span class="hljs-number">0</span>)<br>            right = <span class="hljs-built_in">max</span>(dfs(node.right), <span class="hljs-number">0</span>)<br>            <span class="hljs-variable language_">self</span>.ans = <span class="hljs-built_in">max</span>(<span class="hljs-variable language_">self</span>.ans, node.val + left + right)<br>            <span class="hljs-keyword">return</span> node.val + <span class="hljs-built_in">max</span>(left, right)<br>        dfs(root)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.ans<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间80ms，消耗内存21.6MB</p><h1 id="173-二叉搜索树递归器-Medium"><a href="#173-二叉搜索树递归器-Medium" class="headerlink" title="173 二叉搜索树递归器 Medium"></a>173 二叉搜索树递归器 <font color=#ff7f50 size=4>Medium</font></h1><p>实现一个二叉搜索树迭代器类<code>BSTIterator</code> ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p><p><code>BSTIterator(TreeNode root)</code> 初始化 <code>BSTIterator</code> 类的一个对象。BST 的根节点 <code>root</code> 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</p><p><code>boolean hasNext()</code> 如果向指针右侧遍历存在数字，则返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>int next()</code>将指针向右移动，然后返回指针处的数字。</p><p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 <code>next()</code> 的首次调用将返回 BST 中的最小元素。</p><p>你可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 的中序遍历中至少存在一个下一个数字。</p><p>示例：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/173_1.png" class="" title="173.1">  <figcaption>173.1</figcaption></figure><pre><code class="hljs">输入[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;][[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]输出[null, 3, 7, true, 9, true, 15, true, 20, false]解释BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);bSTIterator.next();    // 返回 3bSTIterator.next();    // 返回 7bSTIterator.hasNext(); // 返回 TruebSTIterator.next();    // 返回 9bSTIterator.hasNext(); // 返回 TruebSTIterator.next();    // 返回 15bSTIterator.hasNext(); // 返回 TruebSTIterator.next();    // 返回 20bSTIterator.hasNext(); // 返回 False</code></pre><p>提示：</p><p>树中节点的数目在范围 <code>[1, 105]</code> 内</p><p><code>0 &lt;= Node.val &lt;= 106</code></p><p>最多调用 $10^5$ 次 <code>hasNext</code> 和 <code>next</code> 操作</p><h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>首先我最开始的写法发现pushAll已经不支持了，立马改写法</p><p>然后我们看正确代码，思路上还是使用一个双端队列来存结果。额外创建一个函数——中序遍历，用这个来将二叉树的节点进行遍历，然后我们按照题目给的意思去写 <code>next</code> 和 <code>hashnext</code> 函数。</p><p>这里需要注意一点题目中所说的当前节点的下一个节点有数返回True，这个直接转化为长度存在就返回True，这样可以避免看到题目第一反应用指针去做。</p><h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><p>错误版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>):<br>        <span class="hljs-variable language_">self</span>.stack = []<br>        <span class="hljs-variable language_">self</span>.pushAll(root)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        node = <span class="hljs-variable language_">self</span>.stack.pop()<br>        <span class="hljs-variable language_">self</span>.pushAll(node.right)<br>        <span class="hljs-keyword">return</span> node.val<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasNext</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.stack) &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>):<br>        <span class="hljs-variable language_">self</span>.queue = collections.deque()<br>        <span class="hljs-variable language_">self</span>.inOrder(root)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inOrder</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> <br>        <span class="hljs-variable language_">self</span>.inOrder(root.left)<br>        <span class="hljs-variable language_">self</span>.queue.append(root.val)<br>        <span class="hljs-variable language_">self</span>.inOrder(root.right)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.queue.popleft()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasNext</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.queue) &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间74ms，消耗内存22.5MB</p><h1 id="222-完全二叉树的节点数-Easy"><a href="#222-完全二叉树的节点数-Easy" class="headerlink" title="222 完全二叉树的节点数 Easy"></a>222 完全二叉树的节点数 <font color=#7fffd4 size=4>Easy</font></h1><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 1~ $2^h$ 个节点。</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/222_1.jpg" class="" title="222.1">  <figcaption>222.1</figcaption></figure><pre><code class="hljs">输入：root = [1,2,3,4,5,6]输出：6</code></pre><p>示例 2：</p><pre><code class="hljs">输入：root = []输出：0</code></pre><p>示例 3：</p><pre><code class="hljs">输入：root = [1]输出：1</code></pre><p>提示：</p><p>树中节点的数目范围是 <code>[0, 5 * 104]</code></p><p><code>0 &lt;= Node.val &lt;= 5 * 104</code></p><p>题目数据保证输入的树是 <strong>完全二叉树</strong></p><h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><p>直接调用countNode函数，记得分别对左右子树进行调用</p><h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countNodes</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-variable language_">self</span>.countNodes(root.left) + <span class="hljs-variable language_">self</span>.countNodes(root.right)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-12"><a href="#时间复杂度-12" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间65ms，消耗内存22MB</p><h1 id="236-二叉树的最近公共祖先-Medium"><a href="#236-二叉树的最近公共祖先-Medium" class="headerlink" title="236 二叉树的最近公共祖先 Medium"></a>236 二叉树的最近公共祖先 <font color=#ff7f50 size=4>Medium</font></h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大<strong>（一个节点也可以是它自己的祖先）</strong>。”</p><p>示例 1：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/236_1.png" class="" title="236.1">  <figcaption>236.1</figcaption></figure><pre><code class="hljs">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出：3解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/20/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91/236_2.png" class="" title="236.2">  <figcaption>236.2</figcaption></figure><pre><code class="hljs">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出：5解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p>示例 3：</p><pre><code class="hljs">输入：root = [1,2], p = 1, q = 2输出：1</code></pre><p>提示：</p><p>树中节点数目在范围 <code>[2, 105]</code> 内。</p><p><code>-109 &lt;= Node.val &lt;= 109</code></p><p>所有 <code>Node.val</code> <strong>互不相同</strong> 。</p><p><code>p != q</code></p><p><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</p><h2 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h2><p>这里直接用lowestCommonAncestor函数，传入两个节点，返回公共祖先。</p><h2 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, p: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, q: <span class="hljs-string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;TreeNode&#x27;</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root <span class="hljs-keyword">or</span> root == p <span class="hljs-keyword">or</span> root == q: <span class="hljs-keyword">return</span> root<br>        left = <span class="hljs-variable language_">self</span>.lowestCommonAncestor(root.left, p, q)<br>        right = <span class="hljs-variable language_">self</span>.lowestCommonAncestor(root.right, p, q)<br>        <span class="hljs-keyword">if</span> left <span class="hljs-keyword">and</span> right:<br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-keyword">return</span> left <span class="hljs-keyword">if</span> left <span class="hljs-keyword">else</span> right<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-13"><a href="#时间复杂度-13" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，空间复杂度O(n)，执行时间47ms，消耗内存20.7MB</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go学习记录——第七天</title>
    <link href="/2024/08/15/go-study-seventh-day/"/>
    <url>/2024/08/15/go-study-seventh-day/</url>
    
    <content type="html"><![CDATA[<h1 id="Map的声明、初始化和make"><a href="#Map的声明、初始化和make" class="headerlink" title="Map的声明、初始化和make"></a>Map的声明、初始化和make</h1><p>这里的<code>map</code>相当于python中的字典，由key:value组成，无序集合。</p><p>声明格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> map1 <span class="hljs-keyword">map</span>[KeyType]ValueType<br><span class="hljs-keyword">var</span> map1 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>在声明时并不知道<code>map</code>长度，<code>map</code>是支持动态增长的。</p><p>未初始化的<code>map</code>默认值为<code>nil</code>。</p><p><code>key</code>支持使用<code>==</code> or <code>!=</code>进行比较类型，比如<code>string</code>, <code>int</code>, <code>float32</code>。所以数组、切片和结构体不能作为<code>key</code>，含数组、切片的结构体不能作为<code>key</code>，只包含内建类型的<code>struct</code>可以作为<code>key</code>，指针和接口类型可以作为<code>key</code>。</p><p>如果要用结构体作为<code>key</code>，必须满足以下条件：</p><ol><li>结构体的字段必须是可导出的。</li><li>结构体的字段必须是基本类型。</li><li>结构体不能是指针类型。</li></ol><p><code>value</code>可以是任意类型；通过使用空接口类型，我们可以存储任意类型的数据，但是使用这种类型的值需要先做一个类型断言。</p><p><code>map</code>传递给函数的代价很小，在查找值方面比较快，比线性查找快。但是相比于数组的切片中的索引还是较慢。</p><p><code>map</code>可以用函数做自己的值，这样可以使用分支结构（之前有，第二篇go的学习记录里），<code>key</code>来选择需要执行的函数。</p><p>如果<code>key1</code>是<code>map1</code>的key，那么就可以使用<code>map1[key1]</code>来获取<code>value</code>，和数组索引是一个样的。</p><p>如果<code>key1</code>是<code>map1</code>的key，那么就可以使用<code>map1[key1] = value</code>来修改<code>value</code>，和数组索引是一个样的。</p><p>同样<code>v := map1[key1]</code>也可以赋值给v，如果key1位置没有值则给值类型的空值。</p><p>同样<code>len(map1)</code>也可以获取map的长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> mapLit <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><span class="hljs-comment">//var mapCreated map[string]float32</span><br><span class="hljs-keyword">var</span> mapAssigned <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><br>mapLit = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;one&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span>: <span class="hljs-number">2</span>&#125;<br>mapCreated := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float32</span>)<br>mapAssigned = mapLit<br><br>mapCreated[<span class="hljs-string">&quot;key1&quot;</span>] = <span class="hljs-number">4.5</span><br>mapCreated[<span class="hljs-string">&quot;key2&quot;</span>] = <span class="hljs-number">3.14159</span><br>mapAssigned[<span class="hljs-string">&quot;two&quot;</span>] = <span class="hljs-number">3</span><br><br>fmt.Printf(<span class="hljs-string">&quot;Map literal at \&quot;one\&quot; is: %d\n&quot;</span>, mapLit[<span class="hljs-string">&quot;one&quot;</span>])<br>fmt.Printf(<span class="hljs-string">&quot;Map created at \&quot;key2\&quot; is: %f\n&quot;</span>, mapCreated[<span class="hljs-string">&quot;key2&quot;</span>])<br>fmt.Printf(<span class="hljs-string">&quot;Map assigned at \&quot;two\&quot; is: %d\n&quot;</span>, mapLit[<span class="hljs-string">&quot;two&quot;</span>])<br>fmt.Printf(<span class="hljs-string">&quot;Map literal at \&quot;ten\&quot; is: %d\n&quot;</span>, mapLit[<span class="hljs-string">&quot;ten&quot;</span>])<br>&#125;<br><br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">Map literal at &quot;one&quot; is: 1</span><br><span class="hljs-comment">Map created at &quot;key2&quot; is: 3.141590</span><br><span class="hljs-comment">Map assigned at &quot;two&quot; is: 3</span><br><span class="hljs-comment">Map literal at &quot;ten&quot; is: 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>mapLit</code>说明了 <code>map literals</code> 的使用方法：<code>map</code>可以用<code>&#123;key1 : value1, key2 : value2&#125;</code>的方式初始化。</p><p><code>map</code> 是引用类型的：内存用 <code>make()</code> 来分配。</p><p><code>map</code> 的初始化：<code>make(map[KeyType]ValueType)</code></p><p>简写为 <code>map1 := make(map[keytype]valuetype)</code></p><p><code>mapAssigned</code> 也是对 <code>mapLit</code> 的引用，对 <code>mapAssigned</code> 的修改会影响 <code>mapLit</code>。</p><p>绝对不要用 <code>new()</code> 来构造 <code>map</code>，因为使用了会获得一个空引用的指针，相当于声明了一个未初始化的变量并获取了地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">mapCreated := <span class="hljs-built_in">new</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float32</span>)<br><span class="hljs-comment">//调用 mapCreated[&quot;key1&quot;] = 4.5</span><br><span class="hljs-type">error</span>：invalid operation: mapCreated[<span class="hljs-string">&quot;key1&quot;</span>] (index of <span class="hljs-keyword">type</span> *<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float32</span>).<br></code></pre></td></tr></table></figure><h2 id="map容量"><a href="#map容量" class="headerlink" title="map容量"></a>map容量</h2><p>由于 <code>map</code> 是动态增长的，所以其不存在最大限制，但是在初始化时我们仍可以表明初始容量，<code>make(map[keytype]valuetype, cap)</code></p><p>当然在达到容量上限后继续增加，编译器会自动加1，但如果为了性能考虑，我们在已经提前知道大概容量的情况下，可以提前表明。</p><h2 id="用切片作为map的值"><a href="#用切片作为map的值" class="headerlink" title="用切片作为map的值"></a>用切片作为map的值</h2><p>既然一个key对应一个value，而value又是一个原始类型，那么如果一个key对应一个切片，那么它的value就是一个切片。举个例子，当我们在处理Unix系统上进程时，父进程是key，子进程是value，我们就可以将value定义为<code>[]int</code>类型或其他所有类型的切片，就可与解决。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> map1 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">int</span><br>map1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">int</span>)<br>map1[<span class="hljs-string">&quot;parent&quot;</span>] = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>map1[<span class="hljs-string">&quot;child&quot;</span>] = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>fmt.Println(map1)<br>&#125;<br><br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">map[parent:[1 2 3] child:[4 5 6]]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="测试键值对是否存在和删除元素"><a href="#测试键值对是否存在和删除元素" class="headerlink" title="测试键值对是否存在和删除元素"></a>测试键值对是否存在和删除元素</h1><p>这里我们可以用 <code>val1, isPresent = map1[key1]</code> 来判断元素是否存在。</p><p><code>isPresent</code> 是一个布尔值，<code>true</code>表示存在，<code>false</code>表示不存在。</p><p>如果只想知道这个值存不存在，不关心值是多少，可以这样写 <code>_, ok := map1[key1] // 如果key1存在则ok == true，否则ok为false</code></p><p>或者和 <code>if</code> 混合使用，<code>if _, ok := map1[key1]; ok &#123;     // ... &#125; </code><br>从 <code>map1</code> 中删除元素，可以这样写 <code>delete(map1, key1)</code>，该操作即使 <code>value1</code> 已经不存在也不会报错。</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> value <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> isPresent <span class="hljs-type">bool</span><br><br>map1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>map1[<span class="hljs-string">&quot;New Delhi&quot;</span>] = <span class="hljs-number">55</span><br>map1[<span class="hljs-string">&quot;Beijing&quot;</span>] = <span class="hljs-number">20</span><br>map1[<span class="hljs-string">&quot;Washington&quot;</span>] = <span class="hljs-number">25</span><br>value, isPresent = map1[<span class="hljs-string">&quot;Beijing&quot;</span>]<br><span class="hljs-keyword">if</span> isPresent &#123;<br>fmt.Printf(<span class="hljs-string">&quot;The value of \&quot;Beijing\&quot; in map1 is: %d\n&quot;</span>, value)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;map1 does not contain Beijing&quot;</span>)<br>&#125;<br><br>value, isPresent = map1[<span class="hljs-string">&quot;Paris&quot;</span>]<br>fmt.Printf(<span class="hljs-string">&quot;Is \&quot;Paris\&quot; in map1 ?: %t\n&quot;</span>, isPresent)<br>fmt.Printf(<span class="hljs-string">&quot;Value is: %d\n&quot;</span>, value)<br><br><span class="hljs-comment">// delete an item:</span><br><span class="hljs-built_in">delete</span>(map1, <span class="hljs-string">&quot;Washington&quot;</span>)<br>value, isPresent = map1[<span class="hljs-string">&quot;Washington&quot;</span>]<br><span class="hljs-keyword">if</span> isPresent &#123;<br>fmt.Printf(<span class="hljs-string">&quot;The value of \&quot;Washington\&quot; in map1 is: %d\n&quot;</span>, value)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;map1 does not contain Washington&quot;</span>)<br>&#125;<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">The value of &quot;Beijing&quot; in map1 is: 20</span><br><span class="hljs-comment">Is &quot;Paris&quot; in map1 ?: false</span><br><span class="hljs-comment">Value is: 0</span><br><span class="hljs-comment">map1 does not contain Washington</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="for-range用法"><a href="#for-range用法" class="headerlink" title="for-range用法"></a>for-range用法</h1><p>可以用 <code>for</code> 来读取 <code>map</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> map1 &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个返回值是key，第二个返回值是value。这里需要注意的是返回的均为在循环内可用的局部变量，key为可选值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> map1 &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只想获得key，可以这样写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> map1 &#123;<br>fmt.Printf(<span class="hljs-string">&quot;key is: %d\n&quot;</span>, key)<br>&#125;<br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>map1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">float32</span>)<br>map1[<span class="hljs-number">1</span>] = <span class="hljs-number">1.0</span><br>map1[<span class="hljs-number">2</span>] = <span class="hljs-number">2.0</span><br>map1[<span class="hljs-number">3</span>] = <span class="hljs-number">3.0</span><br>map1[<span class="hljs-number">4</span>] = <span class="hljs-number">4.0</span><br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> map1 &#123;<br>fmt.Printf(<span class="hljs-string">&quot;key is: %d - value is: %f\n&quot;</span>, key, value)<br>&#125;<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">key is: 3 - value is: 3.000000</span><br><span class="hljs-comment">key is: 1 - value is: 1.000000</span><br><span class="hljs-comment">key is: 4 - value is: 4.000000</span><br><span class="hljs-comment">key is: 2 - value is: 2.000000</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这里可以看到输出并不是按照顺序的，也就是说不是按照key or value进行排列。<code>map</code> 和数据结构中的hash，python中的dict一样，拿来计数就可以了，如果为了规则索引还是去用slice吧。（这里不免想到leetcode上很多题需要用一个hash或者dict来计数，那go在做题的时候直接用map就好咯）</p><h1 id="map类型的切片"><a href="#map类型的切片" class="headerlink" title="map类型的切片"></a>map类型的切片</h1><p>假设要获取一个 <code>map</code> 类型的切片，我们必须使用两次 <code>make()</code> 函数，第一次分配切片，第二次分配切片中的每个 <code>map</code> 元素。</p><p>实例（英文注释是原本的，中文注释是我使用AI去写的）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// main函数是程序的入口，演示了两种不同的方式来初始化和修改切片中的映射</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> <span class="hljs-comment">// Version A:</span><br> <span class="hljs-comment">// 创建一个包含5个映射的切片，并初始化每个映射</span><br> items := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br> <span class="hljs-keyword">for</span> i:= <span class="hljs-keyword">range</span> items &#123;<br>  items[i] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>  items[i][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br> &#125;<br> fmt.Printf(<span class="hljs-string">&quot;Version A: Value of items: %v\n&quot;</span>, items)<br><br> <span class="hljs-comment">// Version B: NOT GOOD!</span><br> <span class="hljs-comment">// 创建一个包含5个映射的切片，尝试初始化每个映射，但这种方式是错误的</span><br> items2 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br> <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items2 &#123;<br>  item = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// item is only a copy of the slice element.</span><br>  item[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span> <span class="hljs-comment">// This &#x27;item&#x27; will be lost on the next iteration.</span><br> &#125;<br> fmt.Printf(<span class="hljs-string">&quot;Version B: Value of items: %v\n&quot;</span>, items2)<br>&#125;<br><span class="hljs-comment">/*ooutput</span><br><span class="hljs-comment">Version A: Value of items: [map[1:2] map[1:2] map[1:2] map[1:2] map[1:2]]</span><br><span class="hljs-comment">Version B: Value of items: [map[] map[] map[] map[] map[]]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这里需要注意的是，A中所得到的是切片，而B中的仅仅是对切片目标元素进行了拷贝，并没有进行初始化。</p><h1 id="map的排序"><a href="#map的排序" class="headerlink" title="map的排序"></a>map的排序</h1><p>按照 <code>map</code> 的概念来看，<code>map</code> 是无序的，所以当需要对它进行排序时我们需要将key（或value）拷贝到一个切片，再对切片进行排序（使用 <code>sort</code> 包，前一篇blog有）</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// the telephone alphabet:</span><br><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>barVal = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;alpha&quot;</span>: <span class="hljs-number">34</span>, <span class="hljs-string">&quot;bravo&quot;</span>: <span class="hljs-number">56</span>, <span class="hljs-string">&quot;charlie&quot;</span>: <span class="hljs-number">23</span>,<br><span class="hljs-string">&quot;delta&quot;</span>: <span class="hljs-number">87</span>, <span class="hljs-string">&quot;echo&quot;</span>: <span class="hljs-number">56</span>, <span class="hljs-string">&quot;foxtrot&quot;</span>: <span class="hljs-number">12</span>,<br><span class="hljs-string">&quot;golf&quot;</span>: <span class="hljs-number">34</span>, <span class="hljs-string">&quot;hotel&quot;</span>: <span class="hljs-number">16</span>, <span class="hljs-string">&quot;indio&quot;</span>: <span class="hljs-number">87</span>,<br><span class="hljs-string">&quot;juliet&quot;</span>: <span class="hljs-number">65</span>, <span class="hljs-string">&quot;kili&quot;</span>: <span class="hljs-number">43</span>, <span class="hljs-string">&quot;lima&quot;</span>: <span class="hljs-number">98</span>&#125;<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;unsorted:&quot;</span>)<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> barVal &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Key: %v, Value: %v / &quot;</span>, k, v)<br>&#125;<br>keys := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-built_in">len</span>(barVal))<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> k, _ := <span class="hljs-keyword">range</span> barVal &#123;<br>keys[i] = k<br>i++<br>&#125;<br>sort.Strings(keys)<br>fmt.Println()<br>fmt.Println(<span class="hljs-string">&quot;sorted:&quot;</span>)<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> keys &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Key: %v, Value: %v / &quot;</span>, k, barVal[k])<br>&#125;<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">unsorted:</span><br><span class="hljs-comment">Key: bravo, Value: 56 / Key: echo, Value: 56 / Key: indio, Value: 87 / Key: juliet, Value: 65 / Key: alpha, Value: 34 / Key: charlie, Value: 23 / Key: delta, Value: 87 / Key: foxtrot, Value: 12 / Key: golf, Value: 34 / Key: hotel, Value: 16 / Key: kili, Value: 43 / Key: lima, Value: 98 /</span><br><span class="hljs-comment">sorted:</span><br><span class="hljs-comment">Key: alpha, Value: 34 / Key: bravo, Value: 56 / Key: charlie, Value: 23 / Key: delta, Value: 87 / Key: echo, Value: 56 / Key: foxtrot, Value: 12 / Key: golf, Value: 34 / Key: hotel, Value: 16 / Key: indio, Value: 87 / Key: juliet, Value: 65 / Key: kili, Value: 43 / Key: lima, Value: 98 /</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>如果想要一个排序的列表，那么最好用结构体切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> name <span class="hljs-keyword">struct</span> &#123;<br>key <span class="hljs-type">string</span><br>value <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="将map的键值对调"><a href="#将map的键值对调" class="headerlink" title="将map的键值对调"></a>将map的键值对调</h1><p>这里直接通过 <code>for-range</code> 循环遍历原始映射（map），并在循环中将原本的值设置为新的键，将原本的键设置为新的值，从而实现键值对的调换。</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 原始映射</span><br>original := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br><span class="hljs-string">&quot;apple&quot;</span>:  <span class="hljs-number">1</span>,<br><span class="hljs-string">&quot;banana&quot;</span>: <span class="hljs-number">2</span>,<br><span class="hljs-string">&quot;cherry&quot;</span>: <span class="hljs-number">3</span>,<br>&#125;<br><br><span class="hljs-comment">// 创建一个新的映射来存储调换后的键值对</span><br>swapped := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br><br><span class="hljs-comment">// 遍历原始映射并调换键值</span><br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> original &#123;<br>swapped[value] = key <span class="hljs-comment">// 将原本的值作为新键，原本的键作为新值</span><br>&#125;<br><br><span class="hljs-comment">// 输出调换后的映射</span><br>fmt.Println(<span class="hljs-string">&quot;原始映射:&quot;</span>, original)<br>fmt.Println(<span class="hljs-string">&quot;调换后的映射:&quot;</span>, swapped)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>go</tag>
      
      <tag>map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go学习记录——第六天</title>
    <link href="/2024/08/14/go-study-sixth-day/"/>
    <url>/2024/08/14/go-study-sixth-day/</url>
    
    <content type="html"><![CDATA[<h1 id="For-range结构"><a href="#For-range结构" class="headerlink" title="For-range结构"></a>For-range结构</h1><p>这种构建方法可以应用于数组和切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> ix, value := <span class="hljs-keyword">range</span> slice1 &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个参数<code>ix</code>是数组或切片的索引，第二个参数<code>value</code>是该索引位置的值。他们均是仅在<code>for</code>循环内的局部变量，<code>value</code>只是<code>slice1</code>某个索引位置的值的一个拷贝，不能用来修改<code>slice1</code>该索引位置的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> slice1 []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">4</span>)<br><br>slice1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>slice1[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>slice1[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span><br>slice1[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span><br><br><span class="hljs-keyword">for</span> ix, value := <span class="hljs-keyword">range</span> slice1 &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Slice at %d is: %d\n&quot;</span>, ix, value)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">Slice at 0 is: 1</span><br><span class="hljs-comment">Slice at 1 is: 2</span><br><span class="hljs-comment">Slice at 2 is: 3</span><br><span class="hljs-comment">Slice at 3 is: 4</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>seasons := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Spring&quot;</span>, <span class="hljs-string">&quot;Summer&quot;</span>, <span class="hljs-string">&quot;Autumn&quot;</span>, <span class="hljs-string">&quot;Winter&quot;</span>&#125;<br><br><span class="hljs-keyword">for</span> ix, season := <span class="hljs-keyword">range</span> seasons &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Season %d is: %s\n&quot;</span>, ix, season)<br>&#125;<br><br><span class="hljs-keyword">var</span> season <span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> _, season = <span class="hljs-keyword">range</span> seasons &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, season)<br>&#125;<br><br><span class="hljs-keyword">for</span> ix := <span class="hljs-keyword">range</span> seasons &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, ix)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* output</span><br><span class="hljs-comment">Season 0 is: Spring</span><br><span class="hljs-comment">Season 1 is: Summer</span><br><span class="hljs-comment">Season 2 is: Autumn</span><br><span class="hljs-comment">Season 3 is: Winter</span><br><span class="hljs-comment">Spring</span><br><span class="hljs-comment">Summer</span><br><span class="hljs-comment">Autumn</span><br><span class="hljs-comment">Winter</span><br><span class="hljs-comment">0 1 2 3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>第二个例子中可以看到，使用<code>_</code>可以忽略索引。</p><p>如果只需要索引，也可以忽略第二个变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> ix := <span class="hljs-keyword">range</span> seasons &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>, ix)<br>&#125;<br><span class="hljs-comment">// Output: 0 1 2 3</span><br></code></pre></td></tr></table></figure><p>如果只需要修改<code>seasons[ix]</code>的值，也可以忽略第二个变量。</p><h2 id="多维切片下的for-range"><a href="#多维切片下的for-range" class="headerlink" title="多维切片下的for-range"></a>多维切片下的for-range</h2><p>通过计算行数和列数就可以对矩阵进行操作，和python的类似，和前面提到的多维数组一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> row := <span class="hljs-keyword">range</span> screen &#123;<br><span class="hljs-keyword">for</span> column := <span class="hljs-keyword">range</span> screen[row] &#123;<br>screen[row][column] = <span class="hljs-number">1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="切片重组（reslice）"><a href="#切片重组（reslice）" class="headerlink" title="切片重组（reslice）"></a>切片重组（reslice）</h1><p>我们首先创建一个普通的切片（比相关数组小）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">slice1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">type</span>, start_length, capacity)<br></code></pre></td></tr></table></figure><p><code>start_length</code>作为初始长度，<code>capacity</code>作为切片的容量。</p><p>然后我们就可以在切片达到容量上限后扩容，过程就是reslicing。做法就是<code>slice1 = slice1[0 : end]</code>，<code>end</code>就是新的切片的末尾索引。</p><p>将切片扩展1位可以这样做</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">sl = sl[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(sl)+<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>切片可以反复扩容操作直到占据整个数组。</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>)<br><span class="hljs-comment">// load the slice, cap(slice1) is 10:</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">cap</span>(slice1); i++ &#123;<br>slice1 = slice1[<span class="hljs-number">0</span>:i+<span class="hljs-number">1</span>]<br>slice1[i] = i<br>fmt.Printf(<span class="hljs-string">&quot;The length of slice is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1))<br>&#125;<br><br><span class="hljs-comment">// print the slice:</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice1); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Slice at %d is %d\n&quot;</span>, i, slice1[i])<br>&#125;<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">The length of slice is 1</span><br><span class="hljs-comment">The length of slice is 2</span><br><span class="hljs-comment">The length of slice is 3</span><br><span class="hljs-comment">The length of slice is 4</span><br><span class="hljs-comment">The length of slice is 5</span><br><span class="hljs-comment">The length of slice is 6</span><br><span class="hljs-comment">The length of slice is 7</span><br><span class="hljs-comment">The length of slice is 8</span><br><span class="hljs-comment">The length of slice is 9</span><br><span class="hljs-comment">The length of slice is 10</span><br><span class="hljs-comment">Slice at 0 is 0</span><br><span class="hljs-comment">Slice at 1 is 1</span><br><span class="hljs-comment">Slice at 2 is 2</span><br><span class="hljs-comment">Slice at 3 is 3</span><br><span class="hljs-comment">Slice at 4 is 4</span><br><span class="hljs-comment">Slice at 5 is 5</span><br><span class="hljs-comment">Slice at 6 is 6</span><br><span class="hljs-comment">Slice at 7 is 7</span><br><span class="hljs-comment">Slice at 8 is 8</span><br><span class="hljs-comment">Slice at 9 is 9</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>再举一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ar = [<span class="hljs-number">10</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br><span class="hljs-keyword">var</span> a = ar[<span class="hljs-number">5</span>:<span class="hljs-number">7</span>] <span class="hljs-comment">// reference to subarray &#123;5,6&#125; - len(a) is 2 and cap(a) is 5</span><br></code></pre></td></tr></table></figure><p>我们将<code>a</code>重新分片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">a = a[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>] <span class="hljs-comment">// ref of subarray &#123;5,6,7,8&#125; - len(a) is now 4 but cap(a) is still 5</span><br></code></pre></td></tr></table></figure><p>总结一下，我们对切片进行重组扩容，实际上就是重新创建一个切片，如果是用类似<code>a = a[0 :end]</code>的方式，那就是把a的引用指向了一个新的切片，原本的切片地址就被替换成了现在的切片。也就是说把原来的删了换成新的。</p><h1 id="切片的复制与追加"><a href="#切片的复制与追加" class="headerlink" title="切片的复制与追加"></a>切片的复制与追加</h1><p>如果想增加切片的容量，我们可以创建一个新的更大的切片并把原来的分片内容都拷贝过来。</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slFrom := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>slTo := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><br>n := <span class="hljs-built_in">copy</span>(slTo, slFrom)<br>fmt.Println(slTo)                    <span class="hljs-comment">// output: [1 2 3 0 0 0 0 0 0 0]</span><br>fmt.Printf(<span class="hljs-string">&quot;Copied %d elements\n&quot;</span>, n) <span class="hljs-comment">// n == 3</span><br><br>sl3 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>sl3 = <span class="hljs-built_in">append</span>(sl3, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>fmt.Println(sl3) <span class="hljs-comment">// output: [1 2 3 4 5 6]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个实例中我们使用了<code>copy</code>来拷贝切片，用<code>append</code>来向切片追加新的元素。</p><p><code>func append(s[]T, x ...T)[]T</code>，其中<code>append()</code>方法将0个或多个具有相同类型的<code>s</code>的元素追加到切片后面并返回新的切片；追加的元素必须和原本切片的元素类型相同。如果<code>s</code>的容量不足以存储新增元素，<code>append()</code>会分配新的切片来保证已有切片元素和新增元素的存储。在分配后切片的指针、长度和容量都会被更新。</p><p>如果向追加切片<code>y</code>到切片<code>x</code>的后面，我们只需要将第二个参数扩展为一个列表即可。</p><p>通常情况下<code>append()</code>是很好用的，但我们如果想掌握整个追加过程，我们就可以使用<code>AppendByte()</code>方法。</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AppendByte</span><span class="hljs-params">(slice []<span class="hljs-type">byte</span>, data ...<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>m := <span class="hljs-built_in">len</span>(slice)<br>n := m + <span class="hljs-built_in">len</span>(data)<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-built_in">cap</span>(slice) &#123; <span class="hljs-comment">// if necessary, reallocate</span><br><span class="hljs-comment">// allocate double what&#x27;s needed, for future growth.</span><br>newSlice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, (n+<span class="hljs-number">1</span>)*<span class="hljs-number">2</span>)<br><span class="hljs-built_in">copy</span>(newSlice, slice)<br>slice = newSlice<br>&#125;<br>slice = slice[<span class="hljs-number">0</span>:n]<br><span class="hljs-built_in">copy</span>(slice[m:n], data)<br><span class="hljs-keyword">return</span> slice<br>&#125;<br></code></pre></td></tr></table></figure><p><code>func copy(dst, src []T) int</code>方法将类型为<code>T</code>的切片源地址<code>src</code>拷贝到目标地址<code>dst</code>，覆盖<code>dst</code>的相关元素，并返回拷贝元素的个数。源地址可能和目标地址有重叠，拷贝个数就是<code>src</code>和<code>dst</code>长度的最小值。如果<code>src</code>是字符串类型，那么元素类型就是<code>byte</code>。如果想继续使用<code>src</code>就可以在拷贝执行后再使用<code>src = dst</code>。</p><p>由于这部分内容用的多，写几个练习（我自己写完后对照了一下，然后直接把答案贴上来了）。</p><p>练习1：<br>给定一个切片 <code>s []int</code> 和一个 <code>int</code> 类型的因子 <code>factor</code>，扩展 <code>s</code> 使其长度为 <code>len(s) * factor</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;The length of s before enlarging is:&quot;</span>, <span class="hljs-built_in">len</span>(s))<br>fmt.Println(s)<br>s = enlarge(s, <span class="hljs-number">5</span>)<br>fmt.Println(<span class="hljs-string">&quot;The length of s after enlarging is:&quot;</span>, <span class="hljs-built_in">len</span>(s))<br>fmt.Println(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">enlarge</span><span class="hljs-params">(s []<span class="hljs-type">int</span>, factor <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>ns := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(s)*factor)<br><span class="hljs-comment">// fmt.Println(&quot;The length of ns  is:&quot;, len(ns))</span><br><span class="hljs-built_in">copy</span>(ns, s)<br><span class="hljs-comment">//fmt.Println(ns)</span><br>s = ns<br><span class="hljs-comment">//fmt.Println(s)</span><br><span class="hljs-comment">//fmt.Println(&quot;The length of s after enlarging is:&quot;, len(s))</span><br><span class="hljs-keyword">return</span> s<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">The length of s before enlarging is: 3</span><br><span class="hljs-comment">[1 2 3]</span><br><span class="hljs-comment">The length of s after enlarging is: 15</span><br><span class="hljs-comment">[1 2 3 0 0 0 0 0 0]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>练习2：<br>用顺序函数过滤容器：<code>s</code> 是前 10 个整型的切片。构造一个函数 <code>Filter</code>，第一个参数是 <code>s</code>，第二个参数是一个 <code>fn func(int) bool</code>，返回满足函数 <code>fn</code> 的元素切片。通过 <code>fn</code> 测试方法测试当整型值是偶数时的情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// filter_slice.go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br>s = Filter(s, even)<br>fmt.Println(s)<br>&#125;<br><br><span class="hljs-comment">// Filter returns a new slice holding only</span><br><span class="hljs-comment">// the elements of s that satisfy f()</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Filter</span><span class="hljs-params">(s []<span class="hljs-type">int</span>, fn <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>) []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> p []<span class="hljs-type">int</span> <span class="hljs-comment">// == nil</span><br><span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">if</span> fn(i) &#123;<br>p = <span class="hljs-built_in">append</span>(p, i)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">even</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">/* [0 2 4 6 8] */</span><br></code></pre></td></tr></table></figure><p>练习3：<br>写一个函数 <code>InsertStringSlice()</code> 将切片插入到另一个切片的指定位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// insert_slice.go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>, <span class="hljs-string">&quot;O&quot;</span>, <span class="hljs-string">&quot;P&quot;</span>, <span class="hljs-string">&quot;Q&quot;</span>, <span class="hljs-string">&quot;R&quot;</span>&#125;<br>in := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;<br>res := InsertStringSlice(s, in, <span class="hljs-number">0</span>) <span class="hljs-comment">// at the front</span><br>fmt.Println(res)                   <span class="hljs-comment">// [A B C M N O P Q R]</span><br>res = InsertStringSlice(s, in, <span class="hljs-number">3</span>)  <br>fmt.Println(res)                   <span class="hljs-comment">// [M N O A B C P Q R]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InsertStringSlice</span><span class="hljs-params">(slice, insertion []<span class="hljs-type">string</span>, index <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-built_in">len</span>(slice)+<span class="hljs-built_in">len</span>(insertion))<br>at := <span class="hljs-built_in">copy</span>(result, slice[:index])<br>at += <span class="hljs-built_in">copy</span>(result[at:], insertion)<br><span class="hljs-built_in">copy</span>(result[at:], slice[index:])<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>练习4：<br>写一个函数 <code>RemoveStringSlice()</code> 将从 <code>start</code> 到 <code>end</code> 索引的元素从切片中移除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// remove_slice.go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>, <span class="hljs-string">&quot;O&quot;</span>, <span class="hljs-string">&quot;P&quot;</span>, <span class="hljs-string">&quot;Q&quot;</span>, <span class="hljs-string">&quot;R&quot;</span>&#125;<br>res := RemoveStringSlice(s, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br>fmt.Println(res) <span class="hljs-comment">// [M N Q R]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RemoveStringSlice</span><span class="hljs-params">(slice []<span class="hljs-type">string</span>, start, end <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-built_in">len</span>(slice)-(end-start))<br>at := <span class="hljs-built_in">copy</span>(result, slice[:start])<br><span class="hljs-built_in">copy</span>(result[at:], slice[end:])<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="字符串、数组和切片的应用"><a href="#字符串、数组和切片的应用" class="headerlink" title="字符串、数组和切片的应用"></a>字符串、数组和切片的应用</h1><h2 id="从字符串生成字节切片"><a href="#从字符串生成字节切片" class="headerlink" title="从字符串生成字节切片"></a>从字符串生成字节切片</h2><p>假设<code>s</code>是一个字符串（本质上是一个不可变的字节数组），那么可以直接通过<code>c := []byte(s)</code>来获取一个字节的切片。另外还可以通过<code>copy()</code>函数来达到相同的目的<code>copy(dst []byte, src string)</code></p><p>同样也可以使用for-range来获取每个元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    s := <span class="hljs-string">&quot;\u00ff\u754c&quot;</span><br>    <span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> s &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%d:%c &quot;</span>, i, c)<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">0:ÿ 2:界</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这里涉及到了Unicode字符，Unicode字符会占两个字节甚至3个或4个字节。如果发现错误的UTF8字符，将会被设置为<code>U+FFFD</code>并且索引会前移一位。和字符串转换一样，可以用<code>c := []int32(s)</code>语法，这样切片中每个<code>int</code>都会包含在对应的Unicode字符中，因为字符中的每个字符都对应一个整数，所以我们也可以将字符串转换为元素类型为<code>rune</code>的切片 <code>r := []rune(s)</code>。</p><p>可以通过<code>len([]int32(s))</code>来获取字符串字符的数量，但使用<code>utf8.RunCountInString(s)</code>效率会更高</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;unicode/utf8&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// count number of characters:</span><br>str1 := <span class="hljs-string">&quot;asSASA ddd dsjkdsjs dk&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;The number of bytes in string str1 is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(str1))<br>fmt.Printf(<span class="hljs-string">&quot;The number of characters in string str1 is %d\n&quot;</span>, utf8.RuneCountInString(str1))<br>str2 := <span class="hljs-string">&quot;asSASA ddd dsjkdsjsこん dk&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;The number of bytes in string str2 is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(str2))<br>fmt.Printf(<span class="hljs-string">&quot;The number of characters in string str2 is %d&quot;</span>, utf8.RuneCountInString(str2))<br>&#125;<br><br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">The number of bytes in string str1 is 22</span><br><span class="hljs-comment">The number of characters in string str1 is 22</span><br><span class="hljs-comment">The number of bytes in string str2 is 28</span><br><span class="hljs-comment">The number of characters in string str2 is 24</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>还可以将一个字符串追加到某个字节切片的后面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b []<span class="hljs-type">byte</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br>b = <span class="hljs-built_in">append</span>(b, s...)<br></code></pre></td></tr></table></figure><h2 id="获取字符串的某一部分"><a href="#获取字符串的某一部分" class="headerlink" title="获取字符串的某一部分"></a>获取字符串的某一部分</h2><p>使用<code>substr := str[start : end]</code>可以从字符串<code>str</code>获取从索引<code>start</code>到<code>end - 1</code>的子字符串。</p><h2 id="字符串和切片的内存结构"><a href="#字符串和切片的内存结构" class="headerlink" title="字符串和切片的内存结构"></a>字符串和切片的内存结构</h2><p>在内存中，一个字符串实际上是双字结构，即一个指向实际数据的指针一个记录字符串长度的整数。因为指针对用户来说不可见，所以依旧可以把字符串看作一个值类型。</p><figure>  <img src="/2024/08/14/go-study-sixth-day/7_6_1.png" class="" title="7.6.1">  <figcaption>7.6.1</figcaption></figure><h2 id="修改字符串中的某个字符"><a href="#修改字符串中的某个字符" class="headerlink" title="修改字符串中的某个字符"></a>修改字符串中的某个字符</h2><p>xxxxxxxxxx26 1package main2​3import (4    “fmt”5)6​7func main() {8    &#x2F;&#x2F; 原始映射9    original :&#x3D; map[string]int{10        “apple”:  1,11        “banana”: 2,12        “cherry”: 3,13    }14​15    &#x2F;&#x2F; 创建一个新的映射来存储调换后的键值对16    swapped :&#x3D; make(map[int]string)17​18    &#x2F;&#x2F; 遍历原始映射并调换键值19    for key, value :&#x3D; range original {20        swapped[value] &#x3D; key &#x2F;&#x2F; 将原本的值作为新键，原本的键作为新值21    }22​23    &#x2F;&#x2F; 输出调换后的映射24    fmt.Println(“原始映射:”, original)25    fmt.Println(“调换后的映射:”, swapped)26}go</p><p>因此我们需要将字符串换成字节数组，然后再去修改数组中的元素值，最后再将数组转换为字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;hello&quot;</span><br>c := []<span class="hljs-type">byte</span>(s)<br>c[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;c&#x27;</span><br>s2 := <span class="hljs-type">string</span>(c) <span class="hljs-comment">// s2 == &quot;cello&quot;</span><br></code></pre></td></tr></table></figure><h2 id="字节数组对比函数"><a href="#字节数组对比函数" class="headerlink" title="字节数组对比函数"></a>字节数组对比函数</h2><p><code>Compare()</code> 函数会返回两个字节数组字典顺序的整数对比结果，即<br><code>0 if a == b, -1 if a &lt; b, 1 if a &gt; b</code></p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Compare</span><span class="hljs-params">(a, b[]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(a) &amp;&amp; i &lt; <span class="hljs-built_in">len</span>(b); i++ &#123;<br>        <span class="hljs-keyword">switch</span> &#123;<br>        <span class="hljs-keyword">case</span> a[i] &gt; b[i]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">case</span> a[i] &lt; b[i]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 数组的长度可能不同</span><br>    <span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">len</span>(a) &lt; <span class="hljs-built_in">len</span>(b):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">len</span>(a) &gt; <span class="hljs-built_in">len</span>(b):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 数组相等</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="搜索及排序切片和数组"><a href="#搜索及排序切片和数组" class="headerlink" title="搜索及排序切片和数组"></a>搜索及排序切片和数组</h2><p>标准库中提供了 <code>sort</code> 包来实现常见的搜索和排序操作。（python中sorted万能函数🤣，leetcode只要遇到需要排序的写了就完事，根本不用自己去写排序算法）</p><table><thead><tr><th>sort&#x2F;search</th><th>example</th></tr></thead><tbody><tr><td>func Ints(a []int)</td><td>sort.Ints(arri)</td></tr><tr><td>func Float64s(a []float64)</td><td>sort.Float64s(arrf)</td></tr><tr><td>func Strings(a []string)</td><td>sort.Strings(arrs)</td></tr><tr><td>func Slice(slice interface{}, less func(i, j int) bool)</td><td>sort.Slice(arr, func(i, j int) bool { return arr[i] &lt; arr[j] })</td></tr><tr><td>func SearchInts(a []int, x int)</td><td>sort.SearchInts(arr, x)</td></tr><tr><td>func SearchFloat64s(a []float64, x float64)</td><td>sort.SearchFloat64s(arr, x)</td></tr><tr><td>func SearchStrings(a []string, x string)</td><td>sort.SearchStrings(arr, x)</td></tr></tbody></table><p>这里我们需要注意，想要搜索一个元素，数组或切片必须先进行排序（标准库中默认为二分排序）</p><h2 id="append-函数常见操作"><a href="#append-函数常见操作" class="headerlink" title="append()函数常见操作"></a>append()函数常见操作</h2><table><thead><tr><th>append()函数常见操作</th><th>example</th></tr></thead><tbody><tr><td>切片b追加到切片a的后面</td><td>a &#x3D; append(a, b…)</td></tr><tr><td>复制切片a的元素到新的切片b上</td><td>b &#x3D; make([]T, len(a)); copy(b, a)</td></tr><tr><td>删除位于索引i位置的元素</td><td>a &#x3D; append(a[:i], a[i+1:]…)</td></tr><tr><td>切除切片 a 中从索引 i 至 j 位置的元素</td><td>a &#x3D; append(a[:i], a[j:]…)</td></tr><tr><td>为切片 a 扩展 j 个元素长度</td><td>a &#x3D; append(a, make([]T, j)…)</td></tr><tr><td>在索引 i 的位置插入元素 x</td><td>a &#x3D; append(a[:i], append([]T{x}, a[i:]…)…)</td></tr><tr><td>在索引 i 的位置插入长度为 j 的新切片</td><td>a &#x3D; append(a[:i], append(make([]T, j), a[i:]…)…)</td></tr><tr><td>在索引 i 的位置插入切片 b 的所有元素</td><td>a &#x3D; append(a[:i], append(b, a[i:]…)…)</td></tr><tr><td>取出位于切片 a 最末尾的元素 x</td><td>x, a &#x3D; a[len(a)-1], a[:len(a)-1]</td></tr><tr><td>将元素 x 追加到切片 a</td><td>a &#x3D; append(a, x)</td></tr></tbody></table><p>这边书上推荐了三个能够实现更完整的操作的三个包，我也附上链接（也方便我自己后续去学）<a href="http://github.com/feyeleanor/slices">Slices</a>, <a href="http://github.com/feyeleanor/chain">chain</a>, <a href="http://github.com/feyeleanor/lists">lists</a></p><p>这里再次感谢原书作者 Ivo Balbaert 和中译本的各位老师，以及三个包的开发者 Eleanor McHugh。</p><h2 id="切片和垃圾回收"><a href="#切片和垃圾回收" class="headerlink" title="切片和垃圾回收"></a>切片和垃圾回收</h2><p>切片的底层指向一个数组，该数组的实际容量可能要大于切片所定义的容量，只有在没有任何切片指向的时候，底层的数组内存才会被释放，这种特性会导致程序产生多余的内存消耗。</p><p>实例（函数FindDigits将一个文件加载到内存，然后搜索其中的数字并返回一个切片）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> digitRegexp = regexp.MustCompile(<span class="hljs-string">&quot;[0-9]+&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindDigits</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>    b, _ := ioutil.ReadFile(filename)<br>    <span class="hljs-keyword">return</span> digitRegexp.Find(b)<br>&#125;<br></code></pre></td></tr></table></figure><p>代码可以正常运行，但返回的 <code>[]byte</code> 指向的底层是整个文件的数据。只要该返回的切片不被释放，垃圾回收就不能释放整个文件占据的内存。（这句话看到就想到了之前在不知道哪个论坛看到的一个例子，那个例子中程序运行过程中内存会被完全使用，也就是说即使只调用一个功能也会将整个内存拉取，造成大量的内存浪费，大致内容是这样。但我自己感觉和这个有点类似，都会造成内存浪费，拖慢运行速度。）</p><p>避免这个问题可以通过将需要的部分拷贝到一个新的切片再调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindDigits</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>   b, _ := ioutil.ReadFile(filename)<br>   b = digitRegexp.Find(b)<br>   c := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(b))<br>   <span class="hljs-built_in">copy</span>(c, b)<br>   <span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个只找到了第一个匹配正则表达式的字符串，要找到全部的用下面这个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindFileDigits</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>   fileBytes, _ := ioutil.ReadFile(filename)<br>   b := digitRegexp.FindAll(fileBytes, <span class="hljs-built_in">len</span>(fileBytes))<br>   c := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>)<br>   <span class="hljs-keyword">for</span> _, bytes := <span class="hljs-keyword">range</span> b &#123;<br>      c = <span class="hljs-built_in">append</span>(c, bytes...)<br>   &#125;<br>   <span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>go</tag>
      
      <tag>切片</tag>
      
      <tag>For-range结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go学习记录——第五天</title>
    <link href="/2024/08/13/go-study-fifth-day/"/>
    <url>/2024/08/13/go-study-fifth-day/</url>
    
    <content type="html"><![CDATA[<p>这篇不算完全的记录，要补充一下基本数据结构中关于字符串的包和切片部分的包，顺便补全一下之前说的转义字符和格式化占位符表格。</p><h1 id="strings和strcov包"><a href="#strings和strcov包" class="headerlink" title="strings和strcov包"></a>strings和strcov包</h1><h2 id="前缀和后缀"><a href="#前缀和后缀" class="headerlink" title="前缀和后缀"></a>前缀和后缀</h2><p><code>HasPrefix()</code>和<code>Hassuffix()</code>用于判断字符串<code>s</code>是否以<code>prefix</code>开头或者以<code>suffix</code>结尾。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.HasPrefix(s, prefix <span class="hljs-type">string</span>) <span class="hljs-type">bool</span><br>strings.HasSuffix(s, suffix <span class="hljs-type">string</span>) <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span> = <span class="hljs-string">&quot;This is an example of a string&quot;</span><br><br>fmt.Printf(<span class="hljs-string">&quot;T/F? Does the string \&quot;%s\&quot; have prefix %s? &quot;</span>, str, <span class="hljs-string">&quot;Th&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%t\n&quot;</span>, strings.HasPrefix(str, <span class="hljs-string">&quot;Th&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">// Output: T/F? Does the string &quot;This is an example of a string&quot; have prefix Th? true</span><br></code></pre></td></tr></table></figure><h2 id="字符串包含关系"><a href="#字符串包含关系" class="headerlink" title="字符串包含关系"></a>字符串包含关系</h2><p><code>Contains()</code>判断字符串<code>s</code>是否包含<code>substr</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Contains(s, substr <span class="hljs-type">string</span>) <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><h2 id="判断子字符串或字符在父字符串中出现的位置（索引）"><a href="#判断子字符串或字符在父字符串中出现的位置（索引）" class="headerlink" title="判断子字符串或字符在父字符串中出现的位置（索引）"></a>判断子字符串或字符在父字符串中出现的位置（索引）</h2><p><code>Index()</code>返回字符串<code>str</code>在字符串<code>s</code>中的索引（<code>str</code>的第一个字符的索引），<code>-1</code>表示字符串<code>s</code>不包含字符串<code>str</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Index(s, str <span class="hljs-type">string</span>) <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p><code>LastIndex()</code>返回字符串<code>str</code>在字符串<code>s</code>中最后出现位置的（<code>str</code>的第一个字符的索引），<code>-1</code>表示字符串<code>s</code>不包含字符串<code>str</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.LastIndex(s, str <span class="hljs-type">string</span>) <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>如果要查询非ASCII编码的字符在父字符串中的位置，用<code>IndexRune()</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.IndexRune(s <span class="hljs-type">string</span>, r <span class="hljs-type">rune</span>) <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>在最新版的Go中定义为<code>func IndexRune(s string, r rune) int</code></li><li>实际使用中的第二个参数<code>rune</code>可以是<code>rune</code>或<code>int</code>，例如<code>strings.IndexRune(&quot;chicken&quot;, 99)</code> 或 <code>strings.IndexRune(&quot;chicken&quot;, rune(&#39;k&#39;))</code></li></ul><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Hi, I&#x27;m Marc, Hi.&quot;</span><br><br>fmt.Printf(<span class="hljs-string">&quot;The position of \&quot;Marc\&quot; is: &quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, strings.Index(str, <span class="hljs-string">&quot;Marc&quot;</span>))<br><br>fmt.Printf(<span class="hljs-string">&quot;The position of the first instance of \&quot;Hi\&quot; is: &quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, strings.Index(str, <span class="hljs-string">&quot;Hi&quot;</span>))<br>fmt.Printf(<span class="hljs-string">&quot;The position of the last instance of \&quot;Hi\&quot; is: &quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, strings.LastIndex(str, <span class="hljs-string">&quot;Hi&quot;</span>))<br><br>fmt.Printf(<span class="hljs-string">&quot;The position of \&quot;Burger\&quot; is: &quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, strings.Index(str, <span class="hljs-string">&quot;Burger&quot;</span>))<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">The position of &quot;Marc&quot; is: 8</span><br><span class="hljs-comment">The position of the first instance of &quot;Hi&quot; is: 0</span><br><span class="hljs-comment">The position of the last instance of &quot;Hi&quot; is: 14</span><br><span class="hljs-comment">The position of &quot;Burger&quot; is: -1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p><code>Replace()</code>用于将字符串<code>s</code>中的前<code>n</code>个字符串<code>old</code>替换为字符串<code>new</code>，并返回一个新的字符串，如果<code>n = -1</code>则替换掉所有字符串<code>old</code>为<code>new</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Replace(str, old, <span class="hljs-built_in">new</span> <span class="hljs-type">string</span>, n <span class="hljs-type">int</span>) <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><h2 id="统计字符串出现次数"><a href="#统计字符串出现次数" class="headerlink" title="统计字符串出现次数"></a>统计字符串出现次数</h2><p><code>Count()</code>用于统计字符串<code>str</code>中字符串<code>s</code>出现的次数（非重叠）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Count(s, str <span class="hljs-type">string</span>) <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Hello, how is it going, Hugo?&quot;</span><br><span class="hljs-keyword">var</span> manyG = <span class="hljs-string">&quot;gggggggggg&quot;</span><br><br>fmt.Printf(<span class="hljs-string">&quot;Number of H&#x27;s in %s is: &quot;</span>, str)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, strings.Count(str, <span class="hljs-string">&quot;H&quot;</span>))<br><br>fmt.Printf(<span class="hljs-string">&quot;Number of double g&#x27;s in %s is: &quot;</span>, manyG)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, strings.Count(manyG, <span class="hljs-string">&quot;gg&quot;</span>))<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">Number of H&#x27;s in Hello, how is it going, Hugo? is: 2</span><br><span class="hljs-comment">Number of double g’s in gggggggggg is: 5</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="重复字符串"><a href="#重复字符串" class="headerlink" title="重复字符串"></a>重复字符串</h2><p><code>Repeat()</code>用于将字符串<code>str</code>重复<code>n</code>次，返回一个新的字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Repeat(s, n <span class="hljs-type">int</span>) <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> origS <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Hi there! &quot;</span><br><span class="hljs-keyword">var</span> newS <span class="hljs-type">string</span><br><br>newS = strings.Repeat(origS, <span class="hljs-number">3</span>)<br>fmt.Printf(<span class="hljs-string">&quot;The new repeated string is: %s\n&quot;</span>, newS)<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">The new repeated string is: Hi there! Hi there! Hi there!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="修改字符串的大小写"><a href="#修改字符串的大小写" class="headerlink" title="修改字符串的大小写"></a>修改字符串的大小写</h2><p><code>ToLower()</code>和<code>ToUpper()</code>用于将字符串<code>s</code>中的所有字符转为小写或大写。和python的一样，就多了个<code>To</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.ToLower(s) <span class="hljs-type">string</span><br>strings.ToUpper(s) <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> orig <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Hey, how are you George?&quot;</span><br><span class="hljs-keyword">var</span> lower <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> upper <span class="hljs-type">string</span><br><br>fmt.Printf(<span class="hljs-string">&quot;The original string is: %s\n&quot;</span>, orig)<br>lower = strings.ToLower(orig)<br>fmt.Printf(<span class="hljs-string">&quot;The lowercase string is: %s\n&quot;</span>, lower)<br>upper = strings.ToUpper(orig)<br>fmt.Printf(<span class="hljs-string">&quot;The uppercase string is: %s\n&quot;</span>, upper)<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">The original string is: Hey, how are you George?</span><br><span class="hljs-comment">The lowercase string is: hey, how are you george?</span><br><span class="hljs-comment">The uppercase string is: HEY, HOW ARE YOU GEORGE?</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="修剪字符串"><a href="#修剪字符串" class="headerlink" title="修剪字符串"></a>修剪字符串</h2><p><code>strings.TrimSpace(s)</code>剔除字符串开头和结尾的空白符号<br><code>strings.Trim(s, &quot;cut&quot;)</code>剔除开头和结尾的指定字符，<code>cut</code>参数可以是任意字符<br><code>strings.TrimLeft()</code>或<code>string.TrimRight()</code>可以剔除开头或结尾的字符</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 示例字符串</span><br>    str1 := <span class="hljs-string">&quot;   Hello, World!   &quot;</span><br>    str2 := <span class="hljs-string">&quot;!!!Hello, World!!!&quot;</span><br>    <br>    <span class="hljs-comment">// 使用 TrimSpace 去除开头和结尾的空白符号</span><br>    trimmedSpace := strings.TrimSpace(str1)<br>    fmt.Println(<span class="hljs-string">&quot;使用 TrimSpace 去除空白符号:&quot;</span>, trimmedSpace) <span class="hljs-comment">// 输出: &quot;Hello, World!&quot;</span><br>    <br>    <span class="hljs-comment">// 使用 Trim 去除开头和结尾的指定字符</span><br>    trimmedCut := strings.Trim(str2, <span class="hljs-string">&quot;!&quot;</span>)<br>    fmt.Println(<span class="hljs-string">&quot;使用 Trim 去除指定字符:&quot;</span>, trimmedCut) <span class="hljs-comment">// 输出: &quot;Hello, World&quot;</span><br>    <br>    <span class="hljs-comment">// 使用 TrimLeft 去除开头的指定字符</span><br>    trimmedLeft := strings.TrimLeft(str2, <span class="hljs-string">&quot;!&quot;</span>)<br>    fmt.Println(<span class="hljs-string">&quot;使用 TrimLeft 去除开头的指定字符:&quot;</span>, trimmedLeft) <span class="hljs-comment">// 输出: &quot;Hello, World!!!&quot;</span><br>    <br>    <span class="hljs-comment">// 使用 TrimRight 去除结尾的指定字符</span><br>    trimmedRight := strings.TrimRight(str2, <span class="hljs-string">&quot;!&quot;</span>)<br>    fmt.Println(<span class="hljs-string">&quot;使用 TrimRight 去除结尾的指定字符:&quot;</span>, trimmedRight) <span class="hljs-comment">// 输出: &quot;!!!Hello, World&quot;</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">使用 TrimSpace 去除空白符号: Hello, World!</span><br><span class="hljs-comment">使用 Trim 去除指定字符: Hello, World</span><br><span class="hljs-comment">使用 TrimLeft 去除开头的指定字符: Hello, World!!!</span><br><span class="hljs-comment">使用 TrimRight 去除结尾的指定字符: !!!Hello, World</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h2><p><code>strings.Fields(s)</code>将会利用1个或多个空白符号来作为动态长度的分隔符将字符串分割成若干小块，并返回一个slice，如果字符串只包含空白符，则返回一个长度为0的slice。</p><p><code>strings.Split(s, sep)</code>用自定义符号去对指定字符串进行分割，并返回slice。</p><p>这里的split和python的差不多，一个字符串在内一个字符串在外</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 使用 strings.Split 按指定分隔符分割字符串</span><br>    str1 := <span class="hljs-string">&quot;apple,banana,cherry&quot;</span><br>    splitResult := strings.Split(str1, <span class="hljs-string">&quot;,&quot;</span>)<br>    fmt.Println(<span class="hljs-string">&quot;使用 strings.Split 结果:&quot;</span>, splitResult) <span class="hljs-comment">// 输出: [apple banana cherry]</span><br><br>    <span class="hljs-comment">// 使用 strings.Fields 按空白字符分割字符串</span><br>    str2 := <span class="hljs-string">&quot;  Hello,   World!  This is Go.  &quot;</span><br>    fieldsResult := strings.Fields(str2)<br>    fmt.Println(<span class="hljs-string">&quot;使用 strings.Fields 结果:&quot;</span>, fieldsResult) <span class="hljs-comment">// 输出: [Hello, World! This is Go.]</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">使用 strings.Split 结果: [apple banana cherry]</span><br><span class="hljs-comment">使用 strings.Fields 结果: [Hello, World! This is Go.]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="拼接slice到字符串"><a href="#拼接slice到字符串" class="headerlink" title="拼接slice到字符串"></a>拼接slice到字符串</h2><p><code>Join()</code>用于将元素类型为<code>string</code>的<code>slice</code>使用分隔符来拼接成一个字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Join(sl []<span class="hljs-type">string</span>, sep <span class="hljs-type">string</span>) <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;The quick brown fox jumps over the lazy dog&quot;</span><br>sl := strings.Fields(str)<br>fmt.Printf(<span class="hljs-string">&quot;Splitted in slice: %v\n&quot;</span>, sl)<br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> sl &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s - &quot;</span>, val)<br>&#125;<br>fmt.Println()<br>str2 := <span class="hljs-string">&quot;GO1|The ABC of Go|25&quot;</span><br>sl2 := strings.Split(str2, <span class="hljs-string">&quot;|&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;Splitted in slice: %v\n&quot;</span>, sl2)<br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> sl2 &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s - &quot;</span>, val)<br>&#125;<br>fmt.Println()<br>str3 := strings.Join(sl2,<span class="hljs-string">&quot;;&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;sl2 joined by ;: %s\n&quot;</span>, str3)<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">Splitted in slice: [The quick brown fox jumps over the lazy dog]</span><br><span class="hljs-comment">The - quick - brown - fox - jumps - over - the - lazy - dog -</span><br><span class="hljs-comment">Splitted in slice: [GO1 The ABC of Go 25]</span><br><span class="hljs-comment">GO1 - The ABC of Go - 25 -</span><br><span class="hljs-comment">sl2 joined by ;: GO1;The ABC of Go;25</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="从字符串中读取内容"><a href="#从字符串中读取内容" class="headerlink" title="从字符串中读取内容"></a>从字符串中读取内容</h2><p><code>strings.NewReader(str)</code>用于生成一个<code>Reader</code>并读取字符串中的内容，然后返回指向这个<code>Reader</code>的指针。</p><p><code>Read()</code>从<code>[]byte</code>读取内容</p><p><code>ReadByte()</code>和<code>ReadRune()</code>从字符串中读取下一个<code>byte</code> or <code>rune</code></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>通过<code>strconv</code>包实现</p><p>数字型转字符串型<br><code>strconv.Itoa(i int) string</code> 返回数字 <code>i</code> 所表示的字符串类型的十进制数。</p><p><code>strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string</code> 将 64 位浮点型的数字转换为字符串，其中 <code>fmt</code> 表示格式（其值可以是 <code>&#39;b&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;f&#39;</code> 或 <code>&#39;g&#39;</code>），<code>prec</code> 表示精度，<code>bitSize</code> 则使用 <code>32</code> 表示 <code>float32</code>，用 <code>64</code> 表示 <code>float64</code>。</p><p>字符串型转数字型</p><p><code>strconv.Atoi(s string) (i int, err error)</code> 将字符串转换为 <code>int</code> 型。</p><p><code>strconv.ParseFloat(s string, bitSize int) (f float64, err error)</code> 将字符串转换为 <code>float64</code> 型。</p><h1 id="bytes包"><a href="#bytes包" class="headerlink" title="bytes包"></a>bytes包</h1><p>类型 <code>[]byte</code> 的切片十分常见，包 <code>btyes</code>就用来提供这种类型的操作方法。同时包里还包含一个 <code>Buffer</code> 类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;bytes&quot;</span><br><br><span class="hljs-keyword">type</span> Buffer <span class="hljs-keyword">struct</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>首先 <code>buffer</code> 是长度可变的 <code>btyes</code> ，提供了 <code>Read()</code> and <code>Write()</code> 方法，读写位置长度的 <code>bytes</code> 最好使用 <code>buffer</code></p><p><code>Buffer</code> 的定义是 <code>var buffer bytes.Buffer</code></p><p>或使用函数 <code>func NewBuffer(buf []byte) *Buffer</code>，创建一个 <code>buffer</code> 对象并且初始化好 <code>buf</code>； <code>NewBuffer</code> 最好在从 <code>buf</code> 读取时使用。</p><h2 id="通过buffer串联字符串"><a href="#通过buffer串联字符串" class="headerlink" title="通过buffer串联字符串"></a>通过buffer串联字符串</h2><p>实例</p><p>创建一个 <code>buffer</code>，通过 <code>buffer.WriteString(s)</code> 方法将字符串 <code>s</code> 追加到后面，最后再通过 <code>buffer.String() </code>方法转换为 <code>string</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> buffer bytes.Buffer<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> s, ok := getNextString(); ok &#123; <span class="hljs-comment">//method getNextString() not shown here</span><br>buffer.WriteString(s)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>fmt.Print(buffer.String(), <span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><table><thead><tr><th>转义字符</th><th>说明</th></tr></thead><tbody><tr><td><code>\a</code></td><td>响铃（警报）</td></tr><tr><td><code>\b</code></td><td>退格</td></tr><tr><td><code>\f</code></td><td>换页</td></tr><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\r</code></td><td>回车</td></tr><tr><td><code>\t</code></td><td>制表符</td></tr><tr><td><code>\v</code></td><td>垂直制表符</td></tr><tr><td><code>\\</code></td><td>反斜杠</td></tr><tr><td><code>\&#39;</code></td><td>单引号</td></tr><tr><td><code>\&quot;</code></td><td>双引号</td></tr><tr><td><code>\?</code></td><td>问号</td></tr><tr><td><code>\0</code></td><td>空字符（Null 字符）</td></tr><tr><td><code>\xhh</code></td><td>十六进制表示的 ASCII 字符</td></tr><tr><td><code>\uhhhh</code></td><td>Unicode 字符，表示为 16 位的十六进制</td></tr><tr><td><code>\Uhhhhhhhh</code></td><td>Unicode 字符，表示为 32 位的十六进制</td></tr></tbody></table><h1 id="格式化占位符"><a href="#格式化占位符" class="headerlink" title="格式化占位符"></a>格式化占位符</h1><table><thead><tr><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td><code>%d</code></td><td>十进制整数</td></tr><tr><td><code>%b</code></td><td>二进制整数</td></tr><tr><td><code>%o</code></td><td>八进制整数</td></tr><tr><td><code>%x</code></td><td>十六进制小写字母</td></tr><tr><td><code>%X</code></td><td>十六进制大写字母</td></tr><tr><td><code>%f</code></td><td>浮点数（默认六位小数）</td></tr><tr><td><code>%e</code></td><td>浮点数（科学计数法）</td></tr><tr><td><code>%E</code></td><td>浮点数（科学计数法，大写E）</td></tr><tr><td><code>%g</code></td><td>浮点数（以最简洁形式输出）</td></tr><tr><td><code>%G</code></td><td>浮点数（以最简洁形式输出，大写E）</td></tr><tr><td><code>%s</code></td><td>字符串</td></tr><tr><td><code>%q</code></td><td>字符串（双引号括起来，转义字符）</td></tr><tr><td><code>%c</code></td><td>Unicode 字符</td></tr><tr><td><code>%p</code></td><td>指针</td></tr><tr><td><code>%t</code></td><td>布尔值</td></tr><tr><td><code>%%</code></td><td>百分号（Literal <code>%</code>）</td></tr></tbody></table><p>今儿就到这吧，再搞下去脑容量不够了🤣</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>go</tag>
      
      <tag>strings</tag>
      
      <tag>strcov</tag>
      
      <tag>btyes</tag>
      
      <tag>转义字符</tag>
      
      <tag>格式化占位符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go学习记录——第四天</title>
    <link href="/2024/08/12/go-study-fourth-day/"/>
    <url>/2024/08/12/go-study-fourth-day/</url>
    
    <content type="html"><![CDATA[<p>今儿继续学go吧。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>这个一看到第一反应就是python的，感觉go就是受到了python的影响。</p><h2 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h2><p>从定义上看和python的差不多，相同的唯一类型的一组、已编号、长度固定、可通过索引来进行修改</p><p>声明格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier [<span class="hljs-built_in">len</span>]<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>所有元素都会在建立时被自动初始化为0</p><p>在初始化、打印数组元素、处理元素时都可以用<code>for</code>循环去做，和python一样</p><p>在循环中需要注意如果写成<code>i &lt;= len(arr)</code>，会导致数组越界，因为<code>len(arr)</code>是数组的长度，而<code>i</code>是索引，所以应该写成<code>i &lt; len(arr)</code>。</p><p>循环的话可以有两种写法</p><p>第一种是<code>for i := 0; i &lt; len(arr); i++ &#123; &#125;</code>，这种写法可以保证循环的次数是数组的长度，但是不推荐这种写法，因为不够简洁。</p><p>第二种是<code>for i, v := range arr &#123; &#125;</code>，这种写法可以直接遍历数组的所有元素，<code>i</code>是索引，<code>v</code>是元素的值。</p><p>go的数组是值类型（和C&#x2F;C++不同），所以在函数中修改数组元素的值，不会影响到原数组的值。所以可以通过<code>var arr1 = new([5]int)</code>建立</p><p>那么既然go的数组是值类型，那就可以用<code>new()</code>来创建数组，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr1 = <span class="hljs-built_in">new</span>([<span class="hljs-number">5</span>]<span class="hljs-type">int</span>)<br><br><span class="hljs-keyword">var</span> arr2 [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>这两个又有什么区别呢</p><p>首先第一种是创建了一个指针数组的指针，指向了一个在堆上分配的数组，所以<code>arr1</code>是一个指针，<code>arr1[0]</code>是一个指针，<code>*arr1[0]</code>才是数组的第一个元素。</p><p>第二种是创建了一个数组，在栈上分配内存，<code>arr2</code>是一个数组，<code>arr2[0]</code>是数组的第一个元素。</p><p>从使用场景上看想在多个函数之间共享数组或需要动态分配数组大小，可以使用指针（new）。如果大小固定，且只在一个函数内使用，直接声明数组会更好</p><p>所以在想把一个数组赋给另一个数组时，需要再做一次数组内存的拷贝</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">arr2 := *arr1<br>arr2[<span class="hljs-number">2</span>] = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>这样两个数组就分别有了不同的值，且赋值后修改 arr2 对 arr1 不会影响</p><p>所以在函数中将数组传入参数时，会直接拷贝副本而非对数组本身进行操作。如果想修改原数组就需要使用<code>&amp;</code>引用来传数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(a [3]<span class="hljs-type">int</span>)</span></span> &#123; fmt.Println(a) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fp</span><span class="hljs-params">(a *[3]<span class="hljs-type">int</span>)</span></span> &#123; fmt.Println(a) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> ar [<span class="hljs-number">3</span>]<span class="hljs-type">int</span><br>f(ar) <span class="hljs-comment">// passes a copy of ar</span><br>fp(&amp;ar) <span class="hljs-comment">// passes a pointer to ar</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">[0 0 0]</span><br><span class="hljs-comment">&amp;[0 0 0]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>还有一种就是生成数组切片然后传递给函数</p><h3 id="数组常量"><a href="#数组常量" class="headerlink" title="数组常量"></a>数组常量</h3><p>如果数组的值已经提前知道了就可以用数组常量来初始化数组，而不是依次使用<code>[]=</code>来初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> arrAge = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">18</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">22</span>, <span class="hljs-number">16</span>&#125;<br><span class="hljs-keyword">var</span> arrLazy = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">22</span>&#125;<br><span class="hljs-comment">// var arrLazy = []int&#123;5, 6, 7, 8, 22&#125;</span><br><span class="hljs-keyword">var</span> arrKeyValue = [<span class="hljs-number">5</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-number">3</span>: <span class="hljs-string">&quot;Chris&quot;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&quot;Ron&quot;</span>&#125;<br><span class="hljs-comment">//var arrKeyValue = []string&#123;3: &quot;Chris&quot;, 4: &quot;Ron&quot;&#125;</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arrAge); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Age at %d is %d\n&quot;</span>, i, arrAge[i])<br>&#125;<br>fmt.Println()<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arrLazy); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Number at %d is %d\n&quot;</span>, i, arrLazy[i])<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arrKeyValue); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Person at %d is %s\n&quot;</span>, i, arrKeyValue[i])<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面的代码示例可以看出有三种办法来初始化</p><ol><li><p><code>var arrAge = [5]int&#123;18, 20, 15, 22, 16&#125;</code>这种方式是直接初始化数组，数组的长度和元素个数都必须一致。这种办法中我们可以在后续不填充和元素个数一样的，也就是我们只指定左侧开始的部分元素，后续编译器会把没有初始化的元素补0。<code>[10]int &#123;1, 2, 3&#125;</code>这样便会在后续直接补0。</p></li><li><p><code>var arrLazy = [...]int&#123;5, 6, 7, 8, 22&#125;</code>这种方式是使用<code>...</code>语法来声明数组，省略了数组的长度，go会根据元素个数来推断数组的长度。忽略后从技术上来看就变成了切片。</p></li><li><p><code>var arrKeyValue = [5]string&#123;3: &quot;Chris&quot;, 4: &quot;Ron&quot;&#125;</code>这种方式是使用索引来初始化数组，索引必须小于数组的长度，否则会报错。这里的数组长度同样可以写成<code>...</code></p></li></ol><p>同样我们可以取任意数组常量的地址来作为新实例的指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fp</span><span class="hljs-params">(a *[3]<span class="hljs-type">int</span>)</span></span> &#123; fmt.Println(a) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>fp(&amp;[<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;i, i * i, i * i * i&#125;)<br>&#125;<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">&amp;[0 0 0]</span><br><span class="hljs-comment">&amp;[1 1 1]</span><br><span class="hljs-comment">&amp;[2 4 8]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>本质上和python差不多，就是写法上不一样，给个例子就行了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">const</span> (<br>WIDTH  = <span class="hljs-number">1920</span><br>HEIGHT = <span class="hljs-number">1080</span><br>)<br><br><span class="hljs-keyword">type</span> pixel <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> screen [WIDTH][HEIGHT]pixel<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> y := <span class="hljs-number">0</span>; y &lt; HEIGHT; y++ &#123;<br><span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; WIDTH; x++ &#123;<br>screen[x][y] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="将数组传给函数"><a href="#将数组传给函数" class="headerlink" title="将数组传给函数"></a>将数组传给函数</h3><p>将数组传递给函数时如果数组较大将消耗很多内存，这时有两种方法可以解决</p><ul><li>传递数组的指针</li><li>传递数组的切片<br>例子中是第一种方法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>array := [<span class="hljs-number">3</span>]<span class="hljs-type">float64</span>&#123;<span class="hljs-number">7.0</span>, <span class="hljs-number">8.5</span>, <span class="hljs-number">9.1</span>&#125;<br>x := Sum(&amp;array) <span class="hljs-comment">// Note the explicit address-of operator</span><br><span class="hljs-comment">// to pass a pointer to the array</span><br>fmt.Printf(<span class="hljs-string">&quot;The sum of the array is: %f&quot;</span>, x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span><span class="hljs-params">(a *[3]<span class="hljs-type">float64</span>)</span></span> (sum <span class="hljs-type">float64</span>) &#123;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> a &#123; <span class="hljs-comment">// derefencing *a to get back to the array is not necessary!</span><br>sum += v<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片（slice）是对数组的一组连续片段的引用（该数组为匿名数组，也是相关数组），从名字上看类似于python的切片，但实际上和python的list类似而不是切片。</p><p>该片段可能是整个数组，也可能是有起始和终止索引所构成的子集片段。但索引并不包含在整个子集中。</p><p>切片还提供了相关数组的动态窗口（可以拿来做滑动窗口和DP好像，确信）</p><p>由于切片是自带索引的，所以<code>len()</code>, <code>cap()</code>, <code>append()</code>等操作都可以直接使用。</p><p>这里需要说的是<code>cap()</code>，该函数可以测量切片的计算容量最大可以为多少，等于切片的长度 + 数组切片之外的长度。</p><p>举个例子如果有一个切片<code>s</code>，<code>cap(s)</code>就是从索引0到<code>len(s)</code>的元素个数，而<code>len(s)</code>是切片的长度。切片的长度不会超过它的容量，也即<code>0&lt;=s&lt;=cap(s)</code>。</p><p>由于切片是带有索引机制，结合python带索引的东西都是可变的我们可以推理出，切片也可能是可变的。而事实证明切片是可变的，并且是在运行过程中可以改变大小，最小为0，最大为整个数组大小。</p><p>如果多个切片引用同一个数组，则他们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。</p><p>切片的优点是引用，由于不需要额外的内存且比直接使用数组更加高效，所以go中更多的使用切片。</p><h2 id="声明和初始化-1"><a href="#声明和初始化-1" class="headerlink" title="声明和初始化"></a>声明和初始化</h2><p>声明格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier []<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>这里不需要说明长度，切片在未初始化前长度默认为nil，长度为0</p><p>初始化格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> slice1 []<span class="hljs-keyword">type</span> = arr1[start:end]<br></code></pre></td></tr></table></figure><p>这里表示 <code>slice1</code> 是由数组 <code>arr1</code> 从 <code>start</code> 索引到 <code>end-1</code> 索引的切片，包括 <code>start</code> ，不包括 <code>end</code> 。</p><p>如果写<code>var slice []type = arr[:]</code>，则表示 <code>slice</code> 是 <code>arr</code> 的一个切片，等价于 <code>slice = arr[0:len(arr)]</code>。</p><p>arr[2:]表示从索引2开始到数组末尾的切片，arr[:3]表示从数组开头到索引3-1的切片。</p><p>如果想去掉最后一个元素，则为<code>slice = arr[:len(arr)-1]</code>。</p><p>一个由数字 1、2、3 组成的切片可以这么生成：s :&#x3D; [3]int{1,2,3}[:]（注：应先用 s :&#x3D; [3]int{1, 2, 3} 生成数组, 再使用 s[:] 转成切片）甚至更简单的 s :&#x3D; []int{1,2,3}。</p><p>s2 :&#x3D; s[:] 是用切片组成的切片，拥有相同的元素，但是仍然指向相同的相关数组。</p><p>由于前面提到切片的上限是 <code>cap(s)</code> 所以如果继续扩展将会报错。</p><p>对每个切片下面的情况是成立的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s == s[:i] + s[i:] <span class="hljs-comment">// i是一个整数且: 0 &lt;= i &lt;= len(s)</span><br><span class="hljs-built_in">len</span>(s) &lt;= <span class="hljs-built_in">cap</span>(s)<br></code></pre></td></tr></table></figure><p>在前面说数组时提到我们可以不指定长度使用<code>...</code>来表明他长度不固定，让编译器自己去识别。那我们忽略掉<code>...</code>就可以得到切片的初始化了。<code>var x = []int&#123;1,2,3&#125;</code>。这样就创建了一个长度为5的数字同时创建了一个相关切片。</p><p>切片在内存中实际上是一个有三个域的结构体——指向相关数组的指针、切片长度、切片容量。</p><figure>  <img src="/2024/08/12/go-study-fourth-day/7_2_1.png" class="" title="7.2 Silence in Memory">  <figcaption>7.2 Silence in Memory</figcaption></figure><p>从图中看到，<code>y[0] = 3</code>且<code>y[1] = 5</code>。切片y[0:4] &#x3D; [3, 5, 7, 11]。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">6</span>]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> slice1 []<span class="hljs-type">int</span> = arr1[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>] <span class="hljs-comment">// index 5 niet meegerekend!</span><br><br><span class="hljs-comment">// load the array with integers: 0,1,2,3,4,5</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr1); i++ &#123;<br>arr1[i] = i<br>&#125;<br><br><span class="hljs-comment">// print the slice:</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice1); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Slice at %d is %d\n&quot;</span>, i, slice1[i])<br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;The length of arr1 is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(arr1))<br>fmt.Printf(<span class="hljs-string">&quot;The length of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1))<br>fmt.Printf(<span class="hljs-string">&quot;The capacity of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">cap</span>(slice1))<br><br><span class="hljs-comment">// grow the slice:</span><br>slice1 = slice1[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice1); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Slice at %d is %d\n&quot;</span>, i, slice1[i])<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;The length of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1))<br>fmt.Printf(<span class="hljs-string">&quot;The capacity of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">cap</span>(slice1))<br><br><span class="hljs-comment">// grow the slice beyond capacity:</span><br><span class="hljs-comment">// slice1 = slice1[0:7 ] // panic: runtime error: slice bounds out of range</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">Slice at 0 is 2</span><br><span class="hljs-comment">Slice at 1 is 3</span><br><span class="hljs-comment">Slice at 2 is 4</span><br><span class="hljs-comment">Slice at 3 is 5</span><br><span class="hljs-comment">The length of arr1 is 6</span><br><span class="hljs-comment">The length of slice1 is 4</span><br><span class="hljs-comment">The capacity of slice1 is 6</span><br><span class="hljs-comment">Slice at 0 is 2</span><br><span class="hljs-comment">Slice at 1 is 3</span><br><span class="hljs-comment">Slice at 2 is 4</span><br><span class="hljs-comment">Slice at 3 is 5</span><br><span class="hljs-comment">The length of slice1 is 4</span><br><span class="hljs-comment">The capacity of slice1 is 6</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>如果<code>s2</code>是一个切片，我们可以使用<code>s2[1:]</code>来表示将切片向后移一位，而结尾没有后移。而我们使用<code>s2[-1:]</code>就会报错，因为切片不能被重新分片以获得数组的前一个元素。</p><p>由于切片本身就是引用，所以绝不可以再使用一个指针去引用索引。</p><h2 id="将切片传递给函数"><a href="#将切片传递给函数" class="headerlink" title="将切片传递给函数"></a>将切片传递给函数</h2><p>如果一个函数需要调用数组，则我们可以创建一个切片并引用传递函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>s := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(a); i++ &#123;<br>s += a[i]<br>&#125;<br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>sum(arr[:])<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用make-创建一个切片"><a href="#用make-创建一个切片" class="headerlink" title="用make()创建一个切片"></a>用make()创建一个切片</h2><p>当相关数组还没被定义时可以使用<code>make()</code>来创建一个切片，同时创建好相关数组<code>var slice1 []type = make([]type, len)</code>。也可以简写为<code>slice1 := make([]type, len)</code>，这里的<code>len</code>表示切片的长度也是<code>slice</code>的初始长度。</p><p>举个例子<code>s2 := make([]int, 5)</code>表示创建一个长度为5的切片，初始值都是0。那么<code>cap(s2) == len(s2) == 5</code>。</p><p><code>make()</code>可以接受两个参数，元素类型和切片的元素个数。</p><p>如果创建一个<code>slice1</code>且不想占用整个数组，而是占用以<code>len</code>为个数，那么只要<code>slice1 = make([]type, len, cap)</code>就可以了。</p><p><code>make()</code>的使用方法是<code>func make([]T, len, cap)</code>，其中<code>len</code>表示切片的长度，<code>cap</code>表示切片的容量。<code>cap</code>为可选。</p><p>下面两种方法可以创建相同的切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>)<br><span class="hljs-built_in">new</span>([<span class="hljs-number">100</span>]<span class="hljs-type">int</span>)[<span class="hljs-number">0</span>:<span class="hljs-number">50</span>]<br></code></pre></td></tr></table></figure><figure>  <img src="/2024/08/12/go-study-fourth-day/7_2_2.png" class="" title="使用make()生成切片的内存结构">  <figcaption>使用make()生成切片的内存结构</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> slice1 []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><span class="hljs-comment">// load the array/slice:</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice1); i++ &#123;<br>slice1[i] = <span class="hljs-number">5</span> * i<br>&#125;<br><br><span class="hljs-comment">// print the slice:</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice1); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Slice at %d is %d\n&quot;</span>, i, slice1[i])<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\nThe length of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1))<br>fmt.Printf(<span class="hljs-string">&quot;The capacity of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">cap</span>(slice1))<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">Slice at 0 is 0  </span><br><span class="hljs-comment">Slice at 1 is 5  </span><br><span class="hljs-comment">Slice at 2 is 10  </span><br><span class="hljs-comment">Slice at 3 is 15  </span><br><span class="hljs-comment">Slice at 4 is 20  </span><br><span class="hljs-comment">Slice at 5 is 25  </span><br><span class="hljs-comment">Slice at 6 is 30  </span><br><span class="hljs-comment">Slice at 7 is 35  </span><br><span class="hljs-comment">Slice at 8 is 40  </span><br><span class="hljs-comment">Slice at 9 is 45  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">The length of slice1 is 10  </span><br><span class="hljs-comment">The capacity of slice1 is 10  </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="new-和make-的区别"><a href="#new-和make-的区别" class="headerlink" title="new()和make()的区别"></a>new()和make()的区别</h2><p><code>make()</code>是用来创建数组的，<code>new()</code>是用来创建指针的。</p><p><code>new(T)</code>为每个新的类型<code>T</code>分配一片内存，初始化为<code>0</code>并返回类型为<code>*T</code>的内存地址。所以这种方法返回的是 <strong>一个指向类型为<code>T</code>值为<code>0</code>的地址的指针</strong> ，适用于值类型如数组和结构体。</p><p><code>make(T)</code> <strong>返回一个类型为<code>T</code>的初始值</strong> ，适用于三种类型，切片、<code>map</code>、<code>channel</code>。</p><p>也就是说<code>new()</code>用来分配内存，<code>make()</code>用来初始化。</p><p>总结一下就是，由于<code>slice</code>、<code>map</code>、<code>channel</code>都是引用类型，三者都存在对于内存中存在多个组成部分，需要对内存进行初始化后才可以使用，这里就需要<code>make()</code>。而<code>new()</code>是直接获取一个地址，不进行初始化。所以需要使用<code>make()</code>来初始化并获取地址，而非简单使用<code>new()</code>获取地址。</p><figure>  <img src="/2024/08/12/go-study-fourth-day/7_2_3.png" class="" title="new()和make()的不同">  <figcaption>new()和make()的不同</figcaption></figure><p>第一幅图</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p *[]<span class="hljs-type">int</span> = <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>) <span class="hljs-comment">// *p == nil; with len and cap 0</span><br>p := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p>第二幅图</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">p := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>在第二幅图中，实际上切片已经被初始化，但指向了一个空指针。</p><p>上面方法实际上并不实用，更常见的是以下两种</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>)<br><br>或<br><br>v := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><p>这样分配了有50个<code>int</code>值的数组，并且创建了一个长度为10，容量为50的切片<code>v</code>，该切片指向了前10个元素。</p><h2 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h2><p>多维切片和多维数组类似，也是可以由多个一维切片组成，且长度可变。这里也需要用到<code>make()</code>对内层切片进行单独分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个 2x3 的二维切片</span><br>    matrix := [][]<span class="hljs-type">int</span>&#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>        &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;,<br>    &#125;<br><br>    <span class="hljs-comment">// 打印二维切片</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[i]); j++ &#123;<br>            fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, matrix[i][j])<br>        &#125;<br>        fmt.Println() <span class="hljs-comment">// 换行</span><br>    &#125;<br><br>    <span class="hljs-comment">// 修改某个元素</span><br>    matrix[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">10</span> <span class="hljs-comment">// 将第二行第三列的值改为 10</span><br><br>    <span class="hljs-comment">// 再次打印二维切片</span><br>    fmt.Println(<span class="hljs-string">&quot;修改后的二维切片:&quot;</span>)<br>    <span class="hljs-keyword">for</span> _, row := <span class="hljs-keyword">range</span> matrix &#123;<br>        fmt.Println(row)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里发现go和python通过循环对多维数组进行操作有点类似，下面进行对比</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[i]); j++ &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, matrix[i][j])<br>    &#125;<br>    fmt.Println()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON">matrix = [<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>    [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[i])):<br>        <span class="hljs-built_in">print</span>(matrix[i][j], end=<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>go</tag>
      
      <tag>数组</tag>
      
      <tag>切片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——链表</title>
    <link href="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141 环形链表"></a>141 环形链表</h1><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：<code>pos</code> <strong>不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。<br>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/141.1.png" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/141.2.png" class="" title="示例2">  <figcaption>示例2</figcaption></figure><pre><code class="hljs">输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p>示例 3：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/141.3.png" class="" title="示例3">  <figcaption>示例3</figcaption></figure><pre><code class="hljs">输入：head = [1], pos = -1输出：false解释：链表中没有环。</code></pre><p>提示：</p><p>链表中节点的数目范围是 <code>[0, 104]</code><br><code>-105 &lt;= Node.val &lt;= 105</code><br><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>环形链表顾名思义就是链表中存在一个环，当节点遍历到能够连接到环的位置能够回到前面。</p><p>所以我们可以用快慢指针，快指针一次走两步慢指针一次走一步，只要这两个能够相遇则为有环，如果不能就表示无环。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        slow = fast = head<br>        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:<br>            slow = slow.<span class="hljs-built_in">next</span><br>            fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> slow == fast:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间76ms，消耗内存18.8MB</p><p>这里提交后发现这个的执行时间还是太慢了，所以我们对这个进行优化。</p><h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>既然我们用两个指针会导致整个代码的速度变慢，把我们就只用一个指针，用一个集合去记录已经走过的位置，只要能够回来就表示这里有环，如果不能就表示无环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        visited = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">while</span> head:<br>            <span class="hljs-keyword">if</span> head <span class="hljs-keyword">in</span> visited:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            visited.add(head)<br>            head = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间46ms，消耗内存19.1MB</p><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2 两数相加"></a>2 两数相加</h1><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/2.1.png" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.</code></pre><p>示例 2：</p><pre><code class="hljs">输入：l1 = [0], l2 = [0]输出：[0]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1]</code></pre><p>提示：</p><p>每个链表中的节点数在范围 <code>[1, 100]</code> 内</p><p><code>0 &lt;= Node.val &lt;= 9</code></p><p>题目数据保证列表表示的数字不含前导零</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这里需要提前知道题目没给的条件，这个是在实例中有体现，我们遇到加和为两位数后，我们需要进位，所以我们需要一个进位的变量。</p><p>这里我们需要用到一个divmod函数来解决这个问题，函数输入为两个数，返回值为一个元组，第一个元素为商，第二个元素为余数。</p><p>其余的就是取数、加和、下一个的问题了</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        curr = dummy<br>        carry = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2 <span class="hljs-keyword">or</span> carry:<br>            val1 = val2 = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> l1:<br>                val1 = l1.val<br>                l1 = l1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> l2:<br>                val2 = l2.val<br>                l2 = l2.<span class="hljs-built_in">next</span><br>            carry, val = <span class="hljs-built_in">divmod</span>(val1 + val2 + carry, <span class="hljs-number">10</span>)<br>            curr.<span class="hljs-built_in">next</span> = ListNode(val)<br>            curr = curr.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间61ms，消耗内存16.4MB</p><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21 合并两个有序链表"></a>21 合并两个有序链表</h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/21.1.jpg" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：l1 = [], l2 = []输出：[]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：l1 = [], l2 = [0]输出：[0]</code></pre><p>提示：</p><p>两个链表的节点数目范围是 <code>[0, 50]</code></p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><p>l1 和 l2 均按 <strong>非递减顺序</strong> 排列</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这里我们就还是设置两个节点，均为头结点的前一位，然后设置一个辅助节点，用来存储合并后的链表。</p><p>然后我们比较两个链表的头结点，谁小就把谁的头结点放到辅助节点的后面，然后把这个节点的指针指向下一个节点，然后继续比较，直到两个链表都为空。</p><p>最后把辅助节点的下一个节点作为合并后的链表的头结点。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        curr = dummy<br>        <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:<br>            <span class="hljs-keyword">if</span> list1.val &lt; list2.val:<br>                curr.<span class="hljs-built_in">next</span> = list1<br>                list1 = list1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                curr.<span class="hljs-built_in">next</span> = list2<br>                list2 = list2.<span class="hljs-built_in">next</span><br>            curr = curr.<span class="hljs-built_in">next</span><br>        curr.<span class="hljs-built_in">next</span> = list1 <span class="hljs-keyword">or</span> list2<br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间40ms，消耗内存16.4MB</p><h1 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138 随机链表的复制"></a>138 随机链表的复制</h1><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 <a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a>。 深拷贝应该正好由 <code>n</code> 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p><p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p><p>返回复制链表的头节点。</p><p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p><p><code>val</code>：一个表示 <code>Node.val</code> 的整数。<br><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为  <code>null</code> 。<br>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p><p>示例 1：<br><img src="/../img/138_1.png" alt="示例1"></p><pre><code class="hljs">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</code></pre><p>示例 2：<br><img src="/../img/138_2.png" alt="示例2"></p><pre><code class="hljs">输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]]</code></pre><p>示例 3：<br><img src="/../img/138_3.png" alt="示例3"></p><pre><code class="hljs">输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]]</code></pre><p>提示：</p><p><code>0 &lt;= n &lt;= 1000</code></p><p><code>-104 &lt;= Node.val &lt;= 104</code></p><p><code>Node.random</code> 为 <code>null</code> 或指向链表中的节点。</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这里我们可以借助字典来实现。</p><p>首先明确一点，我们可以采用两次循环来完成，一次获取val，一次获取next和random</p><p>最后直接返回第一个节点即可。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">copyRandomList</span>(<span class="hljs-params">self, head: <span class="hljs-string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Optional[Node]&#x27;</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        curr = head<br>        dic = &#123;&#125;<br>        <span class="hljs-keyword">while</span> curr:<br>            dic[curr] = Node(curr.val)<br>            curr = curr.<span class="hljs-built_in">next</span><br>            <br>        curr = head<br>        <span class="hljs-keyword">while</span> curr:<br>            dic[curr].<span class="hljs-built_in">next</span> = dic.get(curr.<span class="hljs-built_in">next</span>)<br>            dic[curr].random = dic.get(curr.random)<br>            curr = curr.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dic.get(head)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间48ms，消耗内存17.2MB</p><h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92 反转链表 II"></a>92 反转链表 II</h1><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 反转后的链表 。</p><p>示例 1：</p><pre><code class="hljs">输入：head = [1,2,3,4,5], left = 2, right = 4输出：[1,4,3,2,5]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：head = [5], left = 1, right = 1输出：[5]</code></pre><p>提示：</p><p>链表中节点数目为 <code>n</code></p><p><code>1 &lt;= n &lt;= 500</code></p><p><code>-500 &lt;= Node.val &lt;= 500</code></p><p><code>1 &lt;= left &lt;= right &lt;= n</code></p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>首先需要知道一点，我们在设置头结点前面一个虚拟节点的时候，需要用一个类似pre的字符去表示，直接使用头结点<code>dummy</code>会导致后续出现异常导致无法完全测试。</p><p>然后反转部分我的思路是直接原地操作，不进行拆开后后续拼接，所以时间复杂度上会相对来说高一些。之前反转链表中使用过拆开后拼接，这种情况下时间复杂度会降低，但是也会由于思路的混乱导致最后测试失败。</p><p>这里需要注意的另外一点是，我们这里只使用两个节点进行直接操作。刚开始我也使用了添加一个tail进行操作，但是会导致后续反转逻辑写起来比较复杂。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBetween</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        dummy.<span class="hljs-built_in">next</span> = head<br>        pre = dummy<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m - <span class="hljs-number">1</span>):<br>            pre = pre.<span class="hljs-built_in">next</span><br>        start = pre.<span class="hljs-built_in">next</span><br>        then = start.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - m):<br>            start.<span class="hljs-built_in">next</span> = then.<span class="hljs-built_in">next</span><br>            then.<span class="hljs-built_in">next</span> = pre.<span class="hljs-built_in">next</span><br>            pre.<span class="hljs-built_in">next</span> = then<br>            then = start.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span> <br></code></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间46ms，消耗内存16.3MB</p><h1 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25 K 个一组翻转链表"></a>25 K 个一组翻转链表</h1><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/25_1.jpg" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：head = [1,2,3,4,5], k = 2输出：[2,1,4,3,5]</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/25_2.jpg" class="" title="示例2">  <figcaption>示例2</figcaption></figure><pre><code class="hljs">输入：head = [1,2,3,4,5], k = 3输出：[3,2,1,4,5]</code></pre><p>提示：</p><p>链表中的节点数目为 <code>n</code></p><p><code>1 &lt;= k &lt;= n &lt;= 5000</code></p><p><code>0 &lt;= Node.val &lt;= 1000</code></p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>这里其实反转思路和前一道题一模一样。</p><p>需要注意的是我这里没用一个额外的数去累加计数，而是将整个需要反转的进行递归。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseKGroup</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        a = b = head<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> b:<br>                <span class="hljs-keyword">return</span> head<br>            b = b.<span class="hljs-built_in">next</span>  <br>        newHead = <span class="hljs-variable language_">self</span>.reverse(a, b)<br>        a.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.reverseKGroup(b, k)<br>        <span class="hljs-keyword">return</span> newHead<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">self, a, b</span>):<br>        prev = <span class="hljs-literal">None</span><br>        curr = a<br>        <span class="hljs-keyword">while</span> curr != b:<br>            <span class="hljs-built_in">next</span> = curr.<span class="hljs-built_in">next</span><br>            curr.<span class="hljs-built_in">next</span> = prev<br>            prev = curr<br>            curr = <span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> prev<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间37ms，消耗内存17.1MB</p><h1 id="19-删除链表的倒数第-N-个节点"><a href="#19-删除链表的倒数第-N-个节点" class="headerlink" title="19 删除链表的倒数第 N 个节点"></a>19 删除链表的倒数第 N 个节点</h1><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p>示例 1：</p><pre><code class="hljs">输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：head = [1], n = 1输出：[]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：head = [1,2], n = 1输出：[1]</code></pre><p>提示：</p><p>链表中结点的数目为 <code>sz</code></p><p><code>1 &lt;= sz &lt;= 30</code></p><p><code>0 &lt;= Node.val &lt;= 100</code></p><p><code>1 &lt;= n &lt;= sz</code></p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>首先按照数组字符串的思路直接倒序遍历找到节点删除就可以，但链表是不能进行倒序遍历和直接获取长度的。所以我们就需要自己去通过循环得到相关的内容。</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        dummy.<span class="hljs-built_in">next</span> = head<br>        cur, length = head, <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 获取长度</span><br>        <span class="hljs-keyword">while</span> cur:<br>            length += <span class="hljs-number">1</span><br>            cur = cur.<span class="hljs-built_in">next</span><br>        cur = dummy<br>        <span class="hljs-comment"># 找到倒数第 n 个节点</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length - n):<br>            cur = cur.<span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 删除节点</span><br>        cur.<span class="hljs-built_in">next</span> = cur.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间39ms，消耗内存16.3MB</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>这里我用了快慢指针去，思路上都差不多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> n &lt;= <span class="hljs-number">0</span>:  <span class="hljs-comment"># 增加对n的合理性检查</span><br>            <span class="hljs-keyword">return</span> head<br>        <br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        dummy.<span class="hljs-built_in">next</span> = head<br>        first = second = dummy<br>        <br>        <span class="hljs-comment"># 先将first指针移动n+1步</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> first:  <span class="hljs-comment"># 如果n大于链表长度，直接返回</span><br>                <span class="hljs-keyword">return</span> head<br>            first = first.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-comment"># 同时移动first和second指针，直到first到达链表末尾</span><br>        <span class="hljs-keyword">while</span> first:<br>            first = first.<span class="hljs-built_in">next</span><br>            second = second.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-comment"># 删除节点</span><br>        second.<span class="hljs-built_in">next</span> = second.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h1 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82 删除排序链表中的重复元素 II"></a>82 删除排序链表中的重复元素 II</h1><p>给定一个已排序的链表的头 <code>head</code> ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p><p>示例 1：</p><pre><code class="hljs">输入：head = [1,2,3,3,4,4,5]输出：[1,2,5]</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/82_2.jpg" class="" title="示例2">  <figcaption>示例2</figcaption></figure>    输入：head = [1,1,1,2,3]    输出：[2,3]<p>提示：</p><p>链表中节点数目在范围 <code>[0, 300]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><p>题目数据保证链表已经按升序 <strong>排列</strong></p><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>这里首先要注意一点也是我之前做了好几次一直过不去的原因。当我们发现两个节点值相同时，应该用一个变量去存储值，而不是直接进行后续的循环操作，直接进行操作将一直持续不断的遍历两个节点而非继续往后走。</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        dummy.<span class="hljs-built_in">next</span> = head<br>        curr = dummy<br>        <span class="hljs-keyword">while</span> curr.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> curr.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>:<br>            <span class="hljs-keyword">if</span> curr.<span class="hljs-built_in">next</span>.val == curr.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>.val:<br>                duplicate_val = curr.<span class="hljs-built_in">next</span>.val<br>                <span class="hljs-keyword">while</span> curr.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> curr.<span class="hljs-built_in">next</span>.val == duplicate_val:<br>                    curr.<span class="hljs-built_in">next</span> = curr.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                curr = curr.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间45ms，消耗内存16.3MB</p><h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61 旋转链表"></a>61 旋转链表</h1><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 k 个位置。</p><p>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/61_1.jpg" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：head = [1,2,3,4,5], k = 2输出：[4,5,1,2,3]</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/61_2.jpg" class="" title="示例2">  <figcaption>示例2</figcaption></figure><pre><code class="hljs">输入：head = [0,1,2], k = 4输出：[2,0,1]</code></pre><p>提示：</p><p>链表中节点的数目在范围 <code>[0, 500]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><p><code>0 &lt;= k &lt;= 2 * 109</code></p><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>首先知道我们每个节点往前移k个就相当于倒数第k个节点之后的节点移到头结点前。</p><p>其次我们计算长度后，我们对k进行操作，k就相当于k对长度取余，因为k大于长度时我们进行后续操作就相当于走了一圈又继续走。</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotateRight</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        curr = head<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> curr:<br>            count += <span class="hljs-number">1</span><br>            curr = curr.<span class="hljs-built_in">next</span><br>        k = k % count<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> head<br>        fast = slow = head<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            fast = fast.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> fast.<span class="hljs-built_in">next</span>:<br>            slow = slow.<span class="hljs-built_in">next</span><br>            fast = fast.<span class="hljs-built_in">next</span><br>        new_head = slow.<span class="hljs-built_in">next</span><br>        slow.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        fast.<span class="hljs-built_in">next</span> = head<br>        <span class="hljs-keyword">return</span> new_head<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间40ms，消耗内存16.4MB</p><h1 id="86-分割链表"><a href="#86-分割链表" class="headerlink" title="86 分割链表"></a>86 分割链表</h1><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p><p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p><p>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/86_1.jpg" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：head = [1,4,3,2,5,2], x = 3输出：[1,2,2,4,3,5]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：head = [2,1], x = 2输出：[1,2]</code></pre><p>提示：</p><p>链表中节点的数目在范围 <code>[0, 200]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><p><code>-200 &lt;= x &lt;= 200</code></p><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>看到题目第一反应是二分法，大于k的在右边，小于的在左边。</p><p>然后我们就可以用相似的思路去做。我们建立两个表用来存储大于和小于的节点，其次我们在遍历后直接将两个表一拼接就直接完成了。</p><p>切记我们需要在最后将大于的那个表的尾节点指向None，不然就会形成环。</p><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        smaller = ListNode(<span class="hljs-number">0</span>)<br>        bigger = ListNode(<span class="hljs-number">0</span>)<br>        small, big = smaller, bigger<br>        <span class="hljs-keyword">while</span> head:<br>            <span class="hljs-keyword">if</span> head.val &lt; x:<br>                small.<span class="hljs-built_in">next</span> = head<br>                small = small.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                big.<span class="hljs-built_in">next</span> = head<br>                big = big.<span class="hljs-built_in">next</span>  <br>            head = head.<span class="hljs-built_in">next</span><br>        small.<span class="hljs-built_in">next</span> = bigger.<span class="hljs-built_in">next</span><br>        big.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> smaller.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间38ms，消耗内存16.3MB</p><h1 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146 LRU 缓存"></a>146 LRU 缓存</h1><p>请你设计并实现一个满足  <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。<br>实现 <code>LRUCache</code> 类：<br><code>LRUCache(int capacity)</code> 以 正整数 作为容量 <code>capacity</code> 初始化 LRU 缓存<br><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。<br><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 逐出 最久未使用的关键字。<br>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p>示例：</p><pre><code class="hljs">输入[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;lRUCache.get(1);    // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;lRUCache.get(2);    // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;lRUCache.get(1);    // 返回 -1 (未找到)lRUCache.get(3);    // 返回 3lRUCache.get(4);    // 返回 4</code></pre><p>提示：</p><p><code>1 &lt;= capacity &lt;= 3000</code></p><p><code>0 &lt;= key &lt;= 10000</code></p><p><code>0 &lt;= value &lt;= 105</code></p><p>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></p><h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>这道题有那么亿点点绕，所以思路上写的比较详细</p><p>首先我们需要完成两个操作</p><ul><li><code>get(key)</code>: 如果key存在于缓存中，则返回对应的值，否则返回-1。</li><li><code>put(key, value)</code>: 将key-value对插入缓存中。如果key已经存在，更新其值；如果key不存在并且缓存已满，则移除最近最少使用的项。</li></ul><p>然后我们来说明如何实现</p><ol><li>初始化：构建一个空哈希表和一个带有哨兵头尾节点的双向链表</li><li><code>get(key)</code>：<ul><li>如果不存在，直接返回-1</li><li>如果存在，找到对应节点，将其从链表中移除并添加到链表末尾，以表示它是最近使用的元素</li></ul></li><li><code>put(key, value)</code>：<ul><li>如果key已经在缓存中，更新其值，并将该节点移动到链表的末尾。</li><li>如果key不存在，创建一个新节点并插入到链表末尾。</li><li>如果插入后缓存超出了容量，移除链表头部的节点（即最近最少使用的节点），并从哈希表中删除对应的键。</li></ul></li><li>操作解释<ul><li><code>_add</code>：将节点添加到双向链表的末尾，这表示该节点是最新被访问的。</li><li><code>_remove</code>：将节点从双向链表中删除，这个操作主要用于在<code>get</code>或<code>put</code>操作时调整节点的位置，以及在缓存容量超出限制时移除最老的节点。</li></ul></li></ol><h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CreatNode</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key = <span class="hljs-number">0</span>, value = <span class="hljs-number">0</span></span>):<br>        <span class="hljs-variable language_">self</span>.key = key<br>        <span class="hljs-variable language_">self</span>.value = value<br>        <span class="hljs-variable language_">self</span>.prev = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span> = &#123;&#125;<br>        <span class="hljs-variable language_">self</span>.head = CreatNode()<br>        <span class="hljs-variable language_">self</span>.tail = CreatNode()<br>        <span class="hljs-variable language_">self</span>.head.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.tail<br>        <span class="hljs-variable language_">self</span>.tail.prev = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-variable language_">self</span>.capacity = capacity<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        node = <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>[key]<br>        <span class="hljs-variable language_">self</span>._remove(node)<br>        <span class="hljs-variable language_">self</span>._add(node)<br>        <span class="hljs-keyword">return</span> node.value<br>    <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span>, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>:<br>            node = <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>[key]<br>            node.value = value<br>            <span class="hljs-variable language_">self</span>._remove(node)<br>            <span class="hljs-variable language_">self</span>._add(node)<br>        <span class="hljs-keyword">else</span>:<br>            node = CreatNode(key, value)<br>            <span class="hljs-variable language_">self</span>._add(node)<br>            <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>[key] = node<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>) &gt; <span class="hljs-variable language_">self</span>.capacity:<br>                <span class="hljs-keyword">del</span> <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>[<span class="hljs-variable language_">self</span>.head.<span class="hljs-built_in">next</span>.key]<br>                <span class="hljs-variable language_">self</span>._remove(<span class="hljs-variable language_">self</span>.head.<span class="hljs-built_in">next</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_remove</span>(<span class="hljs-params">self, node</span>):<br>        prev = node.prev<br>        <span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span><br>        prev.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>        <span class="hljs-built_in">next</span>.prev = prev<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_add</span>(<span class="hljs-params">self, node</span>):<br>        prev = <span class="hljs-variable language_">self</span>.tail.prev<br>        prev.<span class="hljs-built_in">next</span> = node<br>        node.prev = prev<br>        node.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.tail<br>        <span class="hljs-variable language_">self</span>.tail.prev = node<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(1)，执行时间457ms，消耗内存75.6MB</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go学习记录——第三天</title>
    <link href="/2024/08/09/go-study-third-day/"/>
    <url>/2024/08/09/go-study-third-day/</url>
    
    <content type="html"><![CDATA[<p>今天也继续学习go吧。今天找了下《The Way to Go》这本书的中译本，书作者是Ivo Balbaert。也非常感谢翻译者们的努力，在这里贴上链接<a href="https://github.com/unknwon/the-way-to-go_ZH_CN.git">The Way to Go</a>，也希望大家能支持下翻译者们，给项目加个小星星。</p><p>根据对比，这个讲的比较完整，咱就准备根据这个进行学习，后续也会找一些其他资料来学习。早知道就直接在GitHub上找资料来学习了🤣，事实证明GitHub才是好东西。</p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>go的指针不同于C的指针，go的指针不能进行算术运算，但是可以通过指针控制特定集合的数据结构、分配的数量及内存的访问模式。</p><p>go的取地址符号是<code>&amp;</code>，放在变量前即可获得该变量的地址。</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i1 = <span class="hljs-number">5</span><br>fmt.Printf(<span class="hljs-string">&quot;An integer: %d, its location in memory: %p\n&quot;</span>, i1, &amp;i1)<br><br><span class="hljs-keyword">var</span> intP *<span class="hljs-type">int</span><br>intP = &amp;i1<br>fmt.Printf(<span class="hljs-string">&quot;The value at memory location %p is %d\n&quot;</span>, intP, *intP)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的第一个输出的便是i1的地址</p><p>而在第二个输出中，定义了一个指向int的指针，用*i表示，然后我们用intP就可以调用。而后intP的值为i1的地址，所以输出的结果为5且地址为原始i1的地址。</p><p>指针格式化标识符为<code>%p</code>。（关于这个后续写个表格都列一下，好像还蛮多的）</p><p>然后捋一下第二个输出，intP -&gt; &amp;i1，所以引用了i1。没有指向任何东西的时候指针的默认值为nil，通常来说指针缩写是<code>prt</code></p><p>再来另外一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-string">&quot;good bye&quot;</span><br><span class="hljs-keyword">var</span> p *<span class="hljs-type">string</span> = &amp;s<br>*p = <span class="hljs-string">&quot;ciao&quot;</span><br><br>fmt.Printf(<span class="hljs-string">&quot;Here is the pointer p: %p\n&quot;</span>, p)  <span class="hljs-comment">// prints address</span><br>fmt.Printf(<span class="hljs-string">&quot;Here is the string *p: %s\n&quot;</span>, *p) <span class="hljs-comment">// prints string</span><br>fmt.Printf(<span class="hljs-string">&quot;Here is the string  s: %s\n&quot;</span>, s)  <span class="hljs-comment">// prints same string</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">Here is the pointer p: 0x2540820</span><br><span class="hljs-comment">Here is the string *p: ciao</span><br><span class="hljs-comment">Here is the string s: ciao</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这里可以看到，当我们在使用指针的时候，第一个输出由于还没有进行操作，所以p指向的是s的地址。而第二个输出*p已经被赋了新值，而后s也被改变了，所以输出都是ciao。</p><p>需要注意的是指针不能获取字面量和常量的地址。</p><p>指针的一个高级应用是你可以传递一个变量的引用（如函数的参数），这样不会传递变量的拷贝。指针传递是很廉价的，只占用 4 个或 8 个字节。当程序在工作中需要占用大量的内存，或很多变量，或者两者都有，使用指针会减少内存占用和提高效率。被指向的变量也保存在内存中，直到没有任何指针指向它们，所以从它们被创建开始就具有相互独立的生命周期。</p><p>另一方面（虽然不太可能），由于一个指针导致的间接引用（一个进程执行了另一个地址），指针的过度频繁使用也会导致性能下降。</p><p>指针也可以指向另一个指针，并且可以进行任意深度的嵌套，导致你可以有多级的间接引用，但在大多数情况这会使你的代码结构不清晰。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>这里将根据这本书的相关内容对之前学习的内容进行补充。</p><p>首先先做一下书中提出的问题</p><p>如下的两个函数调用有什么不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">(A) <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">(a *A)</span></span> &#123;<br>        b = a<br>    &#125;<br><br>(B) <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">(a A)</span></span> &#123;<br>        b = &amp;a<br>    &#125;<br></code></pre></td></tr></table></figure><p>首先A中，a指向了指针*A，所以在后续是可以直接对A值本身进行修改，也就是说b现在指向了和a一样的地址，后续函数内对b的修改同样会影响a</p><p>B中，a指向的是值A，而b指向的是a的地址（副本），也就是调用了这个值（副本），并不会影响a原本的值</p><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>函数返回值可以使用<code>return</code>或<code>return var</code>，但这里就有一个问题，返回值是一个表达式的时候可能会因为没有明确的目标而报错（虽然我写python的时候也老干这个，但好像没啥影响）。所以尽可能用简短的，好辨识的返回值来命名，尽可能减少使用表达式。</p><h2 id="改变外部变量"><a href="#改变外部变量" class="headerlink" title="改变外部变量"></a>改变外部变量</h2><p>这里就需要用到指针了，实例如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// this function changes reply:</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Multiply</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>, reply *<span class="hljs-type">int</span>)</span></span> &#123;<br>    *reply = a * b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    n := <span class="hljs-number">0</span><br>    reply := &amp;n<br>    Multiply(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, reply)<br>    fmt.Println(<span class="hljs-string">&quot;Multiply:&quot;</span>, *reply) <span class="hljs-comment">// Multiply: 50</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以看到，我们在主函数部分让reply指向了n的地址，后续我们在Multiply函数中对reply的修改会影响到n，也就是通过*reply修改了外部变量的值。这里我们就是按引用传递而不是按值传递.</p><h2 id="传递变长参数"><a href="#传递变长参数" class="headerlink" title="传递变长参数"></a>传递变长参数</h2><p>如果函数的最后一个参数是<code>...type</code>的形式，这个函数就可以处理一个变长的参数，这个长度可以为0，故而被称为变参函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(a, b, arg ...<span class="hljs-type">int</span>)</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greeting</span><span class="hljs-params">(prefix <span class="hljs-type">string</span>, who ...<span class="hljs-type">string</span>)</span></span><br>Greeting(<span class="hljs-string">&quot;hello:&quot;</span>, <span class="hljs-string">&quot;Joe&quot;</span>, <span class="hljs-string">&quot;Anna&quot;</span>, <span class="hljs-string">&quot;Eileen&quot;</span>)<br></code></pre></td></tr></table></figure><p>在<code>Greeting</code>函数中，变量<code>who</code>便是变长参数，值便是<code>[]string&#123;&quot;Joe&quot;, &quot;Anna&quot;, &quot;Eileen&quot;&#125;</code></p><p>如果参数被存储在一个 slice 类型的变量 <code>slice</code> 中，则可以通过 <code>slice...</code> 的形式来传递参数，调用变参函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>x := min(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)<br>fmt.Printf(<span class="hljs-string">&quot;The minimum is: %d\n&quot;</span>, x)<br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>&#125;<br>x = min(slice...)<br>fmt.Printf(<span class="hljs-string">&quot;The minimum in the slice is: %d&quot;</span>, x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(s ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s)==<span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>min := s[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">if</span> v &lt; min &#123;<br>min = v<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> min<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">The minimum is: 0</span><br><span class="hljs-comment">The minimum in the slice is: 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>一个接受变长参数的函数可以将这个参数作为其他函数的参数进行传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F1</span><span class="hljs-params">(s ...<span class="hljs-type">string</span>)</span></span> &#123;<br>F2(s...)<br>F3(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F2</span><span class="hljs-params">(s ...<span class="hljs-type">string</span>)</span></span> &#123; &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F3</span><span class="hljs-params">(s []<span class="hljs-type">string</span>)</span></span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>变长参数可以作为对应类型的slice进行二次传递</p><p>如果变长参数的类型不同，有两种方式可以解决</p><ol><li>使用结构，定义一个结构类型，假设它叫<code>Options</code>，用于存储所有可能的参数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Options <span class="hljs-keyword">struct</span> &#123;<br>par1 type1,<br>par2 type2,<br>...<br>&#125;<br></code></pre></td></tr></table></figure>函数 F1() 可以使用正常的参数 a 和 b，以及一个没有任何初始化的 Options 结构： F1(a, b, Options {})。如果需要对选项进行初始化，则可以使用 F1(a, b, Options {par1:val1, par2:val2})。</li><li>使用空接口，如果一个变长参数的类型没有被指定，则默认为空接口interface{}，则就可以接入任何类型的参数。这种情况下我们不仅可以接入任何类型的参数，即使参数长度不固定也是没问题的。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">typecheck</span><span class="hljs-params">(..,..,values … <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> values &#123;<br><span class="hljs-keyword">switch</span> v := value.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-type">int</span>: …<br><span class="hljs-keyword">case</span> float: …<br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>: …<br><span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>: …<br><span class="hljs-keyword">default</span>: …<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="defer和追踪"><a href="#defer和追踪" class="headerlink" title="defer和追踪"></a>defer和追踪</h2><p>关键词<code>defer</code>允许我们推迟到函数返回之前（或任意位置执行<code>return</code>语句之后）一刻才执行某个语句或函数。而返回的原因就是在<code>return</code>中同样包含一些操作，并不是单纯返回一个值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>function1()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function1</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;In function1 at the top\n&quot;</span>)<br><span class="hljs-keyword">defer</span> function2()<br>fmt.Printf(<span class="hljs-string">&quot;In function1 at the bottom!\n&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function2</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Function2: Deferred until the end of the calling function!\n&quot;</span>)<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">In Function1 at the top</span><br><span class="hljs-comment">In Function1 at the bottom!</span><br><span class="hljs-comment">Function2: Deferred until the end of the calling function!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这里我们在执行后可以看到是在function1的第二个Println之后才去执行function2。我们再对比下去掉<code>defer</code>关键词的结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">In function1 at the top<br>Function2: Deferred until the end of the calling function!<br>In function1 at the bottom!<br></code></pre></td></tr></table></figure><p>这里我们就可以很清楚的看到，加入了<code>defer</code>关键词，我们的function2就被在运行到的时候被挂起，等function1的执行结束后立刻接在后面，这也就是概念中提到的推迟。</p><p>使用<code>defer</code>关键词还可以接受参数，下面这个例子就是因为defer直接接受了参数i &#x3D; 0，然后挂起。即使后面i &#x3D; 1还是会用挂起时的数进行输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">defer</span> fmt.Println(i)<br>i++<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当有多个<code>defer</code>行被注册时，将会以逆序进行运行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, i)<br>&#125;<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">4 3 2 1 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>defer</code>关键词的特性可以使得我们能够进行一些特殊的操作</p><ol><li>关闭文件流<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// open a file  </span><br><span class="hljs-keyword">defer</span> file.Close()<br></code></pre></td></tr></table></figure></li><li>解锁一个加锁的资源<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">mu.Lock()  <br><span class="hljs-keyword">defer</span> mu.Unlock() <br></code></pre></td></tr></table></figure></li><li>打印最终的报告<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">printHeader()  <br><span class="hljs-keyword">defer</span> printFooter()<br></code></pre></td></tr></table></figure></li><li>关闭数据库链接<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// open a database connection  </span><br><span class="hljs-keyword">defer</span> disconnectFromDB()   <br></code></pre></td></tr></table></figure></li></ol><p>下面一个实例来结合上面的第四种操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>doDBOperations()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connectToDB</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;ok, connected to db&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">disconnectFromDB</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;ok, disconnected from db&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doDBOperations</span><span class="hljs-params">()</span></span> &#123;<br>connectToDB()<br>fmt.Println(<span class="hljs-string">&quot;Defering the database disconnect.&quot;</span>)<br><span class="hljs-keyword">defer</span> disconnectFromDB() <span class="hljs-comment">//function called here with defer</span><br>fmt.Println(<span class="hljs-string">&quot;Doing some DB operations ...&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;Oops! some crash or network error ...&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;Returning from function here!&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-comment">//terminate the program</span><br><span class="hljs-comment">// deferred function executed here just before actually returning, even if</span><br><span class="hljs-comment">// there is a return or abnormal termination before</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">ok, connected to db</span><br><span class="hljs-comment">Defering the database disconnect.</span><br><span class="hljs-comment">Doing some DB operations ...</span><br><span class="hljs-comment">Oops! some crash or network error ...</span><br><span class="hljs-comment">Returning from function here!</span><br><span class="hljs-comment">ok, disconnected from db</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>还可以使用<code>defer</code>来实现追踪，下面两个函数就是很简单的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;entering:&quot;</span>, s) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">untrace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;leaving:&quot;</span>, s) &#125;<br></code></pre></td></tr></table></figure><p>结合到实际中就是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span>   &#123; fmt.Println(<span class="hljs-string">&quot;entering:&quot;</span>, s) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">untrace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;leaving:&quot;</span>, s) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br>trace(<span class="hljs-string">&quot;a&quot;</span>)<br><span class="hljs-keyword">defer</span> untrace(<span class="hljs-string">&quot;a&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;in a&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br>trace(<span class="hljs-string">&quot;b&quot;</span>)<br><span class="hljs-keyword">defer</span> untrace(<span class="hljs-string">&quot;b&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;in b&quot;</span>)<br>a()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>b()<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">entering: b</span><br><span class="hljs-comment">in b</span><br><span class="hljs-comment">entering: a</span><br><span class="hljs-comment">in a</span><br><span class="hljs-comment">leaving: a</span><br><span class="hljs-comment">leaving: b</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这里leaving先a后b是因为挂起是b先挂起，所以后输出</p><p>这里还有一个例子说明另一种<code>defer</code>语句，也就是使用<code>defer</code>语句来记录函数的参数和返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func1</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>log.Printf(<span class="hljs-string">&quot;func1(%q) = %d, %v&quot;</span>, s, n, err)<br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">7</span>, io.EOF<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>func1(<span class="hljs-string">&quot;Go&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">2024/08/09 15:17:05 func1(&quot;Go&quot;) = 7, EOF</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><code>close()</code></td><td>用于管道通信</td></tr><tr><td><code>len()</code>、<code>cap()</code></td><td><code>len()</code> 用于返回某个类型的长度或数量（字符串、数组、切片、<code>map</code> 和管道）；<code>cap()</code> 是容量的意思，用于返回某个类型的最大容量（只能用于数组、切片和管道，不能用于 <code>map</code>）</td></tr><tr><td><code>new()</code>、<code>make()</code></td><td><code>new()</code> 和 <code>make()</code> 均是用于分配内存：<code>new()</code> 用于值类型和用户定义的类型，如自定义结构，<code>make</code> 用于内置引用类型（切片、<code>map</code> 和管道）。它们的用法就像是函数，但是将类型作为参数：<code>new(type)</code>、<code>make(type)</code>。<code>new(T)</code> 分配类型 <code>T</code> 的零值并返回其地址，也就是指向类型 <code>T</code> 的指针。它也可以被用于基本类型：<code>v := new(int)</code>。<code>make(T)</code> 返回类型 <code>T</code> 的初始化之后的值，因此它比 <code>new()</code> 进行更多的工作。<code>new()</code> 是一个函数，不要忘记它的括号。</td></tr><tr><td><code>copy()</code>、<code>append()</code></td><td>用于复制和连接切片</td></tr><tr><td><code>panic()</code>、<code>recover()</code></td><td>两者均用于错误处理机制</td></tr><tr><td><code>print()</code>、<code>println()</code></td><td>底层打印函数，在部署环境中建议使用 <code>fmt</code> 包</td></tr><tr><td><code>complex()</code>、<code>real ()</code>、<code>imag()</code></td><td>用于创建和操作复数</td></tr></tbody></table><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>最经典的就是计算斐波那契数列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>result := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>result = fibonacci(i)<br>fmt.Printf(<span class="hljs-string">&quot;fibonacci(%d) is: %d\n&quot;</span>, i, result)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> (res <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<br>res = <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>res = fibonacci(n<span class="hljs-number">-1</span>) + fibonacci(n<span class="hljs-number">-2</span>)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">fibonacci(0) is: 1</span><br><span class="hljs-comment">fibonacci(1) is: 1</span><br><span class="hljs-comment">fibonacci(2) is: 2</span><br><span class="hljs-comment">fibonacci(3) is: 3</span><br><span class="hljs-comment">fibonacci(4) is: 5</span><br><span class="hljs-comment">fibonacci(5) is: 8</span><br><span class="hljs-comment">fibonacci(6) is: 13</span><br><span class="hljs-comment">fibonacci(7) is: 21</span><br><span class="hljs-comment">fibonacci(8) is: 34</span><br><span class="hljs-comment">fibonacci(9) is: 55</span><br><span class="hljs-comment">fibonacci(10) is: 89</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>go还可以函数之间相互递归调用，由于go的特性，函数声明的位置可以任意</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d is even: is %t\n&quot;</span>, <span class="hljs-number">16</span>, even(<span class="hljs-number">16</span>)) <span class="hljs-comment">// 16 is even: is true</span><br>fmt.Printf(<span class="hljs-string">&quot;%d is odd: is %t\n&quot;</span>, <span class="hljs-number">17</span>, odd(<span class="hljs-number">17</span>))<br><span class="hljs-comment">// 17 is odd: is true</span><br>fmt.Printf(<span class="hljs-string">&quot;%d is odd: is %t\n&quot;</span>, <span class="hljs-number">18</span>, odd(<span class="hljs-number">18</span>))<br><span class="hljs-comment">// 18 is odd: is false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">even</span><span class="hljs-params">(nr <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> nr == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> odd(RevSign(nr) - <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">odd</span><span class="hljs-params">(nr <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> nr == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> even(RevSign(nr) - <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RevSign</span><span class="hljs-params">(nr <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> nr &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> -nr<br>&#125;<br><span class="hljs-keyword">return</span> nr<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">16 is even: is true</span><br><span class="hljs-comment">17 is odd: is true</span><br><span class="hljs-comment">18 is odd: is false</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="闭包的补充"><a href="#闭包的补充" class="headerlink" title="闭包的补充"></a>闭包的补充</h2><p>实例中将会看到函数<code>Add2()</code>和<code>Adder()</code>均返回签名为<code>func(b_int) int</code>的函数</p><p><code>Add2()</code>不接受任何参数，而<code>Adder()</code>接受一个int类型的参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// make an Add2 function, give it a name p2, and call it:</span><br>p2 := Add2()<br>fmt.Printf(<span class="hljs-string">&quot;Call Add2 for 3 gives: %v\n&quot;</span>, p2(<span class="hljs-number">3</span>))<br><span class="hljs-comment">// make a special Adder function, a gets value 2:</span><br>TwoAdder := Adder(<span class="hljs-number">2</span>)<br>fmt.Printf(<span class="hljs-string">&quot;The result is: %v\n&quot;</span>, TwoAdder(<span class="hljs-number">3</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add2</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> b + <span class="hljs-number">2</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Adder</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面这个实例是另外一种写法实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f = Adder()<br>fmt.Print(f(<span class="hljs-number">1</span>), <span class="hljs-string">&quot; - &quot;</span>)<br>fmt.Print(f(<span class="hljs-number">20</span>), <span class="hljs-string">&quot; - &quot;</span>)<br>fmt.Print(f(<span class="hljs-number">300</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Adder</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(delta <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>x += delta<br><span class="hljs-keyword">return</span> x<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用闭包调试"><a href="#使用闭包调试" class="headerlink" title="使用闭包调试"></a>使用闭包调试</h2><p>在分析和调试复杂程序时，无数个函数在代码之间相互调用，如果能准确知道哪个文件中哪个函数在运行会对分析有很大的帮助。可以使用 <code>runtime</code> 或 <code>log</code> 包中的特殊函数来实现这样的功能。包 <code>runtime</code> 中的函数 <code>Caller()</code> 提供了相应的信息，因此可以在需要的时候实现一个 <code>where()</code> 闭包函数来打印函数执行的位置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">where := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>_, file, line, _ := runtime.Caller(<span class="hljs-number">1</span>)<br>log.Printf(<span class="hljs-string">&quot;%s:%d&quot;</span>, file, line)<br>&#125;<br>where()<br><span class="hljs-comment">// some code</span><br>where()<br><span class="hljs-comment">// some more code</span><br>where()<br></code></pre></td></tr></table></figure><p>也可以设置<code>log</code>包中的<code>flag</code>参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">log.SetFlags(log.Llongfile)<br>log.Print(<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p>或使用更精简版的<code>where()</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> where = log.Print<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span> &#123;<br>where()<br>... some code<br>where()<br>... some code<br>where()<br>&#125;<br></code></pre></td></tr></table></figure><p>这部分还是等后面再深入学吧🤣，咱连很多基础内容都没学呢。</p><p>得嘞，今儿就到这吧，bye~</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>go</tag>
      
      <tag>函数</tag>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——栈</title>
    <link href="/2024/08/08/leetcode-%E6%A0%88/"/>
    <url>/2024/08/08/leetcode-%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20 有效的括号"></a>20 有效的括号</h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li><p>左括号必须用相同类型的右括号闭合。</p></li><li><p>左括号必须以正确的顺序闭合。</p></li><li><p>每个右括号都有一个对应的相同类型的左括号。</p></li></ol><p>示例 1：</p><pre><code class="hljs">输入：s = &quot;()&quot;输出：true</code></pre><p>示例 2：</p><pre><code class="hljs">输入：s = &quot;()[]&#123;&#125;&quot;输出：true</code></pre><p>示例 3：</p><pre><code class="hljs">输入：s = &quot;(]&quot;输出：false</code></pre><p>提示：</p><p><code>1 &lt;= s.length &lt;= 104</code></p><p><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题基本上都多多少少做过、听过，思路基本上就是一个，遇到括号左边压入栈，遇到括号右边就匹配，成功就弹出栈顶失败就false</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        stack = []<br>        dic = &#123;<span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>:<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>:<span class="hljs-string">&#x27;&#125;&#x27;</span>&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> dic:<br>                stack.append(i)<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> dic[stack.pop()] != i:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间43ms，消耗内存16.5MB</p><h1 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71 简化路径"></a>71 简化路径</h1><p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 <code>Unix</code> 风格 <strong>绝对路径</strong> （以 <code>&#39;/&#39;</code> 开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>&#39;//&#39;</code>）都被视为单个斜杠 <code>&#39;/&#39; </code>。 对于此问题，任何其他格式的点（例如，’<code>...</code>‘）均被视为文件&#x2F;目录名称。</p><p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p><p>始终以斜杠 <code>&#39;/&#39;</code> 开头。<br>两个目录名之间必须只有一个斜杠 <code>&#39;/&#39;</code> 。<br>最后一个目录名（如果存在）不能 以 <code>&#39;/&#39;</code> 结尾。<br>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘<code>.</code>‘ 或 ‘<code>..</code>‘）。<br>返回简化后得到的 <strong>规范路径</strong> 。</p><p>示例 1：</p><pre><code class="hljs">输入：path = &quot;/home/&quot;输出：&quot;/home&quot;解释：注意，最后一个目录名后面没有斜杠。 </code></pre><p>示例 2：</p><pre><code class="hljs">输入：path = &quot;/../&quot;输出：&quot;/&quot;解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</code></pre><p>示例 3：</p><pre><code class="hljs">输入：path = &quot;/home//foo/&quot;输出：&quot;/home/foo&quot;解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</code></pre><p>示例 4：</p><pre><code class="hljs">输入：path = &quot;/a/./b/../../c/&quot;输出：&quot;/c&quot;</code></pre><p>提示：</p><p><code>1 &lt;= path.length &lt;= 3000</code></p><p><code>path</code> 由英文字母，数字，<code>&#39;.&#39;</code>，<code>&#39;/&#39;</code> 或 <code>&#39;_&#39;</code> 组成。</p><p><code>path</code> 是一个有效的 Unix 风格绝对路径。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先将所有的<code>/</code>给去掉，然后在我们没遇到<code>&#39; &#39;</code>, <code>&#39;.&#39;</code>, <code>&#39;..&#39;</code>时就会直接压入当前元素，然后当我们遇到<code>&#39;..&#39;</code>就直接将栈顶元素弹出，因为要返回上一级。最后用<code>/</code>连接每个字符并在最前面添加一个<code>/</code></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">simplifyPath</span>(<span class="hljs-params">self, path: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        stack = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> path.split(<span class="hljs-string">&#x27;/&#x27;</span>):<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;..&#x27;</span> <span class="hljs-keyword">and</span> stack:<br>                stack.pop()<br>            <span class="hljs-keyword">elif</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;..&#x27;</span>]:<br>                stack.append(i)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;/&#x27;</span> + <span class="hljs-string">&#x27;/&#x27;</span>.join(stack)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间49ms，消耗内存16.3MB</p><h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155 最小栈"></a>155 最小栈</h1><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><p><code>MinStack()</code> 初始化堆栈对象。<br><code>void push(int val)</code> 将元素val推入堆栈。<br><code>void pop()</code> 删除堆栈顶部的元素。<br><code>int top()</code> 获取堆栈顶部的元素。<br><code>int getMin()</code> 获取堆栈中的最小元素。</p><p>示例 1:</p><p>输入：</p><pre><code class="hljs">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]</code></pre><p>输出：</p><pre><code class="hljs">[null,null,null,null,-3,null,0,-2] </code></pre><p>解释：</p><pre><code class="hljs">MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre><p>提示：</p><p><code>-231 &lt;= val &lt;= 231 - 1</code></p><p><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</p><p><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 104</code> 次</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这里基本上都是采用辅助栈的形式去做，做法其实大差不差</p><p>四个函数分别说一下</p><p><code>push</code>，每当我们push一个新值进来，如果小于等于辅助栈的栈顶则一起push到辅助栈，也就更新了最小值</p><p><code>pop</code>，如果栈顶和辅助栈的栈顶一样，两个都pop，保证最小值在辅助栈中</p><p><code>top</code>，返回主栈栈顶元素</p><p><code>getMin</code>，返回辅助栈栈顶元素也即最小值</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span>:<br>    <span class="hljs-comment"># 初始化两个栈，一个用于存储所有元素，另一个用于存储最小元素</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.stack = []<br>        <span class="hljs-variable language_">self</span>.min_stack = []<br><br>    <span class="hljs-comment"># 向栈中添加元素，并更新最小元素栈</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-variable language_">self</span>.stack.append(val)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.min_stack <span class="hljs-keyword">or</span> val &lt;= <span class="hljs-variable language_">self</span>.min_stack[-<span class="hljs-number">1</span>]:<br>            <span class="hljs-variable language_">self</span>.min_stack.append(val)<br><br>    <span class="hljs-comment"># 从栈中移除元素，并更新最小元素栈</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        x = <span class="hljs-variable language_">self</span>.stack.pop()<br>        <span class="hljs-keyword">if</span> x == <span class="hljs-variable language_">self</span>.min_stack[-<span class="hljs-number">1</span>]:<br>            <span class="hljs-variable language_">self</span>.min_stack.pop()<br><br>    <span class="hljs-comment"># 获取栈顶元素</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.stack[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-comment"># 获取栈中的最小元素</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMin</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.min_stack[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(1)，执行时间59ms，消耗内存20MB</p><p>这里容易有一个误区就是pop的时候我们把辅助栈的最小元素给pop了，那么我们是不是就没有辅助栈了呢。并不是，辅助栈也是会被更新的，如果我们在pop的下一个就需要运行getMin了，那得到的就肯定为空了。当我们在后续还有新的push，那必然获得的就不是这个为空的了。</p><h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150 逆波兰表达式求值"></a>150 逆波兰表达式求值</h1><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p>注意：</p><p>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</p><p>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</p><p>两个整数之间的除法总是 <strong>向零截断</strong> 。</p><p>表达式中不含除零运算。</p><p>输入是一个根据逆波兰表示法表示的算术表达式。</p><p>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</p><p>示例 1：</p><pre><code class="hljs">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]输出：9解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</code></pre><p>示例 2：</p><pre><code class="hljs">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]输出：6解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</code></pre><p>示例 3：</p><pre><code class="hljs">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]输出：22解释：该算式转化为常见的中缀算术表达式为：((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22</code></pre><p>提示：</p><p><code>1 &lt;= tokens.length &lt;= 104</code></p><p><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</p><p>逆波兰表达式：</p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><p>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</p><p>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</p><p>逆波兰表达式主要有以下两个优点：</p><p>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + *</code> 也可以依据次序计算出正确结果。</p><p>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先第一个需要理解的点是逆波兰表达式是一个后缀表达式，所以我们可以先将后缀表达式转换为逆波兰表达式，并计算结果。而我们常用的计算式是中缀表达式，所以明白了这点就可以大概构思出怎么做。</p><p>接下来我们需要想到几个问题。</p><p>第一当用例中出现负数怎么办，负数我们可以直接转换为<code>-</code> + <code>num</code>这样就变相的改成了计算式，然后数字直接int为整数就行。</p><p>第二，当我们看到题目中的第三条时会有一个很无语的事情，就是除法需要 <strong>向零截断</strong>，而python的除余结果是直接向下取整。然而，在我们第一步的操作后，我们直接解决了这个问题，唯一需要注意的是我们除式的结果需要转化为int型变量</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">evalRPN</span>(<span class="hljs-params">self, tokens: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        stack = []<br>        dic = &#123;<span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">lambda</span> x,y:x+y, <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">lambda</span> x,y:x-y, <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">lambda</span> x,y:x*y, <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">lambda</span> x,y:<span class="hljs-built_in">int</span>(x/y)&#125;<br>        <span class="hljs-comment"># 定义一个字典dic，存储运算符和对应的lambda函数，用于执行相应的算术操作</span><br>        <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> tokens:<br>            <span class="hljs-comment"># 遍历tokens列表中的每一个token</span><br>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">in</span> dic:<br>                <span class="hljs-comment"># 如果token是运算符</span><br>                y = stack.pop()<br>                x = stack.pop()<br>                <span class="hljs-comment"># 从stack中弹出两个操作数</span><br>                stack.append(dic[token](x,y))<br>                <span class="hljs-comment"># 执行相应的算术操作，并将结果压入stack</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 如果token是操作数</span><br>                stack.append(<span class="hljs-built_in">int</span>(token))<br>                <span class="hljs-comment"># 将token转换为整数并压入stack</span><br>        <span class="hljs-keyword">return</span> stack[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># 返回stack中唯一的元素，即逆波兰表达式的计算结果</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间40ms，消耗内存18.2MB</p><h1 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224 基本计算器"></a>224 基本计算器</h1><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval() </code>。</p><p>示例 1：</p><pre><code class="hljs">输入：s = &quot;1 + 1&quot;输出：2</code></pre><p>示例 2：</p><pre><code class="hljs">输入：s = &quot; 2-1 + 2 &quot;输出：3</code></pre><p>示例 3：</p><pre><code class="hljs">输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;输出：23</code></pre><p>提示：</p><p><code>1 &lt;= s.length &lt;= 3 * 105</code></p><p><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</p><p><code>s</code> 表示一个有效的表达式</p><p><code>&#39;+&#39;</code> 不能用作一元运算(例如， <code>&quot;+1&quot;</code> 和 <code>&quot;+(2 + 3)&quot;</code> 无效)</p><p><code>&#39;-&#39;</code> 可以用作一元运算(即 <code>&quot;-1&quot;</code> 和 <code>&quot;-(2 + 3)&quot;</code> 是有效的)</p><p>输入中不存在两个连续的操作符</p><p>每个数字和运行的计算将适合于一个有符号的 <strong>32位</strong> 整数</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这个问题的核心是如何处理加减法运算，并正确处理括号内的优先级。我们可以通过以下步骤来解决问题：</p><ol><li><p>符号转换：我们将 <code>+</code> 用 <code>1</code> 表示，将 <code>-</code> 用 <code>-1</code> 表示。这样，当遇到加减号时，可以通过将当前数字乘以符号值来简化运算过程。</p></li><li><p>处理括号：当遇到左括号 <code>(</code> 时，需要将当前的计算结果和运算符号压入栈中，保存当前的运算状态。这是因为括号内的运算结果会影响括号外的结果。遇到右括号 <code>)</code> 时，需要弹出栈顶的运算符号和结果，并将括号内的计算结果与之相结合。</p></li></ol><p>示例<br>例如对于表达式 <code>(1+(4+5+2)-3)+(6+8)</code>，我们首先处理最内层的括号，然后逐步将结果合并到外层的运算中。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        stack = []<br>        num = <span class="hljs-number">0</span><br>        sign = <span class="hljs-number">1</span>  <span class="hljs-comment"># 1表示加号，-1表示减号</span><br>        result = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> char.isdigit():<br>                num = num * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(char)<br>            <span class="hljs-keyword">elif</span> char == <span class="hljs-string">&#x27;+&#x27;</span>:<br>                result += sign * num<br>                num = <span class="hljs-number">0</span><br>                sign = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> char == <span class="hljs-string">&#x27;-&#x27;</span>:<br>                result += sign * num<br>                num = <span class="hljs-number">0</span><br>                sign = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> char == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                stack.append(result)<br>                stack.append(sign)<br>                result = <span class="hljs-number">0</span><br>                sign = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> char == <span class="hljs-string">&#x27;)&#x27;</span>:<br>                result += sign * num<br>                num = <span class="hljs-number">0</span><br>                result *= stack.pop()  <span class="hljs-comment"># 乘以括号前的符号</span><br>                result += stack.pop()  <span class="hljs-comment"># 加上括号前的结果</span><br>        <br>        <span class="hljs-comment"># 处理最后一个数字</span><br>        result += sign * num<br>        <br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度：O(n)，执行时间57ms，消耗内存16.9MB</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go学习记录——第二天</title>
    <link href="/2024/08/08/go-study-second-day/"/>
    <url>/2024/08/08/go-study-second-day/</url>
    
    <content type="html"><![CDATA[<p>今儿继续学go，争取多学点吧，不过感觉困死了，不一定能学多少。</p><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p>惊奇的发现go是没有while循环的，全靠for实现</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>一共三种形式</p><ol><li><code>for init; condition; post &#123;&#125;</code></li><li><code>for condition &#123;&#125;</code></li><li><code>for &#123;&#125;</code></li></ol><p>第一种就是和C差不多的，初始化；条件；后置语句，用来控制循环的次数</p><p>第二种类似于while</p><p>第三种用来无限循环，直到遇到break</p><p>for循环还能对map、slice、数组、字符串进行迭代循环，语法如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> oldMap &#123;<br>    newMap[key] = value<br>&#125;<br></code></pre></td></tr></table></figure><p>其中key和value都是可以省略的，省略的话就只会迭代key，或者只会迭代value</p><p>如果想只读key</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> oldMap<br></code></pre></td></tr></table></figure><p>如果想只读value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> oldMap<br></code></pre></td></tr></table></figure><h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><p>和别的一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> [condition |  ( init; condition; increment ) | Range]<br>&#123;<br>   <span class="hljs-keyword">for</span> [condition |  ( init; condition; increment ) | Range]<br>   &#123;<br>      statement(s)<br>   &#125;<br>   statement(s)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p><code>for</code> 和 <code>switch</code> 都可以用</p><p>唯一需要注意啊的是break和别的不同的一点是可以添加<code>label</code>也就是标签。使用时可以添加在最前面就比如下面这个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>outerLoop: <span class="hljs-comment">// 定义一个名为 outerLoop 的标签</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++ &#123;<br><span class="hljs-keyword">if</span> j == <span class="hljs-number">3</span> &#123;<br><span class="hljs-keyword">break</span> outerLoop <span class="hljs-comment">// 跳出 outerLoop 标签的循环</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;i=%d, j=%d\n&quot;</span>, i, j)<br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;循环结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用outerLoop标记了两层循环，最后跳出循环后继续走下面的代码</p><p>switch和select都可以用break，但通常都用于最后一个case。但select中如果想使用break，虽然可以但理论上由于是非阻塞式循环，是在所有通道匹配后才会输出，break就会影响这个效果。所以通常使用return或goto来跳出循环。</p><p>但这里还有一个问题，由于goto是直接直接去到标记的位置，所以对select来说其实会影响代码的可读性，所以通常还是用return。关于goto后面还会有内容。</p><p>return的例子如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>c2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(time.Second)<br>c1 &lt;- <span class="hljs-number">1</span><br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>c2 &lt;- <span class="hljs-string">&quot;hello&quot;</span><br>&#125;()<br><br><span class="hljs-comment">// 使用 return 跳出 select 语句</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> v := &lt;-c1:<br>fmt.Println(<span class="hljs-string">&quot;received from c1:&quot;</span>, v)<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// 退出函数</span><br><span class="hljs-keyword">case</span> v := &lt;-c2:<br>fmt.Println(<span class="hljs-string">&quot;received from c2:&quot;</span>, v)<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// 退出函数</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>和别的没什么区别</p><p>唯一需要注意的不同就是label</p><p>go的continue也可以使用label去进行操作，例子如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>outerLoop: <span class="hljs-comment">// 定义一个名为 outerLoop 的标签</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++ &#123;<br><span class="hljs-keyword">if</span> j == <span class="hljs-number">3</span> &#123;<br><span class="hljs-keyword">continue</span> outerLoop <span class="hljs-comment">// 跳过当前外层循环的剩余迭代</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;i=%d, j=%d\n&quot;</span>, i, j)<br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;循环结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><p>goto就像前面说的，无条件直达某个位置，这也就导致了代码的结构性和可读性变差，所以能不用就不用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">goto</span> label;<br>..<br>.<br>label: statement;<br></code></pre></td></tr></table></figure><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 定义局部变量 */</span><br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br><br>   <span class="hljs-comment">/* 循环 */</span><br>   LOOP: <span class="hljs-keyword">for</span> a &lt; <span class="hljs-number">20</span> &#123;<br>      <span class="hljs-keyword">if</span> a == <span class="hljs-number">15</span> &#123;<br>         <span class="hljs-comment">/* 跳过迭代 */</span><br>         a = a + <span class="hljs-number">1</span><br>         <span class="hljs-keyword">goto</span> LOOP<br>      &#125;<br>      fmt.Printf(<span class="hljs-string">&quot;a的值为 : %d\n&quot;</span>, a)<br>      a++     <br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-literal">true</span>  &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;这是无限循环。\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>和别的一样，概念没啥好说的</p><p>函数格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function_name</span><span class="hljs-params">( [parameter list] )</span></span> [return_types] &#123;<br>   函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>func：函数从<code>func</code>开始声明<br>function_name：函数名称<br>parameter list：参数列表<br>return_types：返回类型，可以省略<br>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 函数返回两个数的最大值 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(num1, num2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-comment">/* 声明局部变量 */</span><br>   <span class="hljs-keyword">var</span> result <span class="hljs-type">int</span><br><br>   <span class="hljs-keyword">if</span> (num1 &gt; num2) &#123;<br>      result = num1<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      result = num2<br>   &#125;<br>   <span class="hljs-keyword">return</span> result <br>&#125;<br></code></pre></td></tr></table></figure><p>函数调用和python没区别，一个道理</p><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数参数依旧是形参非实参</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 定义相互交换值的函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br><br>   temp = x <span class="hljs-comment">/* 保存 x 的值 */</span><br>   x = y    <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>   y = temp <span class="hljs-comment">/* 将 temp 值赋给 y*/</span><br><br>   <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终如果调用函数，则函数内将交换值，但全局变量并不会变。</p><h2 id="引用传递值"><a href="#引用传递值" class="headerlink" title="引用传递值"></a>引用传递值</h2><p>这里用到指针进行操作，由于指针指向的是实际存储地址，所以在交换后将直接对变量所指向的地址进行改变，进而改变变量值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 定义交换值函数*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x *<span class="hljs-type">int</span>, y *<span class="hljs-type">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br>   temp = *x    <span class="hljs-comment">/* 保持 x 地址上的值 */</span><br>   *x = *y      <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>   *y = temp    <span class="hljs-comment">/* 将 temp 值赋给 y */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数作为实参"><a href="#函数作为实参" class="headerlink" title="函数作为实参"></a>函数作为实参</h2><p>go中可以将函数直接传递给某个变量而作为实参</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-comment">/* 声明函数变量 */</span><br>   getSquareRoot := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>      <span class="hljs-keyword">return</span> math.Sqrt(x)<br>   &#125;<br><br>   <span class="hljs-comment">/* 使用函数 */</span><br>   fmt.Println(getSquareRoot(<span class="hljs-number">9</span>))<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包（匿名函数）"><a href="#闭包（匿名函数）" class="headerlink" title="闭包（匿名函数）"></a>闭包（匿名函数）</h2><p>匿名函数是一个“内联”语句或表达式，优点在于可以直接使用函数内的变量，不用声明。</p><p>匿名函数是无需命名的函数，可以被赋值给变量，方便后续调用。它们可以访问定义时的外部变量，但只访问了这些变量的副本，不会改变外部变量的值。</p><p>当调用匿名函数并传递参数时，参数会覆盖函数内部的同名变量，函数执行完毕后，这些参数会恢复到初始状态。</p><p>匿名函数的优势在于可以方便地创建临时函数，避免重复代码。</p><p>闭包是匿名函数的一个重要特性，它允许匿名函数访问外部变量，即使外部函数已经执行完毕。这里访问的是外部变量的初始参数，而不是副本。</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getSequence</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>   i:=<span class="hljs-number">0</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>      i+=<span class="hljs-number">1</span><br>     <span class="hljs-keyword">return</span> i  <br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-comment">/* nextNumber 为一个函数，函数 i 为 0 */</span><br>   nextNumber := getSequence()  <br><br>   <span class="hljs-comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span><br>   fmt.Println(nextNumber())<br>   fmt.Println(nextNumber())<br>   fmt.Println(nextNumber())<br>   <br>   <span class="hljs-comment">/* 创建新的函数 nextNumber1，并查看结果 */</span><br>   nextNumber1 := getSequence()  <br>   fmt.Println(nextNumber1())<br>   fmt.Println(nextNumber1())<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">output:</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>go中除了函数还有方法，是与特定类型（结构体、接口等）关联的函数，将接收者作为函数的第一个参数。接收者可以是值类型（值拷贝）或指针类型（指针引用）。方法调用时，会将接收者作为第一个参数传递给方法函数，然后方法函数会根据接收者的值或指针进行计算。</p><p>方法的声明格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(variable_name variable_data_type)</span></span> function_name() [return_type]&#123;<br>   <span class="hljs-comment">/* 函数体*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Rectangle <span class="hljs-keyword">struct</span> &#123;<br>Width  <span class="hljs-type">int</span><br>Height <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 方法：计算矩形的面积</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r Rectangle)</span></span> Area() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> r.Width * r.Height<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>rect := Rectangle&#123;Width: <span class="hljs-number">10</span>, Height: <span class="hljs-number">5</span>&#125;<br>area := rect.Area() <span class="hljs-comment">// 调用方法</span><br>fmt.Println(<span class="hljs-string">&quot;面积:&quot;</span>, area) <span class="hljs-comment">// 输出：面积: 50</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Area</code> 方法与 <code>Rectangle</code> 类型关联。当调用 <code>rect.Area()</code> 时，<code>rect</code> 作为接收者被传递给 <code>Area</code> 方法，方法内部使用 <code>r.Width</code> 和 <code>r.Height</code> 计算面积。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>方法是与特定类型关联的函数。</li><li>方法的第一个参数是接收者，可以是值类型或指针类型。</li><li>方法调用时，会将接收者作为第一个参数传递给方法函数。</li><li>方法函数会根据接收者的值或指针进行计算。</li></ul><h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>作用域控制代码中各种元素的使用范围，如包、结构体、变量、函数、方法、常量</p><p>具体来看可以分成三个</p><ul><li>局部变量——函数级作用域</li><li>全局变量——包级作用域</li><li>块级作用域</li><li>形参变量——函数参数</li></ul><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>函数内定义的变量称为局部变量，参数和返回值均为局部变量</p><p>变量用<code>var</code>定义</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 声明局部变量 */</span><br>   <span class="hljs-keyword">var</span> a, b, c <span class="hljs-type">int</span> <br><br>   <span class="hljs-comment">/* 初始化参数 */</span><br>   a = <span class="hljs-number">10</span><br>   b = <span class="hljs-number">20</span><br>   c = a + b<br><br>   fmt.Printf (<span class="hljs-string">&quot;结果： a = %d, b = %d and c = %d\n&quot;</span>, a, b, c)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>函数外定义的变量称为全局变量全局变量可以在整个包（甚至包导出后）使用</p><p>变量用<code>var</code>定义，在包的顶部定义</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">/* 声明全局变量 */</span><br><span class="hljs-keyword">var</span> g <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>   <span class="hljs-comment">/* 声明局部变量 */</span><br>   <span class="hljs-keyword">var</span> a, b <span class="hljs-type">int</span><br><br>   <span class="hljs-comment">/* 初始化参数 */</span><br>   a = <span class="hljs-number">10</span><br>   b = <span class="hljs-number">20</span><br>   g = a + b<br><br>   fmt.Printf(<span class="hljs-string">&quot;结果： a = %d, b = %d and g = %d\n&quot;</span>, a, b, g)<br>&#125;<br></code></pre></td></tr></table></figure><p>在整个代码中，全局变量和局部变量的名称可以是一样的，但在函数内优先使用局部变量。这个和别的是一样的</p><h2 id="形参变量"><a href="#形参变量" class="headerlink" title="形参变量"></a>形参变量</h2><p>形参变量只能在函数内使用，一般作为函数内的局部变量使用</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>在代码块（<code>for</code>, <code>if</code>, <code>switch</code> 等）中，变量的作用范围为这个代码块。</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br>        blockVar := <span class="hljs-number">30</span> <span class="hljs-comment">// 块级作用域</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>今天就到这里吧，虽然但是，总感觉最近学习状态好差，得想办法调整调整了。</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>go</tag>
      
      <tag>循环语句</tag>
      
      <tag>函数</tag>
      
      <tag>变量作用域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go学习记录——第一天</title>
    <link href="/2024/08/07/go-study-first-day/"/>
    <url>/2024/08/07/go-study-first-day/</url>
    
    <content type="html"><![CDATA[<h1 id="go的基本组成部分"><a href="#go的基本组成部分" class="headerlink" title="go的基本组成部分"></a>go的基本组成部分</h1><ul><li>包声明</li><li>引入包</li><li>函数</li><li>变量</li><li>语句 &amp; 表达式</li><li>注释</li></ul><h1 id="go变量声明"><a href="#go变量声明" class="headerlink" title="go变量声明"></a>go变量声明</h1><p>go中用var来声明变量，语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> variableName dataType<br></code></pre></td></tr></table></figure><p>其中，variableName为变量名，dataType为变量的数据类型。</p><p>一次声明多个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    variable1 dataType1<br>    variable2 dataType2<br>    variable3 dataType3<br>)<br></code></pre></td></tr></table></figure><p>第一种，指定变量类型，如果没有初始化则默认为0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v_name v_type<br>v_name = value<br>或<br><span class="hljs-keyword">var</span> v_name v_type = value<br></code></pre></td></tr></table></figure><p>第二种，不指定类型，由编译器自动推导</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v_name = value<br></code></pre></td></tr></table></figure><p>第三种，短变量声明，在函数内使用，注意当已经进行了变量声明再使用短声明会报错。短声明只适用于函数内使用，不能在全局作用域使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">v_name := value<br></code></pre></td></tr></table></figure><p>第四种，多变量声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    v1, v2, v3 = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;hello&quot;</span><br>)<br>或<br><span class="hljs-keyword">var</span> v1, v2, v3 = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-comment">// 这个为主使用，和python类似，迁移起来较快</span><br>或<br>v1, v2, v3 := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><h1 id="go常量声明"><a href="#go常量声明" class="headerlink" title="go常量声明"></a>go常量声明</h1><p>只能使用布尔型、数字型（int, float, 复数）和字符串型</p><p>常量定义格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> constantName  [<span class="hljs-keyword">type</span>]= value<br></code></pre></td></tr></table></figure><p>多个常量声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> constantName1, constantName2 = value1, value2<br></code></pre></td></tr></table></figure><p>常量中可以使用内置函数进行运算，如len(), cap(), unsafe.Sizeof()等。</p><h2 id="inta"><a href="#inta" class="headerlink" title="inta"></a>inta</h2><p>inta是go中的特殊常量，可以当作一个可以被编译成功的常量</p><p>inta在const关键词出现时将被重置为0，const中每加一行都将使inta加1。</p><p>inta可以做枚举值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    a = inta<br>    b = inta<br>    c = inta<br>)<br></code></pre></td></tr></table></figure><p>inta也可以做一个类似行索引的功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    a = inta<br>    b<br>    c<br>)<br></code></pre></td></tr></table></figure><p>输出的结果就是<code>a=0, b=1, c=2</code>。</p><p>inta用法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>a = <span class="hljs-literal">iota</span><br>b<br>c<br>d = <span class="hljs-string">&quot;ha&quot;</span><br>e<br>f = <span class="hljs-number">100</span><br>g<br>h = <span class="hljs-literal">iota</span><br>i<br>)<br><br>fmt.Println(a, b, c, d, e, f, g, h, i)<br>&#125;<br><span class="hljs-comment">// output：</span><br><span class="hljs-comment">// 0 1 2 ha 4 100 6 7 8</span><br></code></pre></td></tr></table></figure><h1 id="go的运算符"><a href="#go的运算符" class="headerlink" title="go的运算符"></a>go的运算符</h1><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><ol><li><p>++ 自增，和+&#x3D;1类似</p></li><li><p>– 自减，和-&#x3D;1类似</p></li></ol><p>别的和python一样</p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>和python一样，直接忽略</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ol><li><p>&amp;&amp; -&gt; and</p></li><li><p>|| -&gt; or</p></li><li><p>!  -&gt; not</p></li></ol><p>从字母换成了符号，其他没区别</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ol><li><p>&amp;  -&gt; 按位与</p></li><li><p>|  -&gt; 按位或</p></li><li><p>^  -&gt; 按位异或</p></li><li><p>&lt;&lt; -&gt; 左移</p></li><li><blockquote><blockquote><p>-&gt; 右移</p></blockquote></blockquote></li><li><p>~  -&gt; 按位取反</p></li></ol><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ol><li>&lt;&lt;&#x3D; -&gt; 左移后赋值</li><li><blockquote><blockquote><p>&#x3D; -&gt; 右移后赋值</p></blockquote></blockquote></li><li>&amp;&#x3D;  -&gt; 按位与后赋值</li><li>|&#x3D;  -&gt; 按位或后赋值</li><li>^&#x3D;  -&gt; 按位异或后赋值</li></ol><p>其他和python一样</p><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><ol><li>&amp; -&gt; 返回实际地址</li><li>‘*’  -&gt; 指针变量</li></ol><h2 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h2><table><thead><tr><th>优先级</th><th>运算符</th></tr></thead><tbody><tr><td>1 一元运算符</td><td>*   &amp;（取地址） +（正号） -（负号）! ~（按位异或）</td></tr><tr><td>2 乘除类运算符</td><td>*  &#x2F;  %  &lt;&lt;  &gt;&gt; &amp;（按位与） &amp;^（按位清除）</td></tr><tr><td>3 加减类运算符</td><td>+  - ‘</td></tr><tr><td>4 关系运算符</td><td>&#x3D;&#x3D; !&#x3D;  &lt;  &lt;&#x3D;  &gt;  &gt;&#x3D;</td></tr><tr><td>5 逻辑运算符</td><td>&amp;&amp;  逻辑或（符号markdown无法显示就用文字代替了）</td></tr></tbody></table><h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><p>和python一样，但编写方式有些不同</p><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 布尔表达式 &#123;<br>   <span class="hljs-comment">/* 在布尔表达式为 true 时执行 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 布尔表达式 &#123;<br>   <span class="hljs-comment">/* 在布尔表达式为 true 时执行 */</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">/* 在布尔表达式为 false 时执行 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="if…else-if…else"><a href="#if…else-if…else" class="headerlink" title="if…else if…else"></a>if…else if…else</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 布尔表达式<span class="hljs-number">1</span> &#123;<br>   <span class="hljs-comment">/* 在布尔表达式1为 true 时执行 */</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> 布尔表达式<span class="hljs-number">2</span> &#123;<br>   <span class="hljs-comment">/* 在布尔表达式2为 true 时执行 */</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">/* 在布尔表达式1和表达式2都为 false 时执行 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> 表达式 &#123;<br>   <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:<br>      <span class="hljs-comment">/* 当表达式的值等于值1时执行 */</span><br>      <span class="hljs-keyword">break</span><br>   <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>      <span class="hljs-comment">/* 当表达式的值等于值2时执行 */</span><br>      <span class="hljs-keyword">break</span><br>   <span class="hljs-keyword">default</span>:<br>      <span class="hljs-comment">/* 当以上都不满足时执行 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Type-Swith"><a href="#Type-Swith" class="headerlink" title="Type Swith"></a>Type Swith</h3><p>用于判断某个interface变量的实际类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> x.(<span class="hljs-keyword">type</span>)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-keyword">type</span>:<br>       statement(s);      <br>    <span class="hljs-keyword">case</span> <span class="hljs-keyword">type</span>:<br>       statement(s); <br>    <span class="hljs-comment">/* 你可以定义任意个数的case */</span><br>    <span class="hljs-keyword">default</span>: <span class="hljs-comment">/* 可选 */</span><br>       statement(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>例子如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125;<br>     <br>   <span class="hljs-keyword">switch</span> i := x.(<span class="hljs-keyword">type</span>) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:   <br>         fmt.Printf(<span class="hljs-string">&quot; x 的类型 :%T&quot;</span>,i)                <br>      <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:   <br>         fmt.Printf(<span class="hljs-string">&quot;x 是 int 型&quot;</span>)                       <br>      <span class="hljs-keyword">case</span> <span class="hljs-type">float64</span>:<br>         fmt.Printf(<span class="hljs-string">&quot;x 是 float64 型&quot;</span>)           <br>      <span class="hljs-keyword">case</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">float64</span>:<br>         fmt.Printf(<span class="hljs-string">&quot;x 是 func(int) 型&quot;</span>)                      <br>      <span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>, <span class="hljs-type">string</span>:<br>         fmt.Printf(<span class="hljs-string">&quot;x 是 bool 或 string 型&quot;</span> )       <br>      <span class="hljs-keyword">default</span>:<br>         fmt.Printf(<span class="hljs-string">&quot;未知型&quot;</span>)     <br>   &#125;   <br>&#125;<br><br>output:<br>x 的类型 : &lt;<span class="hljs-literal">nil</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="fullthrough"><a href="#fullthrough" class="headerlink" title="fullthrough"></a>fullthrough</h3><p>强制执行case后语句，不会判断是否为true<br>即使用了fullthrough，也可以直接用break跳出switch</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>此select非彼select。不是SQL中的那个查看</p><p>这里的select虽然类似switch，但只能作用于通道，一个case只能进行接受或发送</p><p>select会监听每个通道，只要有一个case准备好了就立马执行。如果多个准备好就随机挑选一个。如果一个都没准备好执行default。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br>  <span class="hljs-keyword">case</span> &lt;- channel1:<br>    <span class="hljs-comment">// 执行的代码</span><br>  <span class="hljs-keyword">case</span> value := &lt;- channel2:<br>    <span class="hljs-comment">// 执行的代码</span><br>  <span class="hljs-keyword">case</span> channel3 &lt;- value:<br>    <span class="hljs-comment">// 执行的代码</span><br><br>    <span class="hljs-comment">// 你可以定义任意数量的 case</span><br><br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 所有通道都没有准备好，执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意</p><ul><li>每一个case都必须对应一个通道</li><li>所有channel表达式都会被求值</li><li>所有被发送的表达式都会被求值</li><li>如果有default则会在case均未准备好时执行。如果没有则会阻塞，直到有通道可以运行。Go不会重新对channel或值进行求值</li></ul><p>今儿的就学到这里吧，感觉上在语句写法上和C类似。不过可能是我一直用Python所以还有点不习惯用花括号来作为代码块的感觉。慢慢习惯吧，今儿没啥心情，感觉学不下去了，休息咯~</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>go</tag>
      
      <tag>基本概念</tag>
      
      <tag>条件语句</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL学习记录——第四天</title>
    <link href="/2024/08/07/postgresql-study-fourth-day/"/>
    <url>/2024/08/07/postgresql-study-fourth-day/</url>
    
    <content type="html"><![CDATA[<h1 id="view"><a href="#view" class="headerlink" title="view"></a>view</h1><p>view是PostgreSQL中非常重要的概念，它可以将多个表的关系组合在一起，并提供一个统一的视图，使得用户可以访问到所需要的数据。</p><p>view并不是一个真正的表，只是一个通过查询语句定义的虚拟表，因此，它并不占用磁盘空间，也不存储数据。</p><p>可以包含一个表中的所有行也可以是指定的一个或多个表选定行</p><p>view可以允许用户实现以下几点</p><ul><li>用户或用户组认为更自然的更直观的查找结构数据的方式</li><li>限制数据访问，用户只能访问到被允许的优先数据而不是完整的表</li><li>汇总数据，将多个表的数据汇总到一个视图中，方便用户查看</li><li>简化复杂的查询，通过view可以简化复杂的查询，使得查询更加简单</li></ul><p>PG的视图是只读，无法进行任何修改操作的，只能查询。</p><h2 id="创建view"><a href="#创建view" class="headerlink" title="创建view"></a>创建view</h2><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [TEMP <span class="hljs-operator">|</span> TEMPORARY] <span class="hljs-keyword">VIEW</span> view_name <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> column1, column2.....<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">condition</span>];<br></code></pre></td></tr></table></figure><p>可以在SELECT语句中包含多个表，与正常SQL的查询语句一样。</p><p>导入表的操作和前文一样</p><p>然后进行如下操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> COMPANY_VIEW <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> ID, NAME, AGE<br><span class="hljs-keyword">FROM</span>  COMPANY;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> COMPANY_VIEW;<br></code></pre></td></tr></table></figure><p>最后结果如下</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coq">id | <span class="hljs-type">name</span>  | <span class="hljs-type">age</span><br>----+-------+-----<br>  <span class="hljs-number">1</span> | <span class="hljs-type">Paul</span>  |  <span class="hljs-type">32</span><br>  <span class="hljs-number">2</span> | <span class="hljs-type">Allen</span> |  <span class="hljs-type">25</span><br>  <span class="hljs-number">3</span> | <span class="hljs-type">Teddy</span> |  <span class="hljs-type">23</span><br>  <span class="hljs-number">4</span> | <span class="hljs-type">Mark</span>  |  <span class="hljs-type">25</span><br>  <span class="hljs-number">5</span> | <span class="hljs-type">David</span> |  <span class="hljs-type">27</span><br>  <span class="hljs-number">6</span> | <span class="hljs-type">Kim</span>   |  <span class="hljs-type">22</span><br>  <span class="hljs-number">7</span> | <span class="hljs-type">James</span> |  <span class="hljs-type">24</span><br>(<span class="hljs-number">7</span> rows)<br></code></pre></td></tr></table></figure><h2 id="删除view"><a href="#删除view" class="headerlink" title="删除view"></a>删除view</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> view_name;    <br></code></pre></td></tr></table></figure><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>终于来到了面试必考环节之一（真的被ACID弄得很烦了，时不时就会被拉出来鞭尸）</p><p>基本概念这里就不说了，和MySQL一样。</p><p>只说几点不同的</p><ul><li>PG完全支持ACID，而MySQL只支持部分ACID特性</li><li>PG的事务默认是关闭自动提交，而MySQL默认是开启自动提交</li><li>PG的事务支持回滚，而MySQL不支持</li><li>PG的隔离等级默认为提交读，而MySQL的隔离等级默认为可重复读</li><li>PG的锁机制更加细致，而MySQL的锁机制更加粗糙</li></ul><p>事务的控制是通过下面几个命令完成的</p><p><code>BEGIN TRANSACTION</code>开始事务</p><p><code>COMMIT</code>提交事务</p><p><code>ROLLBACK</code>回滚事务</p><p>事务控制命令只与 INSERT、UPDATE 和 DELETE 一起使用，他们不能在创建表或删除表时使用。</p><h2 id="BEGIN-TRANSACTION"><a href="#BEGIN-TRANSACTION" class="headerlink" title="BEGIN TRANSACTION"></a>BEGIN TRANSACTION</h2><p>事务可以通过命令开始事务并持续下去，直到遇到下一个<code>COMMIT</code>或<code>ROLLBACK</code>命令。</p><p>下面是一个简单的语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><br>或者<br><br><span class="hljs-keyword">BEGIN</span> TRANSACTION;<br></code></pre></td></tr></table></figure><h2 id="COMMIT"><a href="#COMMIT" class="headerlink" title="COMMIT"></a>COMMIT</h2><p>将事务更改的内容提交到数据库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">COMMIT</span>;<br><br>或者<br><br><span class="hljs-keyword">END</span> TRANSACTION;<br></code></pre></td></tr></table></figure><h2 id="ROLLBACK"><a href="#ROLLBACK" class="headerlink" title="ROLLBACK"></a>ROLLBACK</h2><p>撤销还 <strong>未保存</strong> 的事务，即回滚</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>然后是例子，还是用前面的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">WHERE</span> AGE <span class="hljs-operator">=</span> <span class="hljs-number">25</span>;<br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">WHERE</span> AGE <span class="hljs-operator">=</span> <span class="hljs-number">25</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>关于这部分我都不想说了，S锁X锁，不是考锁和隔离级别的关系就是考锁的类型不然就是考死锁。还有悲观锁乐观锁，这个就遇到过一次，不过看面经好像考察次数确实不是很多。</p><p>概念部分太熟悉了直接跳过</p><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">LOCK [ <span class="hljs-keyword">TABLE</span> ]<br>name<br> <span class="hljs-keyword">IN</span><br>lock_mode<br></code></pre></td></tr></table></figure><p>name是当前要锁定表的名称，如果在表名前指定就是锁当前表，如果为指定则锁表及其子表</p><p>lock_name锁定模式指定和哪个锁冲突，不指定的话会使用限制最大的访问独占模式。</p><p>下面是PG支持的锁定模式</p><ol><li>ACCESS SHARE (AccessShareLock)<ul><li>用于SELECT查询，防止表被删除或结构被修改。</li><li>仅与ACCESS EXCLUSIVE冲突。</li></ul></li><li>ROW SHARE (RowShareLock)<ul><li>用于SELECT … FOR UPDATE和SELECT … FOR SHARE，允许读取和共享行级锁。</li><li>与EXCLUSIVE和ACCESS EXCLUSIVE冲突。</li></ul></li><li>ROW EXCLUSIVE (RowExclusiveLock)<ul><li>用于INSERT、UPDATE、DELETE操作，允许行级修改。</li><li>与SHARE、SHARE ROW EXCLUSIVE、EXCLUSIVE和ACCESS EXCLUSIVE冲突。</li></ul></li><li>SHARE UPDATE EXCLUSIVE (ShareUpdateExclusiveLock)<ul><li>用于VACUUM操作，允许更新但不允许删除。</li><li>与SHARE UPDATE EXCLUSIVE、SHARE、SHARE ROW EXCLUSIVE、5 EXCLUSIVE和ACCESS EXCLUSIVE冲突。</li></ul></li><li>SHARE (ShareLock)<ul><li>用于CREATE INDEX操作，允许共享读取但不允许写入。</li><li>与ROW EXCLUSIVE、EXCLUSIVE和ACCESS EXCLUSIVE冲突。</li></ul></li><li>SHARE ROW EXCLUSIVE (ShareRowExclusiveLock)<ul><li>用于某些DDL操作，允许共享读取但限制写入。</li><li>与ROW EXCLUSIVE、SHARE、SHARE ROW EXCLUSIVE、EXCLUSIVE和ACCESS EXCLUSIVE冲突。</li></ul></li><li>EXCLUSIVE (ExclusiveLock)<ul><li>用于某些DDL操作，允许独占访问。</li><li>与ROW SHARE、ROW EXCLUSIVE、SHARE UPDATE EXCLUSIVE、SHARE、SHARE ROW EXCLUSIVE、EXCLUSIVE和ACCESS EXCLUSIVE冲突。</li></ul></li><li>ACCESS EXCLUSIVE (AccessExclusiveLock)<ul><li>用于ALTER TABLE、DROP TABLE等操作，完全独占访问。</li><li>与所有其他锁定模式冲突。</li></ul></li></ol><p>PG中LOCK语句只在事务模式下才能使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">BEGIN</span>;<br>LOCK <span class="hljs-keyword">TABLE</span> company1 <span class="hljs-keyword">IN</span> ACCESS EXCLUSIVE MODE;<br></code></pre></td></tr></table></figure><p>语句的结果是</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">TABLE</span><br></code></pre></td></tr></table></figure><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>基本一样，不再多说</p><h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><p>除了root用户，其他用户在创建数据库、表、视图等对象时，需要有相应的权限。</p><p>权限的控制是通过GRANT和REVOKE命令完成的。</p><h2 id="GRANT"><a href="#GRANT" class="headerlink" title="GRANT"></a>GRANT</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> privilege [, ...]<br><span class="hljs-keyword">ON</span> object [, ...]<br><span class="hljs-keyword">TO</span> &#123; PUBLIC <span class="hljs-operator">|</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">group</span> <span class="hljs-operator">|</span> username &#125;<br></code></pre></td></tr></table></figure><p>privilege是权限类型，包括SELECT、INSERT、UPDATE、DELETE、TRUNCATE、REFERENCES、TRIGGER、CREATE、CONNECT、TEMPORARY、EXECUTE、USAGE等。</p><p>object是要授予权限的对象，包括数据库、表、视图等。</p><p>PUBLIC是所有用户的公共权限，GROUP是用户组的权限，username是具体的用户名。</p><h2 id="REVOKE"><a href="#REVOKE" class="headerlink" title="REVOKE"></a>REVOKE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> privilege [, ...]<br><span class="hljs-keyword">ON</span> object [, ...]<br><span class="hljs-keyword">FROM</span> &#123; PUBLIC <span class="hljs-operator">|</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">group</span> <span class="hljs-operator">|</span> username &#125;<br></code></pre></td></tr></table></figure><p>REVOKE命令的语法和GRANT命令的语法基本相同，只不过是将GRANT命令变成了REVOKE命令。</p><p>好咯，到这里基本的和稍微进阶一点的操作就都学完了。接下来准备开始学习GO语言和前端三件套了💖。</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL学习记录——第三天</title>
    <link href="/2024/08/06/postgresql-study-third-day/"/>
    <url>/2024/08/06/postgresql-study-third-day/</url>
    
    <content type="html"><![CDATA[<p>今天继续学PG，感觉前面的基本操作还比较快，毕竟用的也不少。到后面稍微开始有点慢了，继续努力吧✌️</p><h1 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h1><p>在表中默认可以输入NULL，但从前面建过的表中就能知道可以指定该列不能驶入输入NULL。</p><p>语法大致如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> COMPANY(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   NAME           TEXT    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   AGE            <span class="hljs-type">INT</span>     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   ADDRESS        <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>   SALARY         <span class="hljs-type">REAL</span><br>);<br></code></pre></td></tr></table></figure><p><code>NOT NULL</code>在使用后将使该列如果没有字段输入将无法更新记录，有<code>NULL</code>的可以不添加字段也能更新记录。</p><p><code>NULL</code>和其他语言里一样都表示空，但空并不是一个数，他是不存在，而<code>0</code>是存在。所以<code>NULL</code>和<code>0</code>是不等价的。</p><p>这里添加的表和上一篇blog中JOIN部分的预先准备一样（因为咱没搭载服务器，没法开下载链接🤣）</p><p>使用下面的命令进行操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> COMPANY <span class="hljs-keyword">SET</span> ADDRESS <span class="hljs-operator">=</span> <span class="hljs-keyword">NULL</span>, SALARY <span class="hljs-operator">=</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">WHERE</span> ID <span class="hljs-keyword">IN</span> (<span class="hljs-number">6</span>, <span class="hljs-number">7</span>);<br></code></pre></td></tr></table></figure><h2 id="IS-NOT-NULL"><a href="#IS-NOT-NULL" class="headerlink" title="IS NOT NULL"></a>IS NOT NULL</h2><p>前面说了空现在说不为空（又莫名想到了leetcode上写if not _）。</p><p>用该命令列出所有薪资不为空的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  ID, NAME, AGE, ADDRESS, SALARY <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">WHERE</span> SALARY <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><h2 id="IS-NULL"><a href="#IS-NULL" class="headerlink" title="IS NULL"></a>IS NULL</h2><p>用下面命令列出为空的记录（直接处刑，把没工资的列出来然后开咯~）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  ID, NAME, AGE, ADDRESS, SALARY <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">WHERE</span> SALARY <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><h1 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h1><p>别名和其他的一样都是用<code>AS</code>去设置，大概写一下语法就进入下一个part</p><p>表的别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2....<br><span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">AS</span> alias_name<br><span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">condition</span>];<br></code></pre></td></tr></table></figure><p>列的别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column_name <span class="hljs-keyword">AS</span> alias_name<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">condition</span>];<br></code></pre></td></tr></table></figure><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>这部分原来没咋用过，目测需要花点时间了</p><p>触发器就是数据库的回调函数，会在指定的数据库事件发生时自动执行&#x2F;调用。</p><p>找资料的时候看到的几个PG的触发器比较重要的点，加了点我自己的理解</p><ul><li>触发器可以在下面几种情况下触发<ul><li>在执行操作之前（在检查约束并尝试插入、删除、更新之前）</li><li>在执行操作之后（在检查约束并插入、删除、更新之后）</li><li>更新操作（在对一个表进行插入、删除、更新时）</li></ul></li><li>触发器的<code>FOR EACH ROW</code>属性是可选的，如果选中则在操作修改时每一行调用一次。</li><li>选中<code>FOR EACH STATEMENT</code>属性时，不管修改多少行都只会执行一次。</li><li>WHEN子句和触发器操作在引用NEW.column-name 和 OLD.column-name 表单插入、删除或更新时可以访问每一行元素。</li><li>如果存在 WHEN 子句，PostgreSQL 语句只会执行 WHEN 子句成立的那一行，如果没有 WHEN 子句，PostgreSQL 语句会在每一行执行。</li><li><code>BEFORE</code> 和 <code>AFTER</code> 决定触发器在什么时候执行。</li><li>要修改的表必须和当前操作数据库在一个目录下，不可以使用调用</li><li>约束触发器<ul><li>约束触发器并不是在事件发生前后执行而是可以在指定的时间点触发</li><li>约束触发器可以使用约束选项<code>IMMEDIATE</code>和<code>DEFERRED</code>来调整执行时间</li></ul></li></ul><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">TRIGGER</span> trigger_name [BEFORE<span class="hljs-operator">|</span>AFTER<span class="hljs-operator">|</span>INSTEAD <span class="hljs-keyword">OF</span>] event_name<br><span class="hljs-keyword">ON</span> table_name<br>[<br> <span class="hljs-comment">-- 触发器逻辑....</span><br>];<br></code></pre></td></tr></table></figure><p><code>event_name</code> 可以是在所提到的表 <code>table_name</code> 上的 <code>INSERT</code>、<code>DELETE</code> 和 <code>UPDATE</code> 数据库操作。您可以在表名后选择指定 <code>FOR EACH ROW</code>。</p><p>UPDATE在单表或多表上的示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">TRIGGER</span> trigger_name [BEFORE<span class="hljs-operator">|</span>AFTER] <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">OF</span> column_name<br><span class="hljs-keyword">ON</span> table_name<br>[<br> <span class="hljs-comment">-- 触发器逻辑....</span><br>];<br></code></pre></td></tr></table></figure><p>用<code>DROP TABLE COMPANY;</code>删掉前面part用的COMPANY表，建立一个新的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> COMPANY(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   NAME           TEXT    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   AGE            <span class="hljs-type">INT</span>     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   ADDRESS        <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>   SALARY         <span class="hljs-type">REAL</span><br>);<br></code></pre></td></tr></table></figure><p>然后再建一个对照表AUDIT</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> AUDIT(<br>   EMP_ID <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   ENTRY_DATE TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>);<br></code></pre></td></tr></table></figure><p>然后开始操作，首先建立一个函数</p><p>建立之前先说一下我对函数的基本语法的理解。</p><p>这是我用chatGPT搞的一个示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">FUNCTION</span> get_sum(a <span class="hljs-type">NUMERIC</span>, b <span class="hljs-type">NUMERIC</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">NUMERIC</span> <span class="hljs-keyword">AS</span> $$<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">RETURN</span> a <span class="hljs-operator">+</span> b;<br><span class="hljs-keyword">END</span>;<br>$$ <span class="hljs-keyword">LANGUAGE</span> plpgsql;<br></code></pre></td></tr></table></figure><p>通过直译我们可以发现，创建函数的基本语句就是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">OR</span> REPLACE] <span class="hljs-keyword">FUNCTION</span> 函数名称 (参数列表)<br><span class="hljs-keyword">RETURNS</span> 返回类型 <span class="hljs-keyword">AS</span> $$<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-comment">-- 函数主体</span><br>    <span class="hljs-comment">-- 包含SQL语句和/或过程语言代码</span><br><span class="hljs-keyword">END</span>;<br>$$<br> <span class="hljs-keyword">LANGUAGE</span> 语言名称;<br></code></pre></td></tr></table></figure><p>然后我们回到建立函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">FUNCTION</span> auditlogfunc() <span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-keyword">AS</span> $example_table$<br>   <span class="hljs-keyword">BEGIN</span><br>      <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> AUDIT(EMP_ID, ENTRY_DATE) <span class="hljs-keyword">VALUES</span> (new.ID, <span class="hljs-built_in">current_timestamp</span>);<br>      <span class="hljs-keyword">RETURN</span> <span class="hljs-keyword">NEW</span>;<br>   <span class="hljs-keyword">END</span>;<br>$example_table$ <span class="hljs-keyword">LANGUAGE</span> plpgsql;<br></code></pre></td></tr></table></figure><p>创建后我们来建立触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> example_trigger AFTER <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> COMPANY <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">EXECUTE</span> <span class="hljs-keyword">PROCEDURE</span> auditlogfunc();<br></code></pre></td></tr></table></figure><p>然后向表中插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Paul&#x27;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;California&#x27;</span>, <span class="hljs-number">20000.00</span> );<br></code></pre></td></tr></table></figure><p>插入后我们用SELECT去找AUDIT库就可以看到我们已经添加了数据了。</p><h2 id="列出触发器"><a href="#列出触发器" class="headerlink" title="列出触发器"></a>列出触发器</h2><p>列出所有触发器的语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pg_trigger;<br></code></pre></td></tr></table></figure><p>然后再来看看列出特定触发器的语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> tgname <span class="hljs-keyword">FROM</span> pg_trigger, pg_class <span class="hljs-keyword">WHERE</span> tgrelid<span class="hljs-operator">=</span>pg_class.oid <span class="hljs-keyword">AND</span> relname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;company&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">trigger</span> $&#123;trigger_name&#125; <span class="hljs-keyword">on</span> $&#123;table_of_trigger_dependent&#125;;<br></code></pre></td></tr></table></figure><p>删除我们前面建立的触发器的命令如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">trigger</span> example_trigger <span class="hljs-keyword">on</span> company;<br></code></pre></td></tr></table></figure><p>触发器我自己感觉是更适合大量任务进行时的自动化，可以节省很多人力成本。不过这点好像面试不会特别去考，也不知道为啥。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>终于来到了面试官最最最最喜爱的索引，我自己的经历我感觉除了三范式这个问题出现概率高之外，就是索引会考很多。我自己就遇到过下面几个问题（特指MySQL，毕竟我简历上写的MySQL）</p><ul><li>什么是索引，为什么用索引</li><li>索引的数据结构，他们之间有什么区别</li><li>索引的种类有哪些</li><li>B树和B+树有啥区别（这个我当时懵掉了，之前还复习过）</li><li>索引的使用场景</li><li>之后我也会把我大概能遇到的想到的写成Blog然后发布出来，应该会更倾向于机器学习，毕竟这个我更擅长。</li></ul><p>基本概念咱就跳过，都是一样的，不知道的拖出去乱棍打死</p><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name;<br></code></pre></td></tr></table></figure><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><p>基于表的具体一列去建立索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name (column_name);<br></code></pre></td></tr></table></figure><h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p>基于表的多列去建立索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name (column1_name, column2_name);<br></code></pre></td></tr></table></figure><p>不管是单列还是组合索引都需要建立在频繁多次使用WHERE的情况下，反推出使用场景之一就是频繁使用WHERE的情况下。</p><p>只有一列被使用就用单列索引，多列被使用就用多列索引</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引是为了提高性能、保证数据完整性，保证无重复值进入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX index_name<br><span class="hljs-keyword">on</span> table_name (column_name);<br></code></pre></td></tr></table></figure><h3 id="局部索引"><a href="#局部索引" class="headerlink" title="局部索引"></a>局部索引</h3><p>局部索引是在子集上建立索引，子集由一个条件表达式上定义，索引只包含符合条件的行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name(column_list)<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure><h3 id="隐式索引"><a href="#隐式索引" class="headerlink" title="隐式索引"></a>隐式索引</h3><p>数据库会自动创建</p><h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name;<br></code></pre></td></tr></table></figure><h2 id="索引准则"><a href="#索引准则" class="headerlink" title="索引准则"></a>索引准则</h2><ul><li>适合于中大型表，不适合于小表，小表一般全表扫描更快</li><li>不适用于需要频繁进行大批量的增删改的操作，更适合于大量查询的表</li><li>不应该在含有大量NULL的上</li><li>不应该建立在需要被频繁操作的列上</li><li>多个字段经常一起被查询可以考虑建立联合索引</li><li>多个字段且字段没有重复可以考虑唯一索引</li><li>字段多且有重复考虑普通索引</li></ul><h1 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h1><p>ALTER TABLE 用于添加、修改、删除一张已经存在的表，也可以用来添加和删除约束。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> column_name datatype;<br></code></pre></td></tr></table></figure><h3 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> column_name;<br></code></pre></td></tr></table></figure><h3 id="修改数据类型"><a href="#修改数据类型" class="headerlink" title="修改数据类型"></a>修改数据类型</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> column_name TYPE datatype;<br></code></pre></td></tr></table></figure><h3 id="添加UNIQUE约束"><a href="#添加UNIQUE约束" class="headerlink" title="添加UNIQUE约束"></a>添加UNIQUE约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> MyUniqueConstraint <span class="hljs-keyword">UNIQUE</span>(column1, column2...);<br></code></pre></td></tr></table></figure><h3 id="添加CHECK约束"><a href="#添加CHECK约束" class="headerlink" title="添加CHECK约束"></a>添加CHECK约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> MyUniqueConstraint <span class="hljs-keyword">CHECK</span> (<span class="hljs-keyword">CONDITION</span>);<br></code></pre></td></tr></table></figure><h3 id="添加主键"><a href="#添加主键" class="headerlink" title="添加主键"></a>添加主键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> MyPrimaryKey <span class="hljs-keyword">PRIMARY</span> KEY (column1, column2...);<br></code></pre></td></tr></table></figure><h3 id="添加NOT-NULL约束"><a href="#添加NOT-NULL约束" class="headerlink" title="添加NOT NULL约束"></a>添加NOT NULL约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> column_name <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NOT</span> NNULL;<br></code></pre></td></tr></table></figure><h3 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> MyUniqueConstraint;<br></code></pre></td></tr></table></figure><p>对应MySQL是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">DROP</span> INDEX MyUniqueConstraint;<br></code></pre></td></tr></table></figure><h3 id="删除主键"><a href="#删除主键" class="headerlink" title="删除主键"></a>删除主键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> MyPrimaryKey;<br></code></pre></td></tr></table></figure><p>对应MySQL是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY;<br></code></pre></td></tr></table></figure><h3 id="删除NOT-NULL约束"><a href="#删除NOT-NULL约束" class="headerlink" title="删除NOT NULL约束"></a>删除NOT NULL约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> column_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><h1 id="TRUNCATE-TABLE"><a href="#TRUNCATE-TABLE" class="headerlink" title="TRUNCATE TABLE"></a>TRUNCATE TABLE</h1><p>在使用<code>DROP TABLE TABLE_NAME</code>时会直接删除表内容和表结构，如果想使用该表就需要重新建立</p><p><code>TRUNCATE TABLE</code>就可以只删除表内容保留表结构，并且由于他不扫描表，所以速度上比<code>DELETE</code>更快</p><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span>  table_name;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——区间</title>
    <link href="/2024/08/05/leetcode_%E5%8C%BA%E9%97%B4/"/>
    <url>/2024/08/05/leetcode_%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="228-汇总矩阵"><a href="#228-汇总矩阵" class="headerlink" title="228 汇总矩阵"></a>228 汇总矩阵</h1><p>给定一个  <strong>无重复元素</strong> 的 <strong>有序</strong> 整数数组 <code>nums</code> 。</p><p>返回 <strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表 。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。</p><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><p>“<code>a-&gt;b&quot;</code> ，如果 <code>a != b</code><br>“<code>a</code>“ ，如果 <code>a == b</code></p><p>示例 1：</p><p>输入：nums &#x3D; [0,1,2,4,5,7]</p><p>输出：[“0-&gt;2”,”4-&gt;5”,”7”]</p><p>解释：区间范围是：</p><p>[0,2] –&gt; “0-&gt;2”</p><p>[4,5] –&gt; “4-&gt;5”</p><p>[7,7] –&gt; “7”</p><p>示例 2：</p><p>输入：nums &#x3D; [0,2,3,4,6,8,9]</p><p>输出：[“0”,”2-&gt;4”,”6”,”8-&gt;9”]</p><p>解释：区间范围是：</p><p>[0,0] –&gt; “0”</p><p>[2,4] –&gt; “2-&gt;4”</p><p>[6,6] –&gt; “6”</p><p>[8,9] –&gt; “8-&gt;9”</p><p>提示：</p><p><code>0 &lt;= nums.length &lt;= 20</code></p><p><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></p><p><code>nums</code> 中的所有值都 <strong>互不相同</strong></p><p><code>nums</code> 按升序排列</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到题目第一时间想到两种情况</p><ol><li>如果当前指针和下一个指针两个位置的数相等，将当前指针位置存储到数组中并后移两个指针。</li><li>如果当前指针和下一个指针位置不相等，则下一个指针再往前一个位置。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">summaryRanges</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">help_func</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(nums[i]) <span class="hljs-keyword">if</span> i == j <span class="hljs-keyword">else</span> <span class="hljs-built_in">str</span>(nums[i]) + <span class="hljs-string">&#x27;-&gt;&#x27;</span> + <span class="hljs-built_in">str</span>(nums[j])<br>        <br>        i, n, ans = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums), []<br>        <span class="hljs-keyword">while</span> i &lt; n:<br>            j = i<br>            <span class="hljs-keyword">while</span> j + <span class="hljs-number">1</span> &lt; n <span class="hljs-keyword">and</span> nums[j + <span class="hljs-number">1</span>] == nums[j] + <span class="hljs-number">1</span>:<br>                j += <span class="hljs-number">1</span><br>            ans.append(help_func(i, j))<br>            i = j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间30ms，消耗内存16.2MB</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>刚开始想到的是三指针，但这种情况下，i和j同步往前移，k在i一开始的位置。但是这样后来一想完全没必要，反而浪费了时间。所以双指针直接就能解决，需要检测动的只有一个指针。</p><p>然后看到一个运行速度更快的算法，思路都是一样的，但是这个的执行时间更少。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">summaryRanges</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        <span class="hljs-string">&#x27;&#x27;&#x27;i最多执行n次，O(n)&#x27;&#x27;&#x27;</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        ans = []<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt;n: <span class="hljs-comment"># i从左到右遍历</span><br>            start = i<br>            <span class="hljs-keyword">while</span> i &lt;n -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[i] + <span class="hljs-number">1</span>== nums[i+<span class="hljs-number">1</span>]:  <span class="hljs-comment"># 一直遍历下去直到不连续</span><br>                i += <span class="hljs-number">1</span><br>            s = <span class="hljs-built_in">str</span>(nums[start])<br>            <span class="hljs-keyword">if</span> start &lt; i:<br>                s += <span class="hljs-string">&#x27;-&gt;&#x27;</span><br>                s += <span class="hljs-built_in">str</span>(nums[i])<br>            ans.append(s)<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="56-合并数组"><a href="#56-合并数组" class="headerlink" title="56 合并数组"></a>56 合并数组</h1><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p>示例 1：</p><p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</p><p>输出：[[1,6],[8,10],[15,18]]</p><p>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]。</p><p>示例 2：</p><p>输入：intervals &#x3D; [[1,4],[4,5]]</p><p>输出：[[1,5]]</p><p>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p><p>提示：</p><p><code>1 &lt;= intervals.length &lt;= 104</code></p><p><code>intervals[i].length == 2</code></p><p><code>0 &lt;= starti &lt;= endi &lt;= 104</code></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题一拿到肯定会有点懵，因为第一眼看肯定不知道这俩玩意咋能合并。</p><p>仔细拆解后会发现，题目给出的示例已经给我们怎么去写条件了，当我们当前区间的第一个元素比钱一个区间的第二个元素小或者相等，这时我们就满足了条件。</p><p>然后我们需要找到谁作为新区间的第二个元素，这里很明显就是前一个区间的第二个元素和当前区间的第二个元素较大的那个。</p><p>最后需要强调一个事情就是[-1][1]指的是列表中[-1]指最后一个区间，[1]指第二个元素。代码中ans[-1][1]就是ans列表中的最后一个区间（也就是离当前区间最近的）中第二个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        intervals.sort()<br>        ans = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> intervals:<br>            <span class="hljs-keyword">if</span> ans <span class="hljs-keyword">and</span> i[<span class="hljs-number">0</span>] &lt;= ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:<br>                ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], i[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">else</span>:<br>                ans.append(i)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n log n)，执行时间54ms，消耗内存19.5MB</p><h2 id="反思-1"><a href="#反思-1" class="headerlink" title="反思"></a>反思</h2><p>后来查看了一下其他人的代码，后面的内容大差不差但在排序上使用了lambda来写条件，可以节约时间。但思路上看了几个其他人的都是一样的，先排序后循环比大小。</p><h1 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57 插入区间"></a>57 插入区间</h1><p>给你一个 <strong>无重叠的</strong> ，按照区间起始端点排序的区间列表 <code>intervals</code>，其中 <code>intervals[i] = [starti, endi]</code> 表示第 <code>i</code> 个区间的开始和结束，并且 <code>intervals</code> 按照 <code>starti</code> 升序排列。同样给定一个区间 <code>newInterval = [start, end]</code> 表示另一个区间的开始和结束。</p><p>在 <code>intervals</code> 中插入区间 <code>newInterval</code>，使得 <code>intervals</code> 依然按照 <code>starti</code> 升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。</p><p>返回插入之后的 <code>intervals</code>。</p><p>注意 你不需要原地修改 <code>intervals</code>。你可以创建一个新数组然后返回它。</p><p>示例 1：</p><p>输入：intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]</p><p>输出：[[1,5],[6,9]]</p><p>示例 2：</p><p>输入：intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</p><p>输出：[[1,2],[3,10],[12,16]]</p><p>解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</p><p>提示：</p><p><code>0 &lt;= intervals.length &lt;= 104</code></p><p><code>intervals[i].length == 2</code></p><p><code>0 &lt;= starti &lt;= endi &lt;= 105</code></p><p><code>intervals</code> 根据 <code>starti</code> 按 <strong>升序</strong> 排列</p><p><code>newInterval.length == 2</code></p><p><code>0 &lt;= start &lt;= end &lt;= 105</code></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这道题和前面一道题的唯二不同就在于我们需要先将新区间插入到列表，然后在循环阶段需要引入start和end，其余和前一题一摸一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], newInterval: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        intervals.append(newInterval)<br>        intervals.sort()<br>        ans = [intervals[<span class="hljs-number">0</span>]]<br>        <span class="hljs-keyword">for</span> s, e <span class="hljs-keyword">in</span> intervals[<span class="hljs-number">1</span>:]:<br>            <span class="hljs-keyword">if</span> ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; s:<br>                ans.append([s, e])<br>            <span class="hljs-keyword">else</span>:<br>                ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], e)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n log n)，执行时间49ms，消耗内存18.5MB</p><h2 id="反思-2"><a href="#反思-2" class="headerlink" title="反思"></a>反思</h2><p>这里给出我第一次做的时候的错误代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], newInterval: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        intervals.append(newInterval)<br>        intervals.sort()<br>        ans = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> intervals:<br>            <span class="hljs-keyword">if</span> ans <span class="hljs-keyword">and</span> i[<span class="hljs-number">0</span>] &lt;= ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:<br>                ans[-<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], i[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">else</span>:<br>                ans.append(i)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>没有修改循环部分的代码，导致更新了结束的时间忽略了开始时间导致区间格式错误。</p><h1 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452 用最少数量的箭引爆气球"></a>452 用最少数量的箭引爆气球</h1><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code> ，其中<code>points[i] = [x_start, x_end]</code> 表示水平直径在 <code>xstart</code> 和 <code>xend</code> 之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>xstart</code>，<code>xend</code>， 且满足  <code>xstart ≤ x ≤ xend</code>，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 <code>points</code> ，返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数 。</p><p>示例 1：</p><p>输入：points &#x3D; [[10,16],[2,8],[1,6],[7,12]]</p><p>输出：2</p><p>解释：气球可以用2支箭来爆破:</p><p>-在x &#x3D; 6处射出箭，击破气球[2,8]和[1,6]。</p><p>-在x &#x3D; 11处发射箭，击破气球[10,16]和[7,12]。</p><p>示例 2：</p><p>输入：points &#x3D; [[1,2],[3,4],[5,6],[7,8]]</p><p>输出：4</p><p>解释：每个气球需要射出一支箭，总共需要4支箭。</p><p>示例 3：</p><p>输入：points &#x3D; [[1,2],[2,3],[3,4],[4,5]]</p><p>输出：2</p><p>解释：气球可以用2支箭来爆破:</p><ul><li><p>在x &#x3D; 2处发射箭，击破气球[1,2]和[2,3]。</p></li><li><p>在x &#x3D; 4处射出箭，击破气球[3,4]和[4,5]。</p></li></ul><p>提示:</p><p><code>1 &lt;= points.length &lt;= 105</code></p><p><code>points[i].length == 2</code></p><p><code>-231 &lt;= xstart &lt; xend &lt;= 231 - 1</code></p><p>这里找了张评论区一个大哥画的示意图</p><p><img src="/../img/leetcode%E5%8C%BA%E9%97%B4%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%94%E2%80%94452.png" alt="示意图"></p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ol><li>首先对整个气球架的点进行排序，并且把第一个start和end初始化。</li><li>循环中从第二个气球开始，然后思路和前一道题类似，更新最大最小值。</li><li>然后不满足条件了进入else，箭数量加1然后更新点坐标。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMinArrowShots</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        points.sort()<br>        arrow = <span class="hljs-number">0</span><br>        start, end = points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(points)):<br>            <span class="hljs-keyword">if</span> start &lt;= points[i][<span class="hljs-number">0</span>] &lt;= end:<br>                start = <span class="hljs-built_in">max</span>(start, points[i][<span class="hljs-number">0</span>])<br>                end = <span class="hljs-built_in">min</span>(end, points[i][<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">else</span>:<br>                arrow += <span class="hljs-number">1</span><br>                start, end = points[i][<span class="hljs-number">0</span>], points[i][<span class="hljs-number">1</span>]<br>        arrow += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> arrow<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n log n)，执行时间370ms，消耗内存49.5MB</p><h2 id="反思-3"><a href="#反思-3" class="headerlink" title="反思"></a>反思</h2><p>我这个做法相对来说不是很常见的写法，太过直译。下面附上大多数人的做法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMinArrowShots</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> points:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        points.sort(key=<span class="hljs-keyword">lambda</span> balloon: balloon[<span class="hljs-number">1</span>])<br>        pos = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>        ans = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> balloon <span class="hljs-keyword">in</span> points:<br>            <span class="hljs-keyword">if</span> balloon[<span class="hljs-number">0</span>] &gt; pos:<br>                pos = balloon[<span class="hljs-number">1</span>]<br>                ans += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>大部分人的思路都是类似这个，内容可能有差距但思路大差不差。</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>区间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL学习记录——第二天</title>
    <link href="/2024/08/05/postgresql-study-second-day/"/>
    <url>/2024/08/05/postgresql-study-second-day/</url>
    
    <content type="html"><![CDATA[<p>今天准备继续学PG的高级操作，至于为什么过了一个周末才有开始学，那当然是因为上班时间拿来学习周末时间拿来玩啦~</p><p>今天差不多就是约束、JOIN、UNION、别名、索引、触发器、事务、锁这些，gogogo。</p><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>在观感上感觉和MySQL的差不多，但是在查询相关资料后发现还是有些许区别。</p><h2 id="和MySQL区别"><a href="#和MySQL区别" class="headerlink" title="和MySQL区别"></a>和MySQL区别</h2><p>首先明确一点，他们都支持五大约束（不知道的拖出去乱棍打死！面试经常考的都不知道！）。</p><p>PG自带了一个MySQL中没有的约束——排他约束（EXCLUDE）。同时在检查约束（CHECK）上会更加完善，能够支持更复杂的约束条件。</p><p>PG可以给约束别名，而MySQL只能使用原本的名称，这点上如果按照实际操作来看其实没什么差别，一个就是按照原本的英文去写一个就是按照自己的习惯去修改名称。直接用英文的话感觉上会更习惯日常操作。</p><p>PG支持部分约束和表达式约束（部分约束好像我之前面试的时候有被考到过，太久远了忘记了。），能够实现更复杂的操作。</p><h2 id="PG常见约束"><a href="#PG常见约束" class="headerlink" title="PG常见约束"></a>PG常见约束</h2><ul><li>NOT NULL 非空约束</li><li>UNIQUE 唯一约束</li><li>PREMARY key 主键约束</li><li>FOREIGH key 外键约束</li><li>CHECK 检查约束</li><li>EXCLUSION 排他约束</li></ul><h2 id="NOT-NULL"><a href="#NOT-NULL" class="headerlink" title="NOT NULL"></a>NOT NULL</h2><p>默认情况下，列可以为NULL，但如果不让这列为NULL就可以设置此约束。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> COMPANY1(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   NAME           TEXT    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   AGE            <span class="hljs-type">INT</span>     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   ADDRESS        <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>   SALARY         <span class="hljs-type">REAL</span><br>);<br></code></pre></td></tr></table></figure><p>命令中就给几个列附了非空约束    </p><h2 id="UNIQUE"><a href="#UNIQUE" class="headerlink" title="UNIQUE"></a>UNIQUE</h2><p>唯一性约束可以使该列是唯一的，不存在其他列和该列相同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> COMPANY3(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   NAME           TEXT    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   AGE            <span class="hljs-type">INT</span>     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span>,<br>   ADDRESS        <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>   SALARY         <span class="hljs-type">REAL</span>    <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">50000.00</span><br>);<br></code></pre></td></tr></table></figure><h2 id="PRIMARY-KEY"><a href="#PRIMARY-KEY" class="headerlink" title="PRIMARY KEY"></a>PRIMARY KEY</h2><p>主键约束用于数据库中每条记录的唯一表标识，在设置时UNIQUE可以为多个，但PRIMARY KEY只能有一个，同时可以使用主键来引用表中的行，也可以通过将主键设置为其他表的外键来创建表之间的关联。</p><p>在前两个例子中，ID都是被设置为主键的。</p><h2 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h2><p>外键约束就是该表的制定列中的值必须匹配到另一个表的某一行中出现的值。通常用来建立两个表中的连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> DEPARTMENT1(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   DEPT           <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   EMP_ID         <span class="hljs-type">INT</span>      <span class="hljs-keyword">references</span> COMPANY2(ID)<br>);<br></code></pre></td></tr></table></figure><p>这里是在建立好COMPANY2的基础上建立的DEPARTMENT1，也就是说EMP_ID依托于COMPANY2的ID，EMP_ID就是外键。</p><h2 id="CHECK"><a href="#CHECK" class="headerlink" title="CHECK"></a>CHECK</h2><p>检查约束就是用来限制该列中的值的，在给列添加值时，符合条件的就会被添加，如果为false（不符合条件）就无法输入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> COMPANY4(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   NAME           TEXT    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   AGE            <span class="hljs-type">INT</span>     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   ADDRESS        <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>   SALARY         <span class="hljs-type">REAL</span>    <span class="hljs-keyword">CHECK</span>(SALARY <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>)<br>);<br></code></pre></td></tr></table></figure><p>我们这里建立的COMPANY4中给SALARY一个检查约束，条件是值大于0，也就是说只有大于0的值会被输入，反之不会。</p><h2 id="EXCLUSION"><a href="#EXCLUSION" class="headerlink" title="EXCLUSION"></a>EXCLUSION</h2><p>排他约束确保如果使用指定的运算符在指定列或表达式上比较任意两行，至少其中一个运算符比较将返回false或null。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> COMPANY5(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   NAME           TEXT,<br>   AGE            <span class="hljs-type">INT</span>,<br>   ADDRESS        <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>   SALARY         <span class="hljs-type">REAL</span>,<br>   EXCLUDE <span class="hljs-keyword">USING</span> gist<br>   (NAME <span class="hljs-keyword">WITH</span> <span class="hljs-operator">=</span>,  <span class="hljs-comment">-- 如果满足 NAME 相同，AGE 不相同则不允许插入，否则允许插入</span><br>   AGE <span class="hljs-keyword">WITH</span> <span class="hljs-operator">&lt;&gt;</span>)   <span class="hljs-comment">-- 其比较的结果是如果整个表达式返回 true，则不允许插入，否则允许</span><br>);<br></code></pre></td></tr></table></figure><p>USING gist 是用于构建和执行的索引一种类型。</p><p>这里需要注意的是，在使用这个SQL语句前记得用<code>CREATE EXTENSION IF NOT EXISTS btree_gist;</code>来开启扩展，不然会无法创建。</p><p>然后插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY5 <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Paul&#x27;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;California&#x27;</span>, <span class="hljs-number">20000.00</span> );<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY5 <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Paul&#x27;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;Texas&#x27;</span>, <span class="hljs-number">20000.00</span> );<br><span class="hljs-comment">-- 此条数据的 NAME 与第一条相同，且 AGE 与第一条也相同，故满足插入条件</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY5 <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Allen&#x27;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&#x27;California&#x27;</span>, <span class="hljs-number">20000.00</span> );<br><span class="hljs-comment">-- 此数据与上面数据的 NAME 相同，但 AGE 不相同，故不允许插入</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">ERROR:  conflicting key <span class="hljs-keyword">value</span> violates exclusion <span class="hljs-keyword">constraint</span> &quot;company7_name_age_excl&quot;<br>DETAIL:  Key (name, age)<span class="hljs-operator">=</span>(Paul, <span class="hljs-number">42</span>) conflicts <span class="hljs-keyword">with</span> existing key (name, age)<span class="hljs-operator">=</span>(Paul, <span class="hljs-number">32</span>).<br></code></pre></td></tr></table></figure><h2 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> some_name;<br></code></pre></td></tr></table></figure><p>如果不知道名称可以使用\d + table_name来查询</p><h1 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h1><h2 id="常见JOIN类型"><a href="#常见JOIN类型" class="headerlink" title="常见JOIN类型"></a>常见JOIN类型</h2><ul><li>CROSS JOIN </li><li>INNER JOIN</li><li>LEFT OUTER JOIN</li><li>RIGHT OUTER JOIN</li><li>FULL OUTER JOIN</li></ul><h2 id="预先准备"><a href="#预先准备" class="headerlink" title="预先准备"></a>预先准备</h2><p>导入数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> COMPANY(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   NAME           TEXT    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   AGE            <span class="hljs-type">INT</span>     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   ADDRESS        <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>   SALARY         <span class="hljs-type">REAL</span><br>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Paul&#x27;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;California&#x27;</span>, <span class="hljs-number">20000.00</span> );<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Allen&#x27;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;Texas&#x27;</span>, <span class="hljs-number">15000.00</span> );<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Teddy&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;Norway&#x27;</span>, <span class="hljs-number">20000.00</span> );<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;Mark&#x27;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;Rich-Mond &#x27;</span>, <span class="hljs-number">65000.00</span> );<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;David&#x27;</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&#x27;Texas&#x27;</span>, <span class="hljs-number">85000.00</span> );<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;Kim&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;South-Hall&#x27;</span>, <span class="hljs-number">45000.00</span> );<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;James&#x27;</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&#x27;Houston&#x27;</span>, <span class="hljs-number">10000.00</span> );<br></code></pre></td></tr></table></figure><p>然后用SELECT查看一下是否建立成功，结果如下</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coq"> id | <span class="hljs-type">name</span>  | <span class="hljs-type">age</span> | <span class="hljs-type">address</span>   | <span class="hljs-type">salary</span><br>----+-------+-----+-----------+--------<br>  <span class="hljs-number">1</span> | <span class="hljs-type">Paul</span>  |  <span class="hljs-type">32</span> | <span class="hljs-type">California</span>|  <span class="hljs-type">20000</span><br>  <span class="hljs-number">2</span> | <span class="hljs-type">Allen</span> |  <span class="hljs-type">25</span> | <span class="hljs-type">Texas</span>     |  <span class="hljs-type">15000</span><br>  <span class="hljs-number">3</span> | <span class="hljs-type">Teddy</span> |  <span class="hljs-type">23</span> | <span class="hljs-type">Norway</span>    |  <span class="hljs-type">20000</span><br>  <span class="hljs-number">4</span> | <span class="hljs-type">Mark</span>  |  <span class="hljs-type">25</span> | <span class="hljs-type">Rich</span>-Mond |  <span class="hljs-type">65000</span><br>  <span class="hljs-number">5</span> | <span class="hljs-type">David</span> |  <span class="hljs-type">27</span> | <span class="hljs-type">Texas</span>     |  <span class="hljs-type">85000</span><br>  <span class="hljs-number">6</span> | <span class="hljs-type">Kim</span>   |  <span class="hljs-type">22</span> | <span class="hljs-type">South</span>-Hall|  <span class="hljs-type">45000</span><br>  <span class="hljs-number">7</span> | <span class="hljs-type">James</span> |  <span class="hljs-type">24</span> | <span class="hljs-type">Houston</span>   |  <span class="hljs-type">10000</span><br>(<span class="hljs-number">7</span> rows)<br></code></pre></td></tr></table></figure><p>接下来插入几条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;Paul&#x27;</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&#x27;Houston&#x27;</span>, <span class="hljs-number">20000.00</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;James&#x27;</span>, <span class="hljs-number">44</span>, <span class="hljs-string">&#x27;Norway&#x27;</span>, <span class="hljs-number">5000.00</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;James&#x27;</span>, <span class="hljs-number">45</span>, <span class="hljs-string">&#x27;Texas&#x27;</span>, <span class="hljs-number">5000.00</span>);<br></code></pre></td></tr></table></figure><p>这时的结果为</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coq"> id | <span class="hljs-type">name</span>  | <span class="hljs-type">age</span> | <span class="hljs-type">address</span>      | <span class="hljs-type">salary</span><br> ----+-------+-----+--------------+--------<br>   <span class="hljs-number">1</span> | <span class="hljs-type">Paul</span>  |  <span class="hljs-type">32</span> | <span class="hljs-type">California</span>   |  <span class="hljs-type">20000</span><br>   <span class="hljs-number">2</span> | <span class="hljs-type">Allen</span> |  <span class="hljs-type">25</span> | <span class="hljs-type">Texas</span>        |  <span class="hljs-type">15000</span><br>   <span class="hljs-number">3</span> | <span class="hljs-type">Teddy</span> |  <span class="hljs-type">23</span> | <span class="hljs-type">Norway</span>       |  <span class="hljs-type">20000</span><br>   <span class="hljs-number">4</span> | <span class="hljs-type">Mark</span>  |  <span class="hljs-type">25</span> | <span class="hljs-type">Rich</span>-Mond    |  <span class="hljs-type">65000</span><br>   <span class="hljs-number">5</span> | <span class="hljs-type">David</span> |  <span class="hljs-type">27</span> | <span class="hljs-type">Texas</span>        |  <span class="hljs-type">85000</span><br>   <span class="hljs-number">6</span> | <span class="hljs-type">Kim</span>   |  <span class="hljs-type">22</span> | <span class="hljs-type">South</span>-Hall   |  <span class="hljs-type">45000</span><br>   <span class="hljs-number">7</span> | <span class="hljs-type">James</span> |  <span class="hljs-type">24</span> | <span class="hljs-type">Houston</span>      |  <span class="hljs-type">10000</span><br>   <span class="hljs-number">8</span> | <span class="hljs-type">Paul</span>  |  <span class="hljs-type">24</span> | <span class="hljs-type">Houston</span>      |  <span class="hljs-type">20000</span><br>   <span class="hljs-number">9</span> | <span class="hljs-type">James</span> |  <span class="hljs-type">44</span> | <span class="hljs-type">Norway</span>       |   <span class="hljs-type">5000</span><br>  <span class="hljs-number">10</span> | <span class="hljs-type">James</span> |  <span class="hljs-type">45</span> | <span class="hljs-type">Texas</span>        |   <span class="hljs-type">5000</span><br>(<span class="hljs-number">10</span> rows)<br></code></pre></td></tr></table></figure><p>然后创建表DEPARTMENT</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> DEPARTMENT(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   DEPT           <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   EMP_ID         <span class="hljs-type">INT</span>      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>);<br></code></pre></td></tr></table></figure><p>插入三条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> DEPARTMENT (ID, DEPT, EMP_ID) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;IT Billing&#x27;</span>, <span class="hljs-number">1</span> );<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> DEPARTMENT (ID, DEPT, EMP_ID) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Engineering&#x27;</span>, <span class="hljs-number">2</span> );<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> DEPARTMENT (ID, DEPT, EMP_ID) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Finance&#x27;</span>, <span class="hljs-number">7</span> );<br></code></pre></td></tr></table></figure><p>这时DEPARTMENT表中的记录为</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section"> id | dept        | emp_id</span><br><span class="hljs-section">----+-------------+--------</span><br><span class="hljs-code">  1 | IT Billing  |  1</span><br><span class="hljs-code">  2 | Engineering |  2</span><br><span class="hljs-code">  3 | Finance     |  7</span><br></code></pre></td></tr></table></figure><h2 id="CROSS-JOIN"><a href="#CROSS-JOIN" class="headerlink" title="CROSS JOIN"></a>CROSS JOIN</h2><p>交叉连接（CROSS JOIN），把第一个表中的每一行和第二个表中的每一行进行匹配，如果两个输入表分别有x和有行，则结果有x*y行。</p><p>提示：由于CROSS JOIN可能会产生很大的表，为安全起见还是需要在合适的时候去使用。</p><p>基础语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> table2 ...<br></code></pre></td></tr></table></figure><p>基于上面的两个表可以写下面的连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> DEPARTMENT;<br></code></pre></td></tr></table></figure><p>退出的时候按<code>q</code>就可以。</p><h2 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h2><p>内连接（INNER JOIN）根据连接谓词结合两个表（table1、table2）的列值来创建一个新的结果表。查询结果把table1的每一行和table2的每一行进行比较，找到满足条件的行进行匹配。</p><p>同时INNER JOIN也是默认的连接类型。</p><p>基本语法如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> table1.column1, table2.column2...<br><span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> table2<br><span class="hljs-keyword">ON</span> table1.common_filed = table2.common_field;<br></code></pre></td></tr></table></figure><p>基于上面的表可以写下面的连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> DEPARTMENT <span class="hljs-keyword">ON</span> COMPANY.ID <span class="hljs-operator">=</span> DEPARTMENT.EMP_ID;<br></code></pre></td></tr></table></figure><h2 id="LEFT-RIGHT-OUTER-JOIN"><a href="#LEFT-RIGHT-OUTER-JOIN" class="headerlink" title="LEFT&#x2F;RIGHT OUTER JOIN"></a>LEFT&#x2F;RIGHT OUTER JOIN</h2><p>这里熟悉MySQL中JOIN的一般会有一个疑问，通常我们会直接使用LEFT&#x2F;RIGHT JOIN来表示左右连接，这里为什么会有一个OUTER。都是SQL类型的命令为什么还会有差别？</p><p>实际上，通过查询相关资料发现，OUTER在这里添加是为了体现语句的可读性，因为从翻译角度看，左右连接是并不是官方名称。官方称作左右外连接，这个外就是用OUTER在语句中体现。</p><p>所以在使用过程中，我们可以直接忽略OUTER，熟悉MySQL的应该会直接忽略这个，毕竟操作没有任何影响，只是可读性的问题。</p><p>基本语法如下：</p><ul><li>左连接<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">ON</span> conditional_expression ...<br></code></pre></td></tr></table></figure></li><li>右连接<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">ON</span> conditional_expression ...<br></code></pre></td></tr></table></figure>基于上面的表可以写下面的两个连接<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">LEFT</span>  <span class="hljs-keyword">JOIN</span> DEPARTMENT <span class="hljs-keyword">ON</span> COMPANY.ID <span class="hljs-operator">=</span> DEPARTMENT.EMP_ID;<br><span class="hljs-keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">RIGHT</span>  <span class="hljs-keyword">JOIN</span> DEPARTMENT <span class="hljs-keyword">ON</span> COMPANY.ID <span class="hljs-operator">=</span> DEPARTMENT.EMP_ID;<br></code></pre></td></tr></table></figure></li></ul><h2 id="OUTER-JOIN"><a href="#OUTER-JOIN" class="headerlink" title="OUTER JOIN"></a>OUTER JOIN</h2><p>返回table1和table2中所有行，如果任意一表中没有匹配的行，对应的列将返回NULL。</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">FULL</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">ON</span> conditional_expression ...<br></code></pre></td></tr></table></figure><p>基于上面的表可以写下面的连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">FULL</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> DEPARTMENT <span class="hljs-keyword">ON</span> COMPANY.ID <span class="hljs-operator">=</span> DEPARTMENT.EMP_ID;<br></code></pre></td></tr></table></figure><h1 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h1><p>UNION用于将两个或多个SELECT语句进行连接，合并输出其结果</p><p>UNION需要注意的是每个SELECT语句都必须有相同的列，列必须是相同的数据类型，每个SELECT语句的列顺序必须相同。</p><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1 [, column2 ]<br><span class="hljs-keyword">FROM</span> table1 [, table2 ]<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>]<br><br><span class="hljs-keyword">UNION</span><br><br><span class="hljs-keyword">SELECT</span> column1 [, column2 ]<br><span class="hljs-keyword">FROM</span> table1 [, table2 ]<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>]<br></code></pre></td></tr></table></figure><h2 id="UNION-ALL"><a href="#UNION-ALL" class="headerlink" title="UNION ALL"></a>UNION ALL</h2><p>如果需要取重复值的话，可以使用<code>UNION ALL</code>语句</p><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1 [, column2 ]<br><span class="hljs-keyword">FROM</span> table1 [, table2 ]<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>]<br><br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><br><span class="hljs-keyword">SELECT</span> column1 [, column2 ]<br><span class="hljs-keyword">FROM</span> table1 [, table2 ]<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>]<br></code></pre></td></tr></table></figure><p>好咯，今天就先学到这里吧~该去刷leetcode了，万恶的leetcode😒</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL学习记录——第一天</title>
    <link href="/2024/08/02/postgresql-study-first-day/"/>
    <url>/2024/08/02/postgresql-study-first-day/</url>
    
    <content type="html"><![CDATA[<p>昨天已经完成了PostgreSQL（后续和其他平台一样把这个简称为PG）的安装，今天就来逐步学吧。至于为什么从MySQL转移到PG，主要是因为以下几点：</p><ol><li>PG支持更多的数据类型</li><li>PG在所有配置上均支持ACID，而MySQL只能在部分情况下支持</li><li>PostgreSQL使用了多版本并发控制（MVCC）减少了出现死锁的概率</li><li>PostgreSQL支持更多的索引类型</li></ol><p>说完上面的就不得不提到简历上写了会MySQL然后被面试官无数次拷打的经历了（MongoDB我也写了，没人问，我还准备了蛮多的嘞）。</p><p>首先就是ACID是哪四个，莫名感觉是所有面试官都会想问。</p><p>其次是锁相关，S锁、X锁、IS锁、IX锁、未提交读、提交读、可重复读、串行化，呕。</p><p>然后就说索引B树B+树，前段时间面试才被问到过这个。</p><p>然后正式进入学习记录。</p><figure>  <img src="/2024/08/02/postgresql-study-first-day/start%20psql.png" class="" title="start PG">  <figcaption>start PG</figcaption></figure><p>在开启SQL Shell（psql）之前记得在cmd里打开PG服务。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>这部分内容太多太杂，就把比MySQL支持的更多的数据类型大概记一下吧（我自己按照资料写的，如果有缺少或者多了麻烦各位补充啊）</p><table><thead><tr><th>PostgreSQL数据类型</th><th>描述</th></tr></thead><tbody><tr><td>SERIAL</td><td>自增整数</td></tr><tr><td>BIGSERIAL</td><td>大范围自增整数</td></tr><tr><td>MONEY</td><td>货币金额</td></tr><tr><td>UUID</td><td>通用唯一标识符</td></tr><tr><td>CIDR</td><td>IPv4或IPv6网络地址</td></tr><tr><td>INET</td><td>IPv4或IPv6主机地址</td></tr><tr><td>MACADDR</td><td>MAC地址</td></tr><tr><td>BIT</td><td>定长位串</td></tr><tr><td>BIT VARYING</td><td>变长位串</td></tr><tr><td>BOX</td><td>平面中的矩形框</td></tr><tr><td>LINE</td><td>无限长的线</td></tr><tr><td>LSEG</td><td>线段</td></tr><tr><td>PATH</td><td>闭合路径</td></tr><tr><td>POINT</td><td>平面中的点</td></tr><tr><td>POLYGON</td><td>闭合的平面多边形</td></tr><tr><td>CIRCLE</td><td>平面中的圆</td></tr><tr><td>INTERVAL</td><td>时间间隔</td></tr><tr><td>TSVECTOR</td><td>文本搜索文档</td></tr><tr><td>TSQUERY</td><td>文本搜索查询</td></tr><tr><td>XML</td><td>XML数据</td></tr><tr><td>JSON</td><td>JSON数据</td></tr><tr><td>JSONB</td><td>二进制JSON数据，可索引</td></tr><tr><td>HSTORE</td><td>键值对存储</td></tr></tbody></table><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p><code>CREATE DATABASE dbname;</code></p><h2 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h2><p><code>\l</code> 查看数据库（莫名想到了Linux的ls -l）</p><p><code>\c</code> + <code>dbname</code> 进入数据库</p><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p><code>DROP DATABASE [IF EXISTS] name;</code></p><p>删除需要root权限，普通用户无法删除</p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h2 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name(<br>   column1 datatype,<br>   column2 datatype,<br>   column3 datatype,<br>   .....<br>   columnN datatype,<br>   <span class="hljs-keyword">PRIMARY</span> KEY( 一个或多个列 )<br>);<br></code></pre></td></tr></table></figure><p>例子</p><figure>  <img src="/2024/08/02/postgresql-study-first-day/table%20EX.png" class="" title="table EX">  <figcaption>table EX</figcaption></figure><p><code>\d</code>是查看当前已经存在的表格</p><p><code>\d tablename</code>是查看表格详情</p><figure>  <img src="/2024/08/02/postgresql-study-first-day/%E6%9F%A5%E7%9C%8B%E8%AF%A6%E6%83%85.png" class="" title="查看详情">  <figcaption>查看详情</figcaption></figure><h2 id="删除表格"><a href="#删除表格" class="headerlink" title="删除表格"></a>删除表格</h2><p><code>DROP TABLE table_name;</code></p><h1 id="PG模式（SCHEMA）"><a href="#PG模式（SCHEMA）" class="headerlink" title="PG模式（SCHEMA）"></a>PG模式（SCHEMA）</h1><p>第一眼看感觉有点像事务，但是事务是遵循ACID原则的并且通过MVCC来建立隔离，两者的逻辑不一样。</p><p>模式中可以包括视图、索引、数据类型、函数和操作等。</p><p>相同的名称可以运用于不同的模式而不报错，for example schema1和myschema都包含mytable的表。</p><p>模式的优势：</p><ul><li>允许多个用户操作数据库而不相互干扰</li><li>将数据库对象组织成逻辑便于管理（我的理解是我在做某个东西的时候我将一张表三个视图组织在一起，这个组织就可以一起被操作同时还可以单独操作，然后也可以对整个模式里的对象进行批量操作）</li><li>第三方应用的对象可以放在独立的模式中，这样它们就不会与其他对象的名称发生冲突。</li></ul><h2 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h2><p>语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SCHEMA myschema (<br>...<br>);<br></code></pre></td></tr></table></figure><p>创建表的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> myschema.mytable (<br>    column1 datatype1,<br>    column2 datatype2,<br>    ...<br>);<br></code></pre></td></tr></table></figure><p>上述语法是在一个叫myschema的模式下创建了一个叫mytable的表</p><p>例子</p><figure>  <img src="/2024/08/02/postgresql-study-first-day/create%20schema.png" class="" title="create schema">  <figcaption>create schema</figcaption></figure><p>这里我们建立了一个模式和一个表，中间由于手误少了一个’,’。</p><h2 id="删除模式"><a href="#删除模式" class="headerlink" title="删除模式"></a>删除模式</h2><p>删除一个空的模式（里面的对象已经全部被删除了）</p><p><code>DROP SCHEMA myschema;</code></p><p>删除一个模式及其下面的对象</p><p><code>DROP SCHEMA myschema CASSADE;</code></p><h1 id="INSERT-INTO-语句"><a href="#INSERT-INTO-语句" class="headerlink" title="INSERT INTO 语句"></a>INSERT INTO 语句</h1><p>语法如下</p><p><code>INSERT INTO TABLE_NAME (column1, column2, column3,...columnN) VALUES (value1, value2, value3,...valueN);</code></p><p>需要注意的是column和value需要数量一样，一一对应</p><p>对所有字段均添加值的语法如下</p><p><code>INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);</code></p><table><thead><tr><th>序号</th><th>输出信息&amp;描述</th></tr></thead><tbody><tr><td>1</td><td>INSERT oid 1 直插入一行且表中具备OID的返回信息，那么oid就分配给被插入行</td></tr><tr><td>2</td><td>INSERT 0 # 插入多行，#为插入行数</td></tr></tbody></table><p>例子</p><p>这里先创建一个表</p><figure>  <img src="/2024/08/02/postgresql-study-first-day/create%20company.png" class="" title="create table">  <figcaption>create table</figcaption></figure><figure>  <img src="/2024/08/02/postgresql-study-first-day/insert%20into.png" class="" title="insert into">  <figcaption>insert into</figcaption></figure><p>这里我们从上到下分别来看</p><ul><li>给表里插入数据</li><li>给表里插入忽略SALARY的数据</li><li>插入语句 JOIN_DATE 字段使用 DEFAULT 子句来设置默认值，而不是指定值</li><li>插入多行</li><li>查询数据</li></ul><h1 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h1><p>这里就不多说了，不会的拖出去乱棍打死。和MySQL之类的一摸一样。</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>PG的运算符一般用在<code>WHERE</code>中<br>有四个</p><ul><li>算术运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>按位运算符</li></ul><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><figure>  <img src="/2024/08/02/postgresql-study-first-day/%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6.png" class="" title="算术运算符">  <figcaption>算术运算符</figcaption></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td><td>(a &#x3D; b) 为 false。</td></tr><tr><td>!&#x3D;</td><td>不等于</td><td>(a !&#x3D; b) 为 true。</td></tr><tr><td>&lt;&gt;</td><td>不等于</td><td>(a &lt;&gt; b) 为 true。</td></tr><tr><td>&gt;</td><td>大于</td><td>(a &gt; b) 为 false。</td></tr><tr><td>&lt;</td><td>小于</td><td>(a &lt; b) 为 true。</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td><td>(a &gt;&#x3D; b) 为 false。</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td><td>(a &lt;&#x3D; b) 为 true。</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th>序号</th><th>运算符 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>AND</strong></td></tr><tr><td></td><td>逻辑与运算符。如果两个操作数都非零，则条件为真。</td></tr><tr><td></td><td>PostgresSQL 中的 WHERE 语句可以用 AND 包含多个过滤条件。</td></tr><tr><td>2</td><td><strong>NOT</strong></td></tr><tr><td></td><td>逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td></tr><tr><td></td><td>PostgresSQL 有 NOT EXISTS, NOT BETWEEN, NOT IN 等运算符。</td></tr><tr><td>3</td><td><strong>OR</strong></td></tr><tr><td></td><td>逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td></tr><tr><td></td><td>PostgresSQL 中的 WHERE 语句可以用 OR 包含多个过滤条件。</td></tr></tbody></table><h3 id="三值逻辑系统"><a href="#三值逻辑系统" class="headerlink" title="三值逻辑系统"></a>三值逻辑系统</h3><table><thead><tr><th>a</th><th>b</th><th>a AND b</th><th>a OR b</th></tr></thead><tbody><tr><td>TRUE</td><td>TRUE</td><td>TRUE</td><td>TRUE</td></tr><tr><td>TRUE</td><td>FALSE</td><td>FALSE</td><td>TRUE</td></tr><tr><td>TRUE</td><td>NULL</td><td>NULL</td><td>TRUE</td></tr><tr><td>FALSE</td><td>FALSE</td><td>FALSE</td><td>FALSE</td></tr><tr><td>FALSE</td><td>NULL</td><td>FALSE</td><td>NULL</td></tr><tr><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr></tbody></table><table><thead><tr><th>a</th><th>NOT a</th></tr></thead><tbody><tr><td>TRUE</td><td>FALSE</td></tr><tr><td>FALSE</td><td>TRUE</td></tr><tr><td>NULL</td><td>NULL</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><figure>  <img src="/2024/08/02/postgresql-study-first-day/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.png" class="" title="位运算符">  <figcaption>位运算符</figcaption></figure><h3 id="按位运算符"><a href="#按位运算符" class="headerlink" title="按位运算符"></a>按位运算符</h3><figure>  <img src="/2024/08/02/postgresql-study-first-day/%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.png" class="" title="按位运算符">  <figcaption>按位运算符</figcaption></figure><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, columnN<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">CONDITION</span> <span class="hljs-operator">|</span> EXPRESSION];<br></code></pre></td></tr></table></figure><h2 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h2><p>根据一个指定条件来读取数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, columnN<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> SINGLE <span class="hljs-keyword">VALUE</span> MATCHTING EXPRESSION;<br></code></pre></td></tr></table></figure><h2 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> numerical_expression <span class="hljs-keyword">as</span>  OPERATION_NAME<br>[<span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">CONDITION</span>] ;<br></code></pre></td></tr></table></figure><p>PG还有内置计算函数（这个好像都有吧sum、avg这些）</p><h2 id="日期表达式"><a href="#日期表达式" class="headerlink" title="日期表达式"></a>日期表达式</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>;<br></code></pre></td></tr></table></figure><p>返回当前日期</p><h1 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h1><p>这部分内容和MySQL差不多<br>WHERE的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, columnN<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> [condition1]<br></code></pre></td></tr></table></figure><p>还可以使用比较运算符或逻辑运算符<br>AND, OR, NOT NULL, LIKE, NOT IN, BETWEEN, 子查询</p><h1 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h1><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> table_name<br><span class="hljs-keyword">SET</span> column1 <span class="hljs-operator">=</span> value1, column2 <span class="hljs-operator">=</span> value2...., columnN <span class="hljs-operator">=</span> valueN<br><span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">condition</span>];<br></code></pre></td></tr></table></figure><h1 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h1><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">condition</span>];<br></code></pre></td></tr></table></figure><h1 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h1><p>和MySQL一样，都是进行匹配<br>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;XXXX%&#x27;</span>;<br>或者<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%XXXX%&#x27;</span>;<br>或者<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;XXXX_&#x27;</span>;<br>或者<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_XXXX&#x27;</span>;<br>或者<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_XXXX_&#x27;</span>;<br></code></pre></td></tr></table></figure><h1 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h1><p>作用就是限制查询条数</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, columnN<br><span class="hljs-keyword">FROM</span> table_name<br>LIMIT [<span class="hljs-keyword">no</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">rows</span>]<br></code></pre></td></tr></table></figure><p>和OFFSET一起用的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, columnN <br><span class="hljs-keyword">FROM</span> table_name<br>LIMIT [<span class="hljs-keyword">no</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">rows</span>] <span class="hljs-keyword">OFFSET</span> [<span class="hljs-type">row</span> num]<br></code></pre></td></tr></table></figure><h1 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h1><p><code>ORDER BY</code>是用来对一列或多列进行排序的（升序或降序）</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span><span class="hljs-operator">-</span>list<br><span class="hljs-keyword">FROM</span> table_name<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>]<br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column1, column2, .. columnN] [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>];<br></code></pre></td></tr></table></figure><p>ASC 表示升序，DESC 表示降序。</p><h1 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h1><p><code>GROUP BY</code>用来和<code>SELECT</code>语句一起使用，对数据进行分组。</p><p><code>GROUP BY</code> 在一个 <code>SELECT</code> 语句中，放在 <code>WHERE</code> 子句的后面，<code>ORDER BY</code> 子句的前面。</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span><span class="hljs-operator">-</span>list<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> [ conditions ]<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> column1, column2....columnN<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column1, column2....columnN<br></code></pre></td></tr></table></figure><h1 id="WITH"><a href="#WITH" class="headerlink" title="WITH"></a>WITH</h1><p>WITH主要用来辅助将复杂的查询拆分成简单的表单，便于阅读，也可以当作为查询存在的临时表。</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span><br>   name_for_summary_data <span class="hljs-keyword">AS</span> (<br>      <span class="hljs-keyword">SELECT</span> Statement)<br>   <span class="hljs-keyword">SELECT</span> columns<br>   <span class="hljs-keyword">FROM</span> name_for_summary_data<br>   <span class="hljs-keyword">WHERE</span> conditions <span class="hljs-operator">&lt;=&gt;</span> (<br>      <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span><br>      <span class="hljs-keyword">FROM</span> name_for_summary_data)<br>   [<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> columns]<br></code></pre></td></tr></table></figure><p><code>name_for_summary_data</code> 是 WITH 子句的名称，<code>name_for_summary_data</code> 可以与现有的表名相同，并且具有优先级。</p><p>可以在 WITH 中使用数据 INSERT, UPDATE 或 DELETE 语句，允许您在同一个查询中执行多个不同的操作。</p><h2 id="WITH-递归"><a href="#WITH-递归" class="headerlink" title="WITH 递归"></a>WITH 递归</h2><p>在 WITH 子句中可以使用自身输出的数据。</p><p>公用表表达式 (CTE) 具有一个重要的优点，那就是能够引用其自身，从而创建递归 CTE。递归 CTE 是一个重复执行初始 CTE 以返回数据子集直到获取完整结果集的公用表表达式。</p><h1 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h1><p>HAVING子句用来筛选分组后的各组数据。</p><p>WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。</p><p>HAVING在SELECT语句中的位置</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">FROM</span><br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br><span class="hljs-keyword">HAVING</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br></code></pre></td></tr></table></figure><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2<br><span class="hljs-keyword">FROM</span> table1, table2<br><span class="hljs-keyword">WHERE</span> [ conditions ]<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> column1, column2<br><span class="hljs-keyword">HAVING</span> [ conditions ]<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column1, column2<br></code></pre></td></tr></table></figure><h1 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h1><p>和<code>SELECT</code>一起用，用于去重</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> column1, column2,.....columnN<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">condition</span>]<br></code></pre></td></tr></table></figure><p>好了，基本的操作到这里也就结束了，完结撒花~</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL安装记录及集群初始化失败问题解决</title>
    <link href="/2024/08/01/install-postgreSQL/"/>
    <url>/2024/08/01/install-postgreSQL/</url>
    
    <content type="html"><![CDATA[<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>Windows 11</p><p>PostgreSQL 16.3</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>下载PostgreSQL可以直接通过官网<a href="https://www.postgresql.org/">https://www.postgresql.org/</a></p><p>进入官网后点击图片中的Download，也可以通过Navbar中的Download直接进入对应页面。由于网络不稳定图片中的链接可能会不稳定，所以可以通过第二种方法进入对应页面，两种方法所到达的是同一页面。</p><p>![Download Page](&#x2F;img&#x2F;Download Page.png)</p><p>选择对应的系统进行下载，我这边选择的是Windows，所以直接进入Windows的页面。</p><p>进入后直接点击Download the Installer，进去后再次选择对应的系统和你想要的版本。</p><p><img src="/../img/System%20choice.png" alt="Choice your System"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>这里必须要注意一个事情，如果说遇到了在快要完成的时候出现<br>Problem running post-install step. Installation may not complete correctly. The database cluster initialisation failed.<br>这时切记去看后面的说明，我会把我这么解决的说清楚。</p><p>打开下载好的exe文件后就是这个页面</p><p><img src="/../img/postSQL%20first%20setup.png" alt="First Pic"><br>在这一步记得改一下安装地址，最好别放在C盘（当然只有C盘的话当我没说）</p><p><img src="/../img/PostSQL%20second%20page.png" alt="Second Pic"></p><p><img src="/../img/Select%20Components.png" alt="Third Pic"><br>该图中四个模块我们一一来介绍一下：</p><ol><li><p>PostgreSQL Server</p><p> 该部分属于数据库系统的核心部分，负责处理数据库的存储、检索和管理操作。所有操作都是通过这个部分来进行的（谁不选头拧下来当球踢）。</p></li><li><p>pgAdmin 4</p><p> 一个功能强大的开源管理工具，提供了一个GUI来辅助用户进行各种操作。</p></li><li><p>Stack Builder</p><p> 这部分属于附加组件，为用户外提供了一些可以安装的模块，如PostGIS（地理信息系统扩展）、pgAgent（调度工具）、pgBouncer（连接池管理器）。</p></li><li><p>Command Line Tools</p><p> 这个是PostgreSQL提供的命令行工具，有多个工具组成</p><ul><li>psql：交互式SQL命令行工具，允许用户执行SQL查询和脚本。</li><li>pg_dump：用于备份数据库。</li><li>pg_restore：用于恢复数据库。</li><li>pg_ctl：用于启动、停止和重启PostgreSQL服务器。</li></ul><p> 这些工具适用于脚本化和自动化数据库管理任务，特别是在没有图形界面的环境中。</p></li></ol><p>这里的Data Directory是和我们前面设置的安装地址是捆绑的，如果改为其他盘会直接被修改。不过为了保险起见先查看一下再点Next。</p><p><img src="/../img/Data%20Directory.png" alt="alt text"><br>在这里我们需要注意的是这个密码是我们数据库管理员的密码，也有就是root用户密码。</p><p><img src="/img/Password.png" alt="Fifth Pic"></p><p>这里的端口直接默认然后继续。</p><p><img src="/img/Port.png" alt="Sixth Pic"></p><p>这里选好自己需要的语言</p><p><img src="/../img/Advanced%20Options.png" alt="Seventh Pic"><br>最后确定好安装信息就可以开始安装了。</p><p>这个如果不需要可以不打勾</p><p><img src="/../img/Stack%20Builder.png" alt="Eight Pic"></p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>用<code>Win</code> + <code>s</code>打开搜索找到这个软件。</p><p><img src="/../img/Open%20PgAdmin4.png" alt="First Pic"></p><p>成功安装的话这里会弹出让我们去填写密码的弹窗，如果没有点一下侧边栏的Servers。这里推荐重新创建一个密码，如果实在懒也可以使用我们root用户的</p><p><img src="/../img/Connect%20to%20Server.png" alt="Second Pic"></p><p>最后成功安装并检验成功就会得到这个页面</p><p><img src="/img/Finish.png" alt="Finish"></p><h1 id="后记——解决问题"><a href="#后记——解决问题" class="headerlink" title="后记——解决问题"></a>后记——解决问题</h1><p>在我查找资料过程中发现，国内外无数人在安装过程中都遇到了集群初始化失败的问题。这里我们需要明白一个事情，单纯的卸载重装没有用处（我重装两次都一样！气死我了！）</p><p>接下来我们就需要来完整的说明我们需要怎么去做。</p><ol><li>首先在我们卸载后需要清除我们的注册表win+r ，输入regedit.exe 回车，编辑&gt;查找&gt;输入postgresql&gt;删除相关内容（应该是两个）</li><li>关闭防火墙，如果用的火绒开启免打扰</li><li>输入<code>win</code>+<code>R</code>然后输入cmd，使用<code>Ctrl</code>+<code>Shift</code>+<code>Enter</code>通过管理员打开命令窗口</li><li>使用<code>net user postgres /delete</code>来删除可能已经存在的postgres</li><li>使用<code>net user /add postgres &lt;password&gt;</code>来建立用户，这里记得换成自己的password</li><li>使用<code>net localgroup administrators postgres /add</code>将 postgres 用户添加到管理员组</li><li>用<code>net localgroup &quot;power users&quot; postgres /add</code>将 postgres 用户添加到 Power Users 组</li><li>接下来直接找到我们前面下载的exe文件，右键然后选择<em><strong>以管理员身份运行</strong></em>。这里必须再次强调一点，使用这个方法的原因是因为直接使用命令行去运行exe文件依旧存在问题，所以选择跳出命令行去执行。这样理论上是可以完成安装，后续可以按照正常安装顺序去安装。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——Hash</title>
    <link href="/2024/08/01/Hash/"/>
    <url>/2024/08/01/Hash/</url>
    
    <content type="html"><![CDATA[<p>今天来说一下leetcode面试经典150题中哈希表部分的题</p><h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383 赎金信"></a>383 赎金信</h1><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code>，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p>示例 1：</p><p>输入：ransomNote &#x3D; “a”, magazine &#x3D; “b”</p><p>输出：false</p><p>示例 2：</p><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “ab”</p><p>输出：false</p><p>示例 3：</p><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “aab”</p><p>输出：true</p><p>提示：</p><p><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></p><p><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>看到题目第一眼，需要用hash来对元素进行统计</li><li>可以利用Counter()函数来实现统计</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canConstruct</span>(<span class="hljs-params">self, ransomNote: <span class="hljs-built_in">str</span>, magazine: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        cnt = Counter(magazine)<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> ransomNote:<br>            <span class="hljs-keyword">if</span> c <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> cnt <span class="hljs-keyword">or</span> cnt[c] == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            cnt[c] -= <span class="hljs-number">1</span><br>            <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(m + n)，执行时间54ms，消耗内存16.4MB</p><h1 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205 同构字符串"></a>205 同构字符串</h1><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，判断它们是否是同构的。</p><p>如果 <code>s</code> 中的字符可以按某种映射关系替换得到 <code>t</code> ，那么这两个字符串是同构的。</p><p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p><p>示例 1:</p><p>输入：s &#x3D; <code>&quot;egg&quot;</code>, t &#x3D; <code>&quot;add&quot;</code></p><p>输出：true</p><p>示例 2：</p><p>输入：s &#x3D; <code>&quot;foo&quot;</code>, t &#x3D; <code>&quot;bar&quot;</code></p><p>输出：false</p><p>示例 3：</p><p>输入：s &#x3D; <code>&quot;paper&quot;</code>, t &#x3D; <code>&quot;title&quot;</code></p><p>输出：true</p><p>提示：</p><p><code>1 &lt;= s.length &lt;= 5 * 104</code></p><p><code>t.length == s.length</code></p><p><code>s</code> 和 <code>t</code> 由任意有效的 ASCII 字符组成</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li>首先明确每个字符是需要和自己当前位置所对应的索引直接对应到另一字符串，说人话就是<code>i[1]</code>的对应到<code>j[1]</code>上。</li><li>在前面的基础上，需要一一对应也就可以转换为s的和t的两个交换位置后所形成的字符串并不会和原本的字符串不同，只是平移了</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isIsomorphic</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        h1 = &#123;&#125;<br>        h2 = &#123;&#125;<br>        <span class="hljs-keyword">for</span> sc, tc <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(s, t):<br>            <span class="hljs-keyword">if</span> (sc <span class="hljs-keyword">in</span> h1 <span class="hljs-keyword">and</span> h1[sc] != tc) <span class="hljs-keyword">or</span> (tc <span class="hljs-keyword">in</span> h2 <span class="hljs-keyword">and</span> h2[tc] != sc):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            h1[sc] = tc<br>            h2[tc] = sc<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间49ms，消耗内存16.4MB</p><h1 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290 单词规律"></a>290 单词规律</h1><p>给定一种规律 <code>pattern</code> 和一个字符串 <code>s</code> ，判断 <code>s</code> 是否遵循相同的规律。</p><p>这里的 遵循 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>s</code> 中的每个非空单词之间存在着双向连接的对应规律。</p><p>示例1:</p><p>输入: pattern &#x3D; <code>&quot;abba&quot;</code>, s &#x3D; <code>&quot;dog cat cat dog&quot;</code></p><p>输出: true</p><p>示例 2:</p><p>输入:pattern &#x3D; <code>&quot;abba&quot;</code>, s &#x3D; <code>&quot;dog cat cat fish&quot;</code></p><p>输出: false</p><p>示例 3:</p><p>输入: pattern &#x3D; <code>&quot;aaaa&quot;</code>, s &#x3D; <code>&quot;dog cat cat dog&quot;</code></p><p>输出: false</p><p>提示:</p><p><code>1 &lt;= pattern.length &lt;= 300</code></p><p><code>pattern</code> 只包含小写英文字母</p><p><code>1 &lt;= s.length &lt;= 3000</code></p><p><code>s</code> 只包含小写英文字母和 <code>&#39; &#39;</code></p><p><code>s</code> <strong>不包含</strong> 任何前导或尾随对空格</p><p><code>s</code> 中每个单词都被 <strong>单个空格</strong> 分隔</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ol><li>首先我们需要将我们s中的单词进行分割，然后再开始匹配</li><li>后续匹配思路和前一题一样</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordPattern</span>(<span class="hljs-params">self, pattern: <span class="hljs-built_in">str</span>, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        words = s.split(<span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pattern) != <span class="hljs-built_in">len</span>(words):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        h1 = &#123;&#125;<br>        h2 = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, word <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(pattern, words):<br>            <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> h1 <span class="hljs-keyword">and</span> h1[i] != word) <span class="hljs-keyword">or</span> (word <span class="hljs-keyword">in</span> h2 <span class="hljs-keyword">and</span> h2[word] != i):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            h1[i] = word<br>            h2[word] = i<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(m + n)，执行时间45ms，消耗内存16.3MB</p><h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242 有效的字母异位词"></a>242 有效的字母异位词</h1><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。</p><p>注意：若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code> 互为字母异位词。</p><p>示例 1:</p><p>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”</p><p>输出: true</p><p>示例 2:</p><p>输入: s &#x3D; “rat”, t &#x3D; “car”</p><p>输出: false</p><p>提示:</p><p><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></p><p><code>s</code> 和 <code>t</code> 仅包含小写字母</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><p>用一个defaultdict存储s中的数量，如果t中存在就减少一个，逐个匹配</p><h3 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h3><p>用一个hash表来存储所有的字符和数量，一一匹配，存在就-1。最后记得delete我们的hash并输出结果</p><h3 id="第一版代码"><a href="#第一版代码" class="headerlink" title="第一版代码"></a>第一版代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAnagram</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) != <span class="hljs-built_in">len</span>(t):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        dic = defaultdict(<span class="hljs-built_in">int</span>)<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>            dic[c] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> t:<br>            dic[c] -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> dic.values():<br>            <span class="hljs-keyword">if</span> val != <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="第二版代码"><a href="#第二版代码" class="headerlink" title="第二版代码"></a>第二版代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAnagram</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) != <span class="hljs-built_in">len</span>(t):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        char_count = &#123;&#125;<br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:<br>            char_count[char] = char_count.get(char, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> t:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> char_count:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            char_count[char] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> char_count[char] == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">del</span> char_count[char]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(char_count) == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="第一版-1"><a href="#第一版-1" class="headerlink" title="第一版"></a>第一版</h3><p>时间复杂度O(n)，执行时间44ms，消耗内存16.4MB</p><h3 id="第二版-1"><a href="#第二版-1" class="headerlink" title="第二版"></a>第二版</h3><p>时间复杂度O(n)，执行时间50ms，消耗内存16.3MB</p><h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49 字母异位词分组"></a>49 字母异位词分组</h1><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p>示例 1:</p><p>输入: strs &#x3D; <code>[&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code></p><p>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</p><p>示例 2:</p><p>输入: strs &#x3D; <code>[&quot;&quot;]</code></p><p>输出: [[“”]]</p><p>示例 3:</p><p>输入: strs &#x3D; <code>[&quot;a&quot;]</code></p><p>输出: [[“a”]]</p><p>提示：</p><p><code>1 &lt;= strs.length &lt;= 104</code></p><p><code>0 &lt;= strs[i].length &lt;= 100</code></p><p><code>strs[i]</code> 仅包含小写字母</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><ol><li>见到题目第一时间想到两件事情，第一用hash存储键值对，和前面的题类似用值来进行匹配；第二字母异构意味着两个“单词”之间的字母都是一样的，也就是说经过排序可以得到相同的东西</li><li>通过sorted进行排序后，该字符将之间转换为按照字母顺序排序的字符。这时后续如果还存在和他一样字符就会被加入到hash中，最后我们直接忽略key，输出values就可以得到预期结果</li></ol><p>提示：这里我们使用defaultdict(list)是需要利用list作为默认值，会在不存在的键上初始化一个默认值。而我们使用{}字典则不会这样做，会造成测试样例中strs为空的情况下运行失败。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:<br>        <span class="hljs-built_in">dict</span> = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> strs:<br>            tmp = <span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">sorted</span>(s))<br>            <span class="hljs-keyword">if</span> tmp <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>:<br>                <span class="hljs-built_in">dict</span>[tmp].append(s)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">dict</span>[tmp] = [s]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>.values())<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(m * n log n)，执行时间58ms，消耗内存19.1MB</p><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1 两数之和"></a>1 两数之和</h1><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <code>target</code>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</p><p>输出：[0,1]</p><p>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</p><p>示例 2：</p><p>输入：nums &#x3D; [3,2,4], target &#x3D; 6</p><p>输出：[1,2]</p><p>示例 3：</p><p>输入：nums &#x3D; [3,3], target &#x3D; 6</p><p>输出：[0,1]</p><p>提示：</p><p><code>2 &lt;= nums.length &lt;= 104</code></p><p><code>-109 &lt;= nums[i] &lt;= 109</code></p><p><code>-109 &lt;= target &lt;= 109</code></p><p><strong>只会存在一个有效答案</strong></p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>需要两个数也就是两个指针，当i指向的和j指向的加和能够等于target就直接输出</p><p>提示：用hash去做更快，该思路是用两个循环去做的。后续也会附上用hash去做的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] == target:<br>                    <span class="hljs-keyword">return</span> [i, j]<br></code></pre></td></tr></table></figure><p>用hash去做的代码如下，这个代码整体会比前面的按照题目直译去做快很多，如果只是为了对付笔试可以用前一个，但是面试最好还是用hash，毕竟面试官看你做leetcode第一题都只会用循环去硬怼印象分肯定大打折扣。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pyhton">class Solution:<br>    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:<br>        dic = &#123;&#125;<br>        for i, num in enumerate(nums):<br>            if target - num in dic:<br>                return [dic[target-num], i]<br>            dic[num] = i<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="双循环"><a href="#双循环" class="headerlink" title="双循环"></a>双循环</h3><p>时间复杂度$O(n^2)$，执行时间1824ms，消耗内存17MB</p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>时间复杂度O(n)，执行时间42ms，消耗内存17.6MB</p><h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202 快乐数"></a>202 快乐数</h1><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</p><p>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</p><p>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</p><p>如果 <code>n</code> 是 快乐数 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p>示例 1：</p><p>输入：n &#x3D; 19</p><p>输出：true</p><p>解释：</p><p>12 + 92 &#x3D; 82</p><p>82 + 22 &#x3D; 68</p><p>62 + 82 &#x3D; 100</p><p>12 + 02 + 02 &#x3D; 1</p><p>示例 2：</p><p>输入：n &#x3D; 2</p><p>输出：false</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 231 - 1</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><ol><li>一个函数用set去存储已经出现过的数字，每次循环时将n加入到这个set中</li><li>循环的停止条件为等于1和在seen中</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isHappy</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        seen = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">while</span> n != <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> n <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:<br>            seen.add(n)<br>            n = <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">int</span>(i)**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(n))<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间44ms，消耗内存16.3MB</p><h1 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219 存在重复元素 II"></a>219 存在重复元素 II</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，判断数组中是否存在两个 <strong>不同的索引</strong> <code>i</code> 和 <code>j</code> ，满足 <code>nums[i] == nums[j]</code> 且 <code>abs(i - j) &lt;= k</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3,1], k &#x3D; 3</p><p>输出：true</p><p>示例 2：</p><p>输入：nums &#x3D; [1,0,1,1], k &#x3D; 1</p><p>输出：true</p><p>示例 3：</p><p>输入：nums &#x3D; [1,2,3,1,2,3], k &#x3D; 2</p><p>输出：false</p><p>提示：</p><p><code>1 &lt;= nums.length &lt;= 105</code></p><p><code>-109 &lt;= nums[i] &lt;= 109</code></p><p><code>0 &lt;= k &lt;= 105</code></p><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>用哈希表存索引和值，只要然后按照题目所给的True判断条件写代码。不要忽略最后需要一个False，不然会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">containsNearbyDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        dic = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> num <span class="hljs-keyword">in</span> dic <span class="hljs-keyword">and</span> i - dic[num] &lt;= k:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            dic[num] = i<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间91ms，消耗内存29.3MB</p><h1 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128 最长连续序列"></a>128 最长连续序列</h1><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>明确一点，当我们当前num的前一个数不在我们的hash中，我们就默认当前序列从num开始。那么结束便是当前num的后一个数不在hash中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestConsecutive</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        res = <span class="hljs-number">0</span><br>        num_count = <span class="hljs-built_in">set</span>(nums)<br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> num_count:<br>            <span class="hljs-keyword">if</span> (num - <span class="hljs-number">1</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> num_count:<br>                num_len = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">while</span> (num + <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> num_count:<br>                    num_len += <span class="hljs-number">1</span><br>                    num += <span class="hljs-number">1</span><br>                res = <span class="hljs-built_in">max</span>(res, num_len)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间104ms，消耗内存32.6MB</p><p>根据这个集合给出的题目来看，hash这部分的题目已简单题或中等题考察居多，核心逻辑都是一个——利用hash特有的键值对去进行匹配等操作，所以把握好本质就比较简单了。不过真的不想遇到hash，脑子一转不过来就完犊子。</p><p>最后附上封面的猫猫图片（在这里还是要夸一下iPhone的微距，拍出来真的不错  ）<br><img src="/../img/hash%20blog%20cover.jpg" alt="hash cover"></p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——矩阵</title>
    <link href="/2024/07/30/my-fourth-blog/"/>
    <url>/2024/07/30/my-fourth-blog/</url>
    
    <content type="html"><![CDATA[<p>这篇Blog将分享我在做leetcode面试经典150题中矩阵部分几道题的做题思路和代码。</p><h1 id="36-有效的数组"><a href="#36-有效的数组" class="headerlink" title="36 有效的数组"></a>36 有效的数组</h1><p>请你判断一个 <code>9 x 9</code> 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p><p>数字 <code>1-9</code> 在每一行只能出现一次。<br>数字 <code>1-9</code> 在每一列只能出现一次。<br>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</p><p>注意：</p><p>一个有效的数独（部分已被填充）不一定是可解的。</p><p>只需要根据以上规则，验证已经填入的数字是否有效即可。</p><p>空白格用 <code>&#39;.&#39;</code> 表示。</p><p>示例 1：</p><p><img src="/../img/%E6%9C%89%E6%95%88%E6%95%B0%E7%8B%AC_%E7%A4%BA%E4%BE%8B1.png" alt="示例 1"></p><p>输入：board &#x3D; </p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">[[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>]<br>,[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>,[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br></code></pre></td></tr></table></figure><p>输出：true</p><p>示例 2：</p><p>输入：board &#x3D; </p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">[[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>]<br>,[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>,[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br></code></pre></td></tr></table></figure><p>输出：false</p><p>解释：除了第一行的第一个数字从 <strong>5</strong> 改为 <strong>8</strong> 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</p><p>提示：</p><p><code>board.length == 9</code></p><p><code>board[i].length == 9</code></p><p><code>board[i][j]</code> 是一位数字<code>（1-9）</code>或者 <code>&#39;.&#39;</code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>核心条件就是每行每列每3*3的区域内不能重复</li><li>设置一个索引b来表示该数字在3*3区域内的索引<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidSudoku</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 初始化三个二维列表来跟踪三个维度的数字情况</span><br>        row = [[<span class="hljs-number">0</span>] * <span class="hljs-number">9</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]<br>        col = [[<span class="hljs-number">0</span>] * <span class="hljs-number">9</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]<br>        block = [[<span class="hljs-number">0</span>] * <span class="hljs-number">9</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>                <span class="hljs-keyword">if</span> board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>:<br>                    num = <span class="hljs-built_in">int</span>(board[i][j]) - <span class="hljs-number">1</span> <span class="hljs-comment"># 将数字字符转化为整数并调整为0索引</span><br>                    b = (i // <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + j // <span class="hljs-number">3</span> <span class="hljs-comment"># 建立b索引</span><br>                    <span class="hljs-keyword">if</span> row[i][num] <span class="hljs-keyword">or</span> col[j][num] <span class="hljs-keyword">or</span> block[b][num]:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                    row[i][num] = col[j][num] = block[b][num] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(1)，执行时间56ms，消耗内存16.2MB</p><h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54 螺旋矩阵"></a>54 螺旋矩阵</h1><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong>，返回矩阵中的所有元素。</p><p>示例 1：</p><p><img src="/../img/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5_%E7%A4%BA%E4%BE%8B1.jpg" alt="示例 1"></p><p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</p><p>输出：[1,2,3,6,9,8,7,4,5]</p><p>示例 2：</p><p><img src="/../img/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5_%E7%A4%BA%E4%BE%8B2.jpg" alt="示例 2"></p><p>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</p><p>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p><p>提示：</p><p><code>m == matrix.length</code></p><p><code>n == matrix[i].length</code></p><p><code>1 &lt;= m, n &lt;= 10</code></p><p><code>-100 &lt;= matrix[i][j] &lt;= 100</code></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>相当于走格子，第一行走完走最后一列，最后一列走完走最后一行，最后一行走完走第一列，最后各自缩小一格然后走内侧。</p><p>提示：这里需要注意，从左到右遍历顶部行的时候不能用<code>[0]</code>来表示，会影响后续。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spiralOrder</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> matrix: <span class="hljs-keyword">return</span> []<br>        left, right, top, bottom = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(matrix) - <span class="hljs-number">1</span><br>        res = []<br>        <span class="hljs-keyword">while</span> left &lt;= right <span class="hljs-keyword">and</span> top &lt;= bottom:<br>            <span class="hljs-comment"># 从左到右遍历顶部行</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left, right + <span class="hljs-number">1</span>):<br>                res.append(matrix[top][i])<br>            <span class="hljs-comment"># 从上到下遍历右侧列</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(top + <span class="hljs-number">1</span>, bottom + <span class="hljs-number">1</span>):<br>                res.append(matrix[j][right])<br>            <span class="hljs-keyword">if</span> left &lt; right <span class="hljs-keyword">and</span> top &lt; bottom:<br>                <span class="hljs-comment"># 从右到左遍历底部行</span><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(right - <span class="hljs-number">1</span>, left, -<span class="hljs-number">1</span>):<br>                    res.append(matrix[bottom][i])<br>                <span class="hljs-comment"># 从下到上遍历左侧列</span><br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(bottom, top, -<span class="hljs-number">1</span>):<br>                    res.append(matrix[j][left])<br>            left, right, top, bottom = left + <span class="hljs-number">1</span>, right - <span class="hljs-number">1</span>, top + <span class="hljs-number">1</span>, bottom - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(m*n)，执行用时55ms，消耗内存16.4MB</p><h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48 旋转图像"></a>48 旋转图像</h1><p>给定一个 n × n 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 <code>90</code> 度。</p><p>你必须在 <em><strong>原地</strong></em> 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p>示例 1：</p><p><img src="/../img/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F_%E7%A4%BA%E4%BE%8B1.jpg" alt="示例 1"></p><p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</p><p>输出：[[7,4,1],[8,5,2],[9,6,3]]</p><p>示例 2：</p><p><img src="/../img/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F_%E7%A4%BA%E4%BE%8B2.jpg" alt="示例 2"></p><p>输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</p><p>输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p><p>提示：</p><p><code>n == matrix.length == matrix[i].length</code></p><p><code>1 &lt;= n &lt;= 20</code></p><p><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ol><li>先明确题目要求是讲整个矩阵顺时针旋转90°</li><li>根据每个元素坐标来看，我们只需要将每个元素的坐标交换，最后将整个图像进行逐行反转就能直接完成</li></ol><p>下面有一个比较形象的图来演示一下过程</p><p><img src="/../img/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F_%E6%BC%94%E7%A4%BA.jpg" alt="演示"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        n = <span class="hljs-built_in">len</span>(matrix)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, n):<br>                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            matrix[i].reverse()<br>        <span class="hljs-keyword">return</span> matrix<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O($n^2$)，执行时间36ms，消耗内存16.5MB</p><h1 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73 矩阵置零"></a>73 矩阵置零</h1><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <em><strong>原地</strong></em> 算法。</p><p>示例 1：</p><p><img src="/../img/%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6_%E7%A4%BA%E4%BE%8B1.jpg" alt="示例 1"></p><p>输入：matrix &#x3D; [[1,1,1],[1,0,1],[1,1,1]]</p><p>输出：[[1,0,1],[0,0,0],[1,0,1]]</p><p>示例 2：</p><p><img src="/../img/%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6_%E7%A4%BA%E4%BE%8B2.jpg" alt="示例 2"></p><p>输入：matrix &#x3D; [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</p><p>输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</p><p>提示：</p><p><code>m == matrix.length</code></p><p><code>n == matrix[0].length</code></p><p><code>1 &lt;= m, n &lt;= 200</code></p><p><code>-231 &lt;= matrix[i][j] &lt;= 231 - 1</code></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ol><li>设置两个集合来存储横纵坐标。</li><li>两次遍历，第一次遍历标记为0的元素横纵坐标并分别添加到set中，第二次遍历对元素进行修改。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setZeroes</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> matrix <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(matrix) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> matrix<br>        rows, cols = <span class="hljs-built_in">set</span>(), <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span>:<br>                    rows.add(i)<br>                    cols.add(j)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> rows <span class="hljs-keyword">or</span> j <span class="hljs-keyword">in</span> cols:<br>                    matrix[i][j] = <span class="hljs-number">0</span>    <br>        <span class="hljs-keyword">return</span> matrix<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度$O(m*n)$，执行时间38ms，消耗内存17.1MB</p><h1 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289 生命游戏"></a>289 生命游戏</h1><p>根据 <a href="https://baike.baidu.com/item/%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/22668799?fromtitle=%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F&fromid=2926434">百度百科</a> ，<strong>生命游戏</strong> ，简称为 <strong>生命</strong> ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p><p>给定一个包含 <code>m × n </code>个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： <code>1</code> 即为 活细胞 （live），或 <code>0</code> 即为 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><p>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</p><p>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</p><p>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</p><p>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</p><p>下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 <code>m x n</code> 网格面板 <code>board</code> 的当前状态，返回下一个状态。</p><p>示例 1：</p><p><img src="/../img/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F_%E7%A4%BA%E4%BE%8B1.jpg" alt="示例 1"></p><p>输入：board &#x3D; [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]</p><p>输出：[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]</p><p>示例 2：</p><p><img src="/../img/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F_%E7%A4%BA%E4%BE%8B2.jpg" alt="示例 2"></p><p>输入：board &#x3D; [[1,1],[1,0]]</p><p>输出：[[1,1],[1,1]]</p><p>提示：</p><p><code>m == board.length</code></p><p><code>n == board[i].length</code></p><p><code>1 &lt;= m, n &lt;= 25</code></p><p><code>board[i][j]</code> 为 <code>0</code> 或 <code>1</code></p><h2 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gameOfLife</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board: <span class="hljs-keyword">return</span> <br>        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-built_in">dict</span> = [(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">for</span> dx, dy <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>:<br>                    x, y = i + dx, j + dy<br>                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= x &lt; m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= y &lt; n:<br>                        cnt += board[x][y] &amp; <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (cnt &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> cnt &gt; <span class="hljs-number">3</span>):<br>                    board[i][j] = <span class="hljs-number">3</span><br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> cnt == <span class="hljs-number">3</span>:<br>                    board[i][j] = <span class="hljs-number">2</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                board[i][j] &gt;&gt;= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这个版本的代码直接报错，而后根据相似的思路重新写了一个版本的代码，先讲一下思路。</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ol><li>设置好八个位置的坐标</li><li>设置一个函数用于对某个位置的细胞周围的活细胞进行标记</li><li>根据题目所给出的情况进行处理</li><li>最后对所有位置的细胞进行遍历</li><li>-1表示当前细胞是从活变死，2表示当前细胞是从死变活</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gameOfLife</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> board[<span class="hljs-number">0</span>]:<br>            <span class="hljs-keyword">return</span><br>    <br>        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>        directions = [(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">count_live_neighbors</span>(<span class="hljs-params">x, y</span>):<br>            count = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> dx, dy <span class="hljs-keyword">in</span> directions:<br>                nx, ny = x + dx, y + dy<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; n <span class="hljs-keyword">and</span> <span class="hljs-built_in">abs</span>(board[nx][ny]) == <span class="hljs-number">1</span>:<br>                    count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> count<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                live_neighbors = count_live_neighbors(i, j)<br>                <br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (live_neighbors &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> live_neighbors &gt; <span class="hljs-number">3</span>):<br>                    board[i][j] = -<span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> live_neighbors == <span class="hljs-number">3</span>:<br>                    board[i][j] = <span class="hljs-number">2</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> board[i][j] == -<span class="hljs-number">1</span>:<br>                    board[i][j] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">elif</span> board[i][j] == <span class="hljs-number">2</span>:<br>                    board[i][j] = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度$O(m * n)$，执行时间36ms，消耗内存16.5MB</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode刷题——滑动窗口</title>
    <link href="/2024/07/21/my-third-post/"/>
    <url>/2024/07/21/my-third-post/</url>
    
    <content type="html"><![CDATA[<p>这篇Blog将分享我自己在做Leetcode面试经典150题中滑动窗口部分几道题的思路，let’s go。</p><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> 。</p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的子数组 [$nums_l$, $nums_{l+1}$, …, $nums_{r - 1}$, $nums_r$] ，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p>示例 1：</p><pre><code class="hljs">输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 `[4,3]` 是该条件下的长度最小的子数组。</code></pre><p>示例 2：</p><pre><code class="hljs">输入：target = 4, nums = [1,4,4]输出：1</code></pre><p>示例 3：</p><pre><code class="hljs">输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0</code></pre><p>提示：</p><p><code>1 &lt;= target &lt;= 109</code></p><p><code>1 &lt;= nums.length &lt;= 105</code></p><p><code>1 &lt;= nums[i] &lt;= 105</code></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>第一个while循环中total不断累加end位置上的值</li><li>第二个循环判断total &gt;&#x3D; target，这时满足了条件中所说的大于等于</li><li>用ans来存储数组，并对其进行最小值比较</li><li>total和start都后移，窗口滑动一位</li></ol><p>提示：</p><p>这里的窗口并不是一成不变的，而是不断累加到满足条件，期间窗口可能包含一个两个三个数。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSubArrayLen</span>(<span class="hljs-params">self, target:<span class="hljs-built_in">int</span>, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        ans = n + <span class="hljs-number">1</span><br>        start, end = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        total = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> end &lt; n:<br>            total += nums[end]<br>            <span class="hljs-keyword">while</span> total &gt;= target:<br>                ans = <span class="hljs-built_in">min</span>(ans, end - start + <span class="hljs-number">1</span>)<br>                total -= nums[start]<br>                start += <span class="hljs-number">1</span><br>            end += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> ans == n + <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> ans<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度O(n)，执行用时60ms，消耗内存26.9MB</p><h2 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p><p>示例 1:</p><pre><code class="hljs">输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 `&quot;abc&quot;`，所以其长度为 3。</code></pre><p>示例 2:</p><pre><code class="hljs">输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 `&quot;b&quot;`，所以其长度为 1。</code></pre><p>示例 3:</p><pre><code class="hljs">输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 `&quot;wke&quot;`，所以其长度为 3。请注意，你的答案必须是**子串**的长度，`&quot;pwke&quot;` 是一个子序列，不是子串。</code></pre><p>提示：</p><p><code>0 &lt;= s.length &lt;= 5 * 104</code></p><p><code>s</code> 由英文字母、数字、符号和空格组成</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>首先确定需要使用滑动窗口和哈希表</li><li>哈希表用于存储字符和其对应的索引</li><li>当字符已经存在于哈希表中，对应的滑动窗口左边界移到该字符存储于哈希表中的索引位置</li><li>涉及到四个初始变量。<code>n</code>表示s的长度，<code>ans</code>用于存储结果，哈希表<code>mp</code>，指针<code>j</code>表示左边界</li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        ans = <span class="hljs-number">0</span><br>        mp = &#123;&#125;<br>        j = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">in</span> mp:<br>                j = <span class="hljs-built_in">max</span>(mp[s[i]], j)<br>            ans = <span class="hljs-built_in">max</span>(ans, i - j + <span class="hljs-number">1</span>)<br>            mp[s[i]] = i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度O(n)，执行用时52ms，消耗内存16.5MB</p><h2 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30.串联所有单词的子串"></a>30.串联所有单词的子串</h2><p>给定一个字符串 <code>s</code> 和一个字符串数组 <code>words</code>。 <code>words</code> 中所有字符串 <strong>长度相同</strong>。</p><p><code>s</code> 中的 <strong>串联子串</strong> 是指一个包含  <code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p><ul><li>例如，如果 <code>words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>， 那么 <code>&quot;abcdef&quot;</code>， <code>&quot;abefcd&quot;</code>，<code>&quot;cdabef&quot;</code>， <code>&quot;cdefab&quot;</code>，<code>&quot;efabcd&quot;</code>， 和 <code>&quot;efcdab&quot;</code> 都是串联子串。 <code>&quot;acdbef&quot;</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li></ul><p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p><p>示例1：</p><pre><code class="hljs">输入：s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]输出：`[0,9]`解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。子串 &quot;barfoo&quot; 开始位置是 0。它是 words 中以 [&quot;bar&quot;,&quot;foo&quot;] 顺序排列的连接。子串 &quot;foobar&quot; 开始位置是 9。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。输出顺序无关紧要。返回 [9,0] 也是可以的。</code></pre><p>示例2：</p><pre><code class="hljs">输入：s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]输出：`[]`解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。所以我们返回一个空数组。</code></pre><p>示例 3：</p><pre><code class="hljs">输入：s = &quot;barfoofoobarthefoobarman&quot;, words = [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]输出：`[6,9,12]`解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。子串 &quot;foobarthe&quot; 开始位置是 6。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;] 顺序排列的连接。子串 &quot;barthefoo&quot; 开始位置是 9。它是 words 中以 [&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;] 顺序排列的连接。子串 &quot;thefoobar&quot; 开始位置是 12。它是 words 中以 [&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。</code></pre><p>提示：</p><p><code>1 &lt;= s.length &lt;= 104</code></p><p><code>1 &lt;= words.length &lt;= 5000</code></p><p><code>1 &lt;= words[i].length &lt;= 30</code></p><p><code>words[i]</code> 和 <code>s</code> 由小写英文字母组成</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>最开始初始化五个变量，<code>word_len</code>单词长度，<code>total_len</code>单词长度之和，<code>word_map</code>用Counter记录每个单词出现的次数，<code>ans</code>用于存储结果</li><li>滑动窗口每次滑动一个单词长度，当我们窗口内的单词出现次数和原本的不匹配就移动右边界，直到窗口内单词计数不超过原始计数</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> words:<br>            <span class="hljs-keyword">return</span> []<br><br>        word_len = <span class="hljs-built_in">len</span>(words[<span class="hljs-number">0</span>])<br>        word_count = <span class="hljs-built_in">len</span>(words)<br>        total_len = word_len * word_count<br>        word_map = Counter(words)<br>        ans = []<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(word_len):<br>            left = i<br>            right = i<br>            cur_map = Counter()<br>            <span class="hljs-keyword">while</span> right + word_len &lt;= <span class="hljs-built_in">len</span>(s):<br>                word = s[right:right + word_len]<br>                right += word_len<br>                <span class="hljs-keyword">if</span> word <span class="hljs-keyword">in</span> word_map:<br>                    cur_map[word] += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> cur_map[word] &gt; word_map[word]:<br>                        cur_map[s[left:left + word_len]] -= <span class="hljs-number">1</span><br>                        left += word_len<br>                    <span class="hljs-keyword">if</span> right - left == total_len:<br>                        ans.append(left)<br>                <span class="hljs-keyword">else</span>:<br>                    cur_map.clear()<br>                    left = right<br><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度O(n * m)，执行时间72ms，消耗内存17.1MB</p><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76 最小覆盖子串"></a>76 最小覆盖子串</h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p>注意：</p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p>示例1：</p><pre><code class="hljs">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;输出：&quot;BANC&quot;解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#39;A&#39;、&#39;B&#39; 和 &#39;C&#39;。</code></pre><p>示例 2：</p><pre><code class="hljs">输入：s = &quot;a&quot;, t = &quot;a&quot;输出：&quot;a&quot;解释：整个字符串 s 是最小覆盖子串。</code></pre><p>示例 3:</p><pre><code class="hljs">输入: s = &quot;a&quot;, t = &quot;aa&quot;输出: &quot;&quot;解释: t 中两个字符 &#39;a&#39; 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</code></pre><p>提示：</p><p><code>m == s.length</code><br><code>n == t.length</code><br><code>1 &lt;= m, n &lt;= 105</code><br><code>s</code> 和 <code>t</code> 由英文字母组成</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>初始化五个变量，<code>need</code>用于记录<code>t</code>每个字符的需求数量，<code>missing</code>用于记录还需要匹配的字符数量，<code>left</code>左边界，<code>start</code>起始位置，<code>min_len</code>长度，<code>ans</code>存储结果</li><li>滑动窗口使用right指针遍历字符串<code>s</code>，如果当前字符在<code>need</code>中数量大于0则减少<code>missing</code>表示需求字符少一个</li><li>当<code>missing</code>为0即窗口内包含所有所需字符，移动left继续遍历直到 <code>need[s[left]]</code> 不再小于 0。</li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minWindow</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> t: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>        need = Counter(t)<br>        missing = <span class="hljs-built_in">len</span>(t)<br>        left = start = <span class="hljs-number">0</span><br>        min_len = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        ans = <span class="hljs-string">&quot;&quot;</span><br>        <br>        <span class="hljs-keyword">for</span> right, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s, <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> need[char] &gt; <span class="hljs-number">0</span>:<br>                missing -= <span class="hljs-number">1</span><br>            need[char] -= <span class="hljs-number">1</span><br>            <br>            <span class="hljs-keyword">if</span> missing == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> need[s[left]] &lt; <span class="hljs-number">0</span>:<br>                    need[s[left]] += <span class="hljs-number">1</span><br>                    left += <span class="hljs-number">1</span><br>                    <br>                <span class="hljs-keyword">if</span> right - left &lt; min_len:<br>                    min_len = right - left<br>                    ans = s[left:right]<br>                    <br>                need[s[left]] += <span class="hljs-number">1</span><br>                left += <span class="hljs-number">1</span><br>                missing += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度O(n)，执行用时108ms，消耗内存16.8MB</p><p>好的，滑动窗口部分的题目就四个，到这里就结束了。滑动窗口的核心思路就在于不断移动窗口去匹配题设所给出的条件，之前刷2024春招100题那会还没特别明白这部分，现在也是彻底会了🤣不过还是不想笔试或面试遇到，这个真的好烦。</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卧推训练过程中发现的一个小问题</title>
    <link href="/2024/07/20/My-Second-Blog/"/>
    <url>/2024/07/20/My-Second-Blog/</url>
    
    <content type="html"><![CDATA[<p>满打满算健身也快一年了，身材也有了极其明显的变化。虽然因为长时间坐着不动外加kuku吃碳水导致腰上肉长得飞快，也正因此上半身感觉上下没啥分别。说回正题，这篇Blog主要是想聊一下我自己最近遇到的也是我这么长时间以来完全忽略的一点，还是两个健身房里的大佬一块换着练的时候被指出来的。</p><h1 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h1><p>这个问题说起来也不是很大，实际上就是很多健身博主都在说的卧推的时候手腕的位置。我自己刚开始是听了那些博主的话，乖乖的每次都强行让手腕保持中立位，但每次都感觉非常的别扭。由于是自己练再加上原本就很瘦，我的卧推重量现在也只是60KG做组，之前30、40KG时每次练完胸回来手腕倒是没有不舒服，到45+就开始不对劲了。每次练完胸回来都感觉手腕非常难受，有的时候还需要用云南白药喷雾。自打我开始健身就听说过TFCC，我自己当时也有点担心会不会是，也做了下自测什么的，但最后的结果都是没问题。到这里我已经产生奇怪的念头了，为什么我每次明明戴了护腕还是会不舒服呢？</p><h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><p>直到那天和两个大佬一起练，我才知道我自己的手腕是非常塌的，基本上可以说完美符合网上所说的全靠手腕支撑杠铃。在这里我画了个简图。<br><img src="/../img/second%20blog%20pic.jpg" alt="alt text"><br>可以看到左侧是正常的手腕处于中立位，如果用正常视角来看杠铃杆就是靠我们虎口下面的部分来支持，说到这里还需要提到掰杠，不过这个问题我们后面再说。而右边就是我之前的卧推姿势，手腕非常塌，通过受力分析可以得到一个结论。除了杠铃在手上的重力、我们给杠铃的推力，还有一个向斜下方的力。由于我们以这种姿势卧推是靠手掌托住杠铃，手腕收到的力等于我们的重力。而斜向下的力属于对抗我们重力过程中的副产物，同样作用于手腕。故而我们可以得出结论，斜向下的力和重力双重叠加导致我们的手腕受到了大于杠铃本身的重力。</p><p>那么为什么说当保持中立位的时候我们的手腕不会受到那么大的力呢？这里我们需要了解到一个事情。当我们的手腕在中立位时，我们的手腕、手肘、小臂处于同一条线，力线垂直向下，重力垂直作用于前臂，相当于我们整个前臂来对抗重力。反观塌腕时我们单纯用手腕来对抗，很明显保持中立位是对我们的手腕很友好的。</p><h1 id="掰杠"><a href="#掰杠" class="headerlink" title="掰杠"></a>掰杠</h1><p>再说会掰杠，为什么很多博主会刻意提到掰杠中整个操作。这里我们来观察下，当我们不使用掰杠，单纯用正常的卧推姿势去卧推，我们杠铃位于我们的大鱼际上，这时我们可以发现，杠铃的重心是略微偏离我们的小臂垂直线的，这样可能会造成手腕略微压力增大。而我们手腕微微外旋我们就能发现，大鱼际和小鱼际近似处于一个平面，而平面和我们的小臂垂直线属于垂直。这时我们就可以达到我们前面所说的手腕中立位的“完美”卧推上臂姿势。</p><p>当然并不是说不掰杠就不好，掰杠的作用并不是单纯的为了减弱那么一丢丢力，而是我们的手腕本身就非常脆弱，软组织一旦损伤可以说这辈子都可能健身和say goodbye，毕竟这个软组织恢复慢、影响大，为了我们的日常生活和训练生活，我们一定要在动作标准的情况下尽最大可能避免受伤。</p><p>接下来就要说到掰杠最大的作用了——增加稳定性。健身的人通常都会熟悉一个名词叫做肩胛骨，可以说得肩胛骨者得天下（这话怎么和高中那会的得语文者得天下一模一样，不会提出这句话的人是语文老师吧）。肩胛骨负责了我们上半身非常多的作用，而卧推的准备过程中我们需要沉肩、稳定肩胛骨、稳定下半身、背部肌肉绷紧。这些无一例外都是为了稳定二字。而我们的掰杠，很大程度上是为了辅助我们去稳定肩胛骨，根据我微不足道的观察发现，现代人因为长时间伏案工作、滑手机已经导致我们的肩胛骨很容易形成翼状肩胛。翼状肩胛不仅难看而且非常影响我们的卧推稳定性（本次不讨论翼状肩胛对背部的影响，这个后续会写我自己背部训练还是有一定心得的）。也正因此掰杠提供的额外增加就很好的进行了补充。可以试一试先沉肩然后空手外旋，这时会发现我们的肩胛骨位置有明显的感觉。也正因此换到卧推当中，掰杠可以提供给我们额外的稳定性，让我们不至于把卧推做成诺克萨斯断头台🤣</p><h1 id="结束咯😝"><a href="#结束咯😝" class="headerlink" title="结束咯😝"></a>结束咯😝</h1><p>好的，相信看到这里的朋友已经明白为什么我会写这篇Blog了。从我自身角度来说，被指出问题后我对手腕姿势进行了修改，后续我卧推后也没有再出现特别难受的情况。同时我也去学习了掰杠技巧，进一步增强了卧推（虽然重量依旧没变化，大夏天真的吃啥都掉体重）。所以，我这一年中不断的磨合我的动作，不断上重量，不断学习。之前看到有人说过一句话“健身就是一年增重一年减重改动作的不断循环”，从我个人角度而言，我并不反对这句话，因为我自己这一年也是这么走过来的，从哑铃卧推6KG到现在的杠铃卧推60KG，从辅助引体需要50KG（那会我体重不到60）到现在轻松自重引体。但在这过程中我自己也在不断的反思学习，任何事情都是需要不断学习打磨，不断完善，世间并无一蹴而就的事情。</p><p>好咯，这次的Blog就到这里结束啦，有兴趣的朋友可以去我的IG看我拍的健身照片，不过应该看不出来啥区别，毕竟我发的时候已经有了一些变化了，最早很瘦的应该是没有的。</p>]]></content>
    
    
    <categories>
      
      <category>健身记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>健身</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>360技术综合H卷笔试——编程题记录</title>
    <link href="/2024/07/20/My-First-Blog/"/>
    <url>/2024/07/20/My-First-Blog/</url>
    
    <content type="html"><![CDATA[<p>360是我七月初就已经投的公司，同时也是我今年秋招第一个拿到笔试的公司。在考前按照往年的试卷估计题目应该是40道客观题2道编程题。实际结果也如预期一般，30多道的单选题，为数不多的多选题（每个卷子的题型不一样，maybe我这个卷子的少）以及2个编程题。接下来我将尽可能完整的复刻题目并阐述我自己的做法，同时也会附加我自己的代码，望各位看官满意。</p><h2 id="第一题-加密算法"><a href="#第一题-加密算法" class="headerlink" title="第一题 加密算法"></a><strong>第一题 加密算法</strong></h2><p>有两个人在研究加密算法，一个人提出对只包含小写英文字母的字符串，将 ’a’替换成 ’1’，将 ’b’;替换成 ’2’……，将 ’z’替换成 ’26’。比如一个字符串 ’aabac’（想不起来了，我编的），加密后变成了 ’11213’，但另外一个人提出困难会造成多个结果，就比如 ’11213’也可能是 ’kbm’，会产生多个结果。所以我们要做的就是计算某个加密后的字符串可能对应的原字符串个数，要求取模10^9+7。</p><p>输入：</p><p>第一行n是加密后的字符串长度</p><p>第二行是加密后的字符串</p><p>输出：</p><p>一个正整数表示原字符串个数</p><p>样例输入：</p><p>5</p><p>11213</p><p>样例输出：</p><p>8</p><p>在做题的时候我就感觉这题怎么这么熟悉，考完一看才发现这不就是leetcode 91 解码方法。</p><p>既然提到了那就顺便说一下这道题的思路吧，如果实在需要代码可以直接用笔试题的代码稍微改改应该maybe也能行？</p><p>首先这道题需要对一个问题进行多次匹配求解出多个情况。也就是说字符串’11213’可能被分为’1’和’1213’也可能被分为’11’和’213’类似于这样的不断进行。故而就想到了动态规划来解决。<br>接下来就需要具体构建：</p><ol><li>定义一个数组dp，其中dp[i]表示长度为i的加密字符串可能解码出的原字符串个数。</li><li>设置初始条件dp[0] &#x3D; 1，即空字符串有一种解码方式。</li><li>状态转移：<ul><li>如果当前字符可以作为有效的单字符解码(1 &lt;&#x3D; s[i - 1] &lt;&#x3D; 9)，则dp[i] +&#x3D; dp[i - 1]</li><li>如果当前字符和前一个字符可以作为一个有效的双字符解码(10 &lt;&#x3D; s[i - 2:i] &lt;&#x3D; 26)，则dp[i] +&#x3D; dp[i - 2]</li></ul></li><li>最终结果为dp[n]</li></ol><p>好的，接下来回到笔试的考题加密算法本身。</p><p>首先分析问题，我们需要给每个字母进行一一对应；加密后的字符串可能对应多个原字符串；我们需要对结果进行取模。<br>接下来来说说具体的思路：</p><ol><li>使用动态规划来解决</li><li>创建一个数组dp，其中dp[i]表示前i个数字可能对应的原字符串</li><li>对每个位置i，我们需要考虑单独解码和组合解码</li></ol><p>借助这个大致思路得到了下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_possible_string</span>(<span class="hljs-params">encoded</span>):<br>    MOD = <span class="hljs-number">1000000007</span><br>    n = <span class="hljs-built_in">len</span>(encoded)<br>    dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> encoded[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 单独解码</span><br>        <span class="hljs-keyword">if</span> encoded[i - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;0&#x27;</span>:<br>            dp[i] = dp[i - <span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 组合解码</span><br>        two_digit = <span class="hljs-built_in">int</span>(encoded[i - <span class="hljs-number">2</span>:i])<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">10</span> &lt;= two_digit &lt;= <span class="hljs-number">26</span>:<br>            dp[i] = (dp[i] + dp[i - <span class="hljs-number">2</span>]) % MOD<br><br>    <span class="hljs-keyword">return</span> dp[n]<br><br><span class="hljs-comment"># 输入</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>encoded = <span class="hljs-built_in">input</span>()<br><br><span class="hljs-comment"># 输出</span><br>result = count_possible_string(encoded)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>到这里第一题就结束了，不过我需要说明一点的是，我的代码并不是最优代码，只是能AC这道题，这里也只是提供一种代码和一种思路。</p><h2 id="第二题-传染病防控"><a href="#第二题-传染病防控" class="headerlink" title="第二题 传染病防控"></a>第二题 传染病防控</h2><p>某市正在进行传染病防控，某市有n个人，每个人有一个位置$(x_{i},y_{i})$。现在已知有一个是高风险人员，但不知道是谁。同时我们定义一个安全距离k，如果某个人和这个高风险人员的距离不超过k，那么这个人也将被列为高风险人员。所以我们现在需要帮工作人员得到最多的高风险人员数量。两个人$(x_1,y_1),(x_2,y_2)$的距离公式为$|x_1-x_2| + |y_1 - y_2|$。</p><p>输入描述：</p><p>一行两个整数n，k</p><p>接下来一行n个整数分别表示$x_1$到$x_n$</p><p>接下来一行n个整数分别表示$y_1$到$y_n$</p><p>输出描述：</p><p>输出一个整数表示最多的高风险人员数量</p><p>样例输入：（这里因为debug了好几遍输了好几遍所以还有记录，可以用原本的数）</p><p>5 2</p><p>8 6 1 5 1</p><p>4 4 3 4 6</p><p>样例输出：</p><p>3</p><p>首先明确一点，这个距离公式就是常用的曼哈顿距离，所以在正式写算法前需要先把这个距离公式给写了。</p><p>接下来说一下我的大致思路：</p><ol><li>首先构建图，根据输入的坐标和距离构建邻接矩阵<code>ajd</code></li><li>图的遍历：这里根据惯例选择DFS或BFS来遍历图，我选的是BFS，以此计算出某一点出发的最大连通节点数。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">max_high_risk</span>(<span class="hljs-params">n, k, x, y</span>):<br>    <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br>    <span class="hljs-comment"># 曼哈顿距离公式</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">manhatten_distance</span>(<span class="hljs-params">x1, y1, x2, y2</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(x1 - x2) + <span class="hljs-built_in">abs</span>(y1 - y2)<br><br>    <span class="hljs-comment"># 构建邻接表，adj[i]表示与第i个人相邻的所有人</span><br>    adj = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">if</span> manhatten_distance(x[i], y[i], x[j], y[j]) &lt;= k:<br>                adj[i].append(j)<br>                adj[j].append(i)<br><br>    <span class="hljs-comment"># 构建BFS            </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">start</span>):<br>        queue = deque([start])<br>        visited = <span class="hljs-built_in">set</span>([start])<br>        count = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> queue:<br>            current = queue.popleft()<br>            <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> adj[current]:<br>                <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>                    queue.append(neighbor)<br>                    visited.add(neighbor)<br>                    count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> count<br><br>    max_count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        max_count = <span class="hljs-built_in">max</span>(max_count, bfs(i))<br>    <span class="hljs-keyword">return</span> max_count<br><br><span class="hljs-comment"># 输入</span><br>n, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>x = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>y = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br><span class="hljs-comment"># 输出</span><br><span class="hljs-built_in">print</span>(max_high_risk(n, k, x, y))<br></code></pre></td></tr></table></figure><p>到这里第二题也就结束了，我当时这道题debug了好几遍，第一次是输入不对，第二次是邻接矩阵出问题，到第三次才成功AC。再次说明我的代码仅仅只能通过所有样例完成这道题，并不是最优解。</p><p>最后附上一张在食堂吃饭的时候拍到的学长，超乖的一只猫咪，就是动作有那么一丝丝不文雅。</p><p><img src="/../img/first%20blog%20cover.jpg" alt="alt text"></p>]]></content>
    
    
    <categories>
      
      <category>笔试记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔试</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
