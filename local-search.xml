<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PostgreSQL学习记录——第一天</title>
    <link href="/2024/08/02/postgresql-study-first-day/"/>
    <url>/2024/08/02/postgresql-study-first-day/</url>
    
    <content type="html"><![CDATA[<p>昨天已经完成了PostgreSQL（后续和其他平台一样把这个简称为PG）的安装，今天就来逐步学吧。至于为什么从MySQL转移到PG，主要是因为以下几点：</p><ol><li>PG支持更多的数据类型</li><li>PG在所有配置上均支持ACID，而MySQL只能在部分情况下支持</li><li>PostgreSQL使用了多版本并发控制（MVCC）减少了出现死锁的概率</li><li>PostgreSQL支持更多的索引类型</li></ol><p>说完上面的就不得不提到简历上写了会MySQL然后被面试官无数次拷打的经历了（MongoDB我也写了，没人问，我还准备了蛮多的嘞）。</p><p>首先就是ACID是哪四个，莫名感觉是所有面试官都会想问。</p><p>其次是锁相关，S锁、X锁、IS锁、IX锁、未提交读、提交读、可重复读、串行化，呕。</p><p>然后就说索引B树B+树，前段时间面试才被问到过这个。</p><p>然后正式进入学习记录。</p><figure>  <img src="/2024/08/02/postgresql-study-first-day/start%20psql.png" class="" title="start PG">  <figcaption>start PG</figcaption></figure><p>在开启SQL Shell（psql）之前记得在cmd里打开PG服务。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>这部分内容太多太杂，就把比MySQL支持的更多的数据类型大概记一下吧（我自己按照资料写的，如果有缺少或者多了麻烦各位补充啊）</p><table><thead><tr><th>PostgreSQL数据类型</th><th>描述</th></tr></thead><tbody><tr><td>SERIAL</td><td>自增整数</td></tr><tr><td>BIGSERIAL</td><td>大范围自增整数</td></tr><tr><td>MONEY</td><td>货币金额</td></tr><tr><td>UUID</td><td>通用唯一标识符</td></tr><tr><td>CIDR</td><td>IPv4或IPv6网络地址</td></tr><tr><td>INET</td><td>IPv4或IPv6主机地址</td></tr><tr><td>MACADDR</td><td>MAC地址</td></tr><tr><td>BIT</td><td>定长位串</td></tr><tr><td>BIT VARYING</td><td>变长位串</td></tr><tr><td>BOX</td><td>平面中的矩形框</td></tr><tr><td>LINE</td><td>无限长的线</td></tr><tr><td>LSEG</td><td>线段</td></tr><tr><td>PATH</td><td>闭合路径</td></tr><tr><td>POINT</td><td>平面中的点</td></tr><tr><td>POLYGON</td><td>闭合的平面多边形</td></tr><tr><td>CIRCLE</td><td>平面中的圆</td></tr><tr><td>INTERVAL</td><td>时间间隔</td></tr><tr><td>TSVECTOR</td><td>文本搜索文档</td></tr><tr><td>TSQUERY</td><td>文本搜索查询</td></tr><tr><td>XML</td><td>XML数据</td></tr><tr><td>JSON</td><td>JSON数据</td></tr><tr><td>JSONB</td><td>二进制JSON数据，可索引</td></tr><tr><td>HSTORE</td><td>键值对存储</td></tr></tbody></table><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p><code>CREATE DATABASE dbname;</code></p><h2 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h2><p><code>\l</code> 查看数据库（莫名想到了Linux的ls -l）</p><p><code>\c</code> + <code>dbname</code> 进入数据库</p><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p><code>DROP DATABASE [IF EXISTS] name;</code></p><p>删除需要root权限，普通用户无法删除</p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h2 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name(<br>   column1 datatype,<br>   column2 datatype,<br>   column3 datatype,<br>   .....<br>   columnN datatype,<br>   <span class="hljs-keyword">PRIMARY</span> KEY( 一个或多个列 )<br>);<br></code></pre></td></tr></table></figure><p>例子</p><figure>  <img src="/2024/08/02/postgresql-study-first-day/table%20EX.png" class="" title="table EX">  <figcaption>table EX</figcaption></figure><p><code>\d</code>是查看当前已经存在的表格</p><p><code>\d tablename</code>是查看表格详情</p><figure>  <img src="/2024/08/02/postgresql-study-first-day/%E6%9F%A5%E7%9C%8B%E8%AF%A6%E6%83%85.png" class="" title="查看详情">  <figcaption>查看详情</figcaption></figure><h2 id="删除表格"><a href="#删除表格" class="headerlink" title="删除表格"></a>删除表格</h2><p><code>DROP TABLE table_name;</code></p><h1 id="PG模式（SCHEMA）"><a href="#PG模式（SCHEMA）" class="headerlink" title="PG模式（SCHEMA）"></a>PG模式（SCHEMA）</h1><p>第一眼看感觉有点像事务，但是事务是遵循ACID原则的并且通过MVCC来建立隔离，两者的逻辑不一样。</p><p>模式中可以包括视图、索引、数据类型、函数和操作等。</p><p>相同的名称可以运用于不同的模式而不报错，for example schema1和myschema都包含mytable的表。</p><p>模式的优势：</p><ul><li>允许多个用户操作数据库而不相互干扰</li><li>将数据库对象组织成逻辑便于管理（我的理解是我在做某个东西的时候我将一张表三个视图组织在一起，这个组织就可以一起被操作同时还可以单独操作，然后也可以对整个模式里的对象进行批量操作）</li><li>第三方应用的对象可以放在独立的模式中，这样它们就不会与其他对象的名称发生冲突。</li></ul><h2 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h2><p>语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SCHEMA myschema (<br>...<br>);<br></code></pre></td></tr></table></figure><p>创建表的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> myschema.mytable (<br>    column1 datatype1,<br>    column2 datatype2,<br>    ...<br>);<br></code></pre></td></tr></table></figure><p>上述语法是在一个叫myschema的模式下创建了一个叫mytable的表</p><p>例子</p><figure>  <img src="/2024/08/02/postgresql-study-first-day/create%20schema.png" class="" title="create schema">  <figcaption>create schema</figcaption></figure><p>这里我们建立了一个模式和一个表，中间由于手误少了一个’,’。</p><h2 id="删除模式"><a href="#删除模式" class="headerlink" title="删除模式"></a>删除模式</h2><p>删除一个空的模式（里面的对象已经全部被删除了）</p><p><code>DROP SCHEMA myschema;</code></p><p>删除一个模式及其下面的对象</p><p><code>DROP SCHEMA myschema CASSADE;</code></p><h1 id="INSERT-INTO-语句"><a href="#INSERT-INTO-语句" class="headerlink" title="INSERT INTO 语句"></a>INSERT INTO 语句</h1><p>语法如下</p><p><code>INSERT INTO TABLE_NAME (column1, column2, column3,...columnN) VALUES (value1, value2, value3,...valueN);</code></p><p>需要注意的是column和value需要数量一样，一一对应</p><p>对所有字段均添加值的语法如下</p><p><code>INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);</code></p><table><thead><tr><th>序号</th><th>输出信息&amp;描述</th></tr></thead><tbody><tr><td>1</td><td>INSERT oid 1 直插入一行且表中具备OID的返回信息，那么oid就分配给被插入行</td></tr><tr><td>2</td><td>INSERT 0 # 插入多行，#为插入行数</td></tr></tbody></table><p>例子</p><p>这里先创建一个表</p><figure>  <img src="/2024/08/02/postgresql-study-first-day/create%20company.png" class="" title="create table">  <figcaption>create table</figcaption></figure><figure>  <img src="/2024/08/02/postgresql-study-first-day/insert%20into.png" class="" title="insert into">  <figcaption>insert into</figcaption></figure><p>这里我们从上到下分别来看</p><ul><li>给表里插入数据</li><li>给表里插入忽略SALARY的数据</li><li>插入语句 JOIN_DATE 字段使用 DEFAULT 子句来设置默认值，而不是指定值</li><li>插入多行</li><li>查询数据</li></ul><h1 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h1><p>这里就不多说了，不会的拖出去乱棍打死。和MySQL之类的一摸一样。</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>PG的运算符一般用在<code>WHERE</code>中<br>有四个</p><ul><li>算术运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>按位运算符</li></ul><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><figure>  <img src="/2024/08/02/postgresql-study-first-day/%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6.png" class="" title="算术运算符">  <figcaption>算术运算符</figcaption></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td><td>(a &#x3D; b) 为 false。</td></tr><tr><td>!&#x3D;</td><td>不等于</td><td>(a !&#x3D; b) 为 true。</td></tr><tr><td>&lt;&gt;</td><td>不等于</td><td>(a &lt;&gt; b) 为 true。</td></tr><tr><td>&gt;</td><td>大于</td><td>(a &gt; b) 为 false。</td></tr><tr><td>&lt;</td><td>小于</td><td>(a &lt; b) 为 true。</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td><td>(a &gt;&#x3D; b) 为 false。</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td><td>(a &lt;&#x3D; b) 为 true。</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th>序号</th><th>运算符 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>AND</strong></td></tr><tr><td></td><td>逻辑与运算符。如果两个操作数都非零，则条件为真。</td></tr><tr><td></td><td>PostgresSQL 中的 WHERE 语句可以用 AND 包含多个过滤条件。</td></tr><tr><td>2</td><td><strong>NOT</strong></td></tr><tr><td></td><td>逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td></tr><tr><td></td><td>PostgresSQL 有 NOT EXISTS, NOT BETWEEN, NOT IN 等运算符。</td></tr><tr><td>3</td><td><strong>OR</strong></td></tr><tr><td></td><td>逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td></tr><tr><td></td><td>PostgresSQL 中的 WHERE 语句可以用 OR 包含多个过滤条件。</td></tr></tbody></table><h3 id="三值逻辑系统"><a href="#三值逻辑系统" class="headerlink" title="三值逻辑系统"></a>三值逻辑系统</h3><table><thead><tr><th>a</th><th>b</th><th>a AND b</th><th>a OR b</th></tr></thead><tbody><tr><td>TRUE</td><td>TRUE</td><td>TRUE</td><td>TRUE</td></tr><tr><td>TRUE</td><td>FALSE</td><td>FALSE</td><td>TRUE</td></tr><tr><td>TRUE</td><td>NULL</td><td>NULL</td><td>TRUE</td></tr><tr><td>FALSE</td><td>FALSE</td><td>FALSE</td><td>FALSE</td></tr><tr><td>FALSE</td><td>NULL</td><td>FALSE</td><td>NULL</td></tr><tr><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr></tbody></table><table><thead><tr><th>a</th><th>NOT a</th></tr></thead><tbody><tr><td>TRUE</td><td>FALSE</td></tr><tr><td>FALSE</td><td>TRUE</td></tr><tr><td>NULL</td><td>NULL</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><figure>  <img src="/2024/08/02/postgresql-study-first-day/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.png" class="" title="位运算符">  <figcaption>位运算符</figcaption></figure><h3 id="按位运算符"><a href="#按位运算符" class="headerlink" title="按位运算符"></a>按位运算符</h3><figure>  <img src="/2024/08/02/postgresql-study-first-day/%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.png" class="" title="按位运算符">  <figcaption>按位运算符</figcaption></figure><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, columnN<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">CONDITION</span> <span class="hljs-operator">|</span> EXPRESSION];<br></code></pre></td></tr></table></figure><h2 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h2><p>根据一个指定条件来读取数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, columnN<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> SINGLE <span class="hljs-keyword">VALUE</span> MATCHTING EXPRESSION;<br></code></pre></td></tr></table></figure><h2 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> numerical_expression <span class="hljs-keyword">as</span>  OPERATION_NAME<br>[<span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">CONDITION</span>] ;<br></code></pre></td></tr></table></figure><p>PG还有内置计算函数（这个好像都有吧sum、avg这些）</p><h2 id="日期表达式"><a href="#日期表达式" class="headerlink" title="日期表达式"></a>日期表达式</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>;<br></code></pre></td></tr></table></figure><p>返回当前日期</p><h1 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h1><p>这部分内容和MySQL差不多<br>WHERE的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, columnN<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> [condition1]<br></code></pre></td></tr></table></figure><p>还可以使用比较运算符或逻辑运算符<br>AND, OR, NOT NULL, LIKE, NOT IN, BETWEEN, 子查询</p><h1 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h1><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> table_name<br><span class="hljs-keyword">SET</span> column1 <span class="hljs-operator">=</span> value1, column2 <span class="hljs-operator">=</span> value2...., columnN <span class="hljs-operator">=</span> valueN<br><span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">condition</span>];<br></code></pre></td></tr></table></figure><h1 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h1><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">condition</span>];<br></code></pre></td></tr></table></figure><h1 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h1><p>和MySQL一样，都是进行匹配<br>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;XXXX%&#x27;</span>;<br>或者<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%XXXX%&#x27;</span>;<br>或者<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;XXXX_&#x27;</span>;<br>或者<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_XXXX&#x27;</span>;<br>或者<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_XXXX_&#x27;</span>;<br></code></pre></td></tr></table></figure><h1 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h1><p>作用就是限制查询条数</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, columnN<br><span class="hljs-keyword">FROM</span> table_name<br>LIMIT [<span class="hljs-keyword">no</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">rows</span>]<br></code></pre></td></tr></table></figure><p>和OFFSET一起用的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, columnN <br><span class="hljs-keyword">FROM</span> table_name<br>LIMIT [<span class="hljs-keyword">no</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">rows</span>] <span class="hljs-keyword">OFFSET</span> [<span class="hljs-type">row</span> num]<br></code></pre></td></tr></table></figure><h1 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h1><p><code>ORDER BY</code>是用来对一列或多列进行排序的（升序或降序）</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span><span class="hljs-operator">-</span>list<br><span class="hljs-keyword">FROM</span> table_name<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>]<br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column1, column2, .. columnN] [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>];<br></code></pre></td></tr></table></figure><p>ASC 表示升序，DESC 表示降序。</p><h1 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h1><p><code>GROUP BY</code>用来和<code>SELECT</code>语句一起使用，对数据进行分组。</p><p><code>GROUP BY</code> 在一个 <code>SELECT</code> 语句中，放在 <code>WHERE</code> 子句的后面，<code>ORDER BY</code> 子句的前面。</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span><span class="hljs-operator">-</span>list<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> [ conditions ]<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> column1, column2....columnN<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column1, column2....columnN<br></code></pre></td></tr></table></figure><h1 id="WITH"><a href="#WITH" class="headerlink" title="WITH"></a>WITH</h1><p>WITH主要用来辅助将复杂的查询拆分成简单的表单，便于阅读，也可以当作为查询存在的临时表。</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span><br>   name_for_summary_data <span class="hljs-keyword">AS</span> (<br>      <span class="hljs-keyword">SELECT</span> Statement)<br>   <span class="hljs-keyword">SELECT</span> columns<br>   <span class="hljs-keyword">FROM</span> name_for_summary_data<br>   <span class="hljs-keyword">WHERE</span> conditions <span class="hljs-operator">&lt;=&gt;</span> (<br>      <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span><br>      <span class="hljs-keyword">FROM</span> name_for_summary_data)<br>   [<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> columns]<br></code></pre></td></tr></table></figure><p><code>name_for_summary_data</code> 是 WITH 子句的名称，<code>name_for_summary_data</code> 可以与现有的表名相同，并且具有优先级。</p><p>可以在 WITH 中使用数据 INSERT, UPDATE 或 DELETE 语句，允许您在同一个查询中执行多个不同的操作。</p><h2 id="WITH-递归"><a href="#WITH-递归" class="headerlink" title="WITH 递归"></a>WITH 递归</h2><p>在 WITH 子句中可以使用自身输出的数据。</p><p>公用表表达式 (CTE) 具有一个重要的优点，那就是能够引用其自身，从而创建递归 CTE。递归 CTE 是一个重复执行初始 CTE 以返回数据子集直到获取完整结果集的公用表表达式。</p><h1 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h1><p>HAVING子句用来筛选分组后的各组数据。</p><p>WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。</p><p>HAVING在SELECT语句中的位置</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">FROM</span><br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br><span class="hljs-keyword">HAVING</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br></code></pre></td></tr></table></figure><p>基础语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2<br><span class="hljs-keyword">FROM</span> table1, table2<br><span class="hljs-keyword">WHERE</span> [ conditions ]<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> column1, column2<br><span class="hljs-keyword">HAVING</span> [ conditions ]<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column1, column2<br></code></pre></td></tr></table></figure><h1 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h1><p>和<code>SELECT</code>一起用，用于去重</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> column1, column2,.....columnN<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">condition</span>]<br></code></pre></td></tr></table></figure><p>好了，基本的操作到这里也就结束了，完结撒花~</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL安装记录及集群初始化失败问题解决</title>
    <link href="/2024/08/01/install-postgreSQL/"/>
    <url>/2024/08/01/install-postgreSQL/</url>
    
    <content type="html"><![CDATA[<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>Windows 11</p><p>PostgreSQL 16.3</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>下载PostgreSQL可以直接通过官网<a href="https://www.postgresql.org/">https://www.postgresql.org/</a></p><p>进入官网后点击图片中的Download，也可以通过Navbar中的Download直接进入对应页面。由于网络不稳定图片中的链接可能会不稳定，所以可以通过第二种方法进入对应页面，两种方法所到达的是同一页面。</p><p>![Download Page](&#x2F;img&#x2F;Download Page.png)</p><p>选择对应的系统进行下载，我这边选择的是Windows，所以直接进入Windows的页面。</p><p>进入后直接点击Download the Installer，进去后再次选择对应的系统和你想要的版本。</p><p><img src="/../img/System%20choice.png" alt="Choice your System"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>这里必须要注意一个事情，如果说遇到了在快要完成的时候出现<br>Problem running post-install step. Installation may not complete correctly. The database cluster initialisation failed.<br>这时切记去看后面的说明，我会把我这么解决的说清楚。</p><p>打开下载好的exe文件后就是这个页面</p><p><img src="/../img/postSQL%20first%20setup.png" alt="First Pic"><br>在这一步记得改一下安装地址，最好别放在C盘（当然只有C盘的话当我没说）</p><p><img src="/../img/PostSQL%20second%20page.png" alt="Second Pic"></p><p><img src="/../img/Select%20Components.png" alt="Third Pic"><br>该图中四个模块我们一一来介绍一下：</p><ol><li><p>PostgreSQL Server</p><p> 该部分属于数据库系统的核心部分，负责处理数据库的存储、检索和管理操作。所有操作都是通过这个部分来进行的（谁不选头拧下来当球踢）。</p></li><li><p>pgAdmin 4</p><p> 一个功能强大的开源管理工具，提供了一个GUI来辅助用户进行各种操作。</p></li><li><p>Stack Builder</p><p> 这部分属于附加组件，为用户外提供了一些可以安装的模块，如PostGIS（地理信息系统扩展）、pgAgent（调度工具）、pgBouncer（连接池管理器）。</p></li><li><p>Command Line Tools</p><p> 这个是PostgreSQL提供的命令行工具，有多个工具组成</p><ul><li>psql：交互式SQL命令行工具，允许用户执行SQL查询和脚本。</li><li>pg_dump：用于备份数据库。</li><li>pg_restore：用于恢复数据库。</li><li>pg_ctl：用于启动、停止和重启PostgreSQL服务器。</li></ul><p> 这些工具适用于脚本化和自动化数据库管理任务，特别是在没有图形界面的环境中。</p></li></ol><p>这里的Data Directory是和我们前面设置的安装地址是捆绑的，如果改为其他盘会直接被修改。不过为了保险起见先查看一下再点Next。</p><p><img src="/../img/Data%20Directory.png" alt="alt text"><br>在这里我们需要注意的是这个密码是我们数据库管理员的密码，也有就是root用户密码。</p><p><img src="/img/Password.png" alt="Fifth Pic"></p><p>这里的端口直接默认然后继续。</p><p><img src="/img/Port.png" alt="Sixth Pic"></p><p>这里选好自己需要的语言</p><p><img src="/../img/Advanced%20Options.png" alt="Seventh Pic"><br>最后确定好安装信息就可以开始安装了。</p><p>这个如果不需要可以不打勾</p><p><img src="/../img/Stack%20Builder.png" alt="Eight Pic"></p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>用<code>Win</code> + <code>s</code>打开搜索找到这个软件。</p><p><img src="/../img/Open%20PgAdmin4.png" alt="First Pic"><br>成功安装的话这里会弹出让我们去填写密码的弹窗，如果没有点一下侧边栏的Servers。这里推荐重新创建一个密码，如果实在懒也可以使用我们root用户的</p><p><img src="/../img/Connect%20to%20Server.png" alt="Second Pic"><br>最后成功安装并检验成功就会得到这个页面<br><img src="/img/Finish.png" alt="Finish"></p><h1 id="后记——解决问题"><a href="#后记——解决问题" class="headerlink" title="后记——解决问题"></a>后记——解决问题</h1><p>在我查找资料过程中发现，国内外无数人在安装过程中都遇到了集群初始化失败的问题。这里我们需要明白一个事情，单纯的卸载重装没有用处（我重装两次都一样！气死我了！）</p><p>接下来我们就需要来完整的说明我们需要怎么去做。</p><ol><li>首先在我们卸载后需要清除我们的注册表win+r ，输入regedit.exe 回车，编辑&gt;查找&gt;输入postgresql&gt;删除相关内容（应该是两个）</li><li>关闭防火墙，如果用的火绒开启免打扰</li><li>输入<code>win</code>+<code>R</code>然后输入cmd，使用<code>Ctrl</code>+<code>Shift</code>+<code>Enter</code>通过管理员打开命令窗口</li><li>使用<code>net user postgres /delete</code>来删除可能已经存在的postgres</li><li>使用<code>net user /add postgres &lt;password&gt;</code>来建立用户，这里记得换成自己的password</li><li>使用<code>net localgroup administrators postgres /add</code>将 postgres 用户添加到管理员组</li><li>用<code>net localgroup &quot;power users&quot; postgres /add</code>将 postgres 用户添加到 Power Users 组</li><li>接下来直接找到我们前面下载的exe文件，右键然后选择<em><strong>以管理员身份运行</strong></em>。这里必须再次强调一点，使用这个方法的原因是因为直接使用命令行去运行exe文件依旧存在问题，所以选择跳出命令行去执行。这样理论上是可以完成安装，后续可以按照正常安装顺序去安装。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——Hash</title>
    <link href="/2024/08/01/Hash/"/>
    <url>/2024/08/01/Hash/</url>
    
    <content type="html"><![CDATA[<p>今天来说一下leetcode面试经典150题中哈希表部分的题</p><h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383 赎金信"></a>383 赎金信</h1><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code>，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p>示例 1：</p><p>输入：ransomNote &#x3D; “a”, magazine &#x3D; “b”</p><p>输出：false</p><p>示例 2：</p><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “ab”</p><p>输出：false</p><p>示例 3：</p><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “aab”</p><p>输出：true</p><p>提示：</p><p><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></p><p><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>看到题目第一眼，需要用hash来对元素进行统计</li><li>可以利用Counter()函数来实现统计</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canConstruct</span>(<span class="hljs-params">self, ransomNote: <span class="hljs-built_in">str</span>, magazine: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        cnt = Counter(magazine)<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> ransomNote:<br>            <span class="hljs-keyword">if</span> c <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> cnt <span class="hljs-keyword">or</span> cnt[c] == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            cnt[c] -= <span class="hljs-number">1</span><br>            <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(m + n)，执行时间54ms，消耗内存16.4MB</p><h1 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205 同构字符串"></a>205 同构字符串</h1><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，判断它们是否是同构的。</p><p>如果 <code>s</code> 中的字符可以按某种映射关系替换得到 <code>t</code> ，那么这两个字符串是同构的。</p><p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p><p>示例 1:</p><p>输入：s &#x3D; <code>&quot;egg&quot;</code>, t &#x3D; <code>&quot;add&quot;</code></p><p>输出：true</p><p>示例 2：</p><p>输入：s &#x3D; <code>&quot;foo&quot;</code>, t &#x3D; <code>&quot;bar&quot;</code></p><p>输出：false</p><p>示例 3：</p><p>输入：s &#x3D; <code>&quot;paper&quot;</code>, t &#x3D; <code>&quot;title&quot;</code></p><p>输出：true</p><p>提示：</p><p><code>1 &lt;= s.length &lt;= 5 * 104</code></p><p><code>t.length == s.length</code></p><p><code>s</code> 和 <code>t</code> 由任意有效的 ASCII 字符组成</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li>首先明确每个字符是需要和自己当前位置所对应的索引直接对应到另一字符串，说人话就是<code>i[1]</code>的对应到<code>j[1]</code>上。</li><li>在前面的基础上，需要一一对应也就可以转换为s的和t的两个交换位置后所形成的字符串并不会和原本的字符串不同，只是平移了</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isIsomorphic</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        h1 = &#123;&#125;<br>        h2 = &#123;&#125;<br>        <span class="hljs-keyword">for</span> sc, tc <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(s, t):<br>            <span class="hljs-keyword">if</span> (sc <span class="hljs-keyword">in</span> h1 <span class="hljs-keyword">and</span> h1[sc] != tc) <span class="hljs-keyword">or</span> (tc <span class="hljs-keyword">in</span> h2 <span class="hljs-keyword">and</span> h2[tc] != sc):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            h1[sc] = tc<br>            h2[tc] = sc<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间49ms，消耗内存16.4MB</p><h1 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290 单词规律"></a>290 单词规律</h1><p>给定一种规律 <code>pattern</code> 和一个字符串 <code>s</code> ，判断 <code>s</code> 是否遵循相同的规律。</p><p>这里的 遵循 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>s</code> 中的每个非空单词之间存在着双向连接的对应规律。</p><p>示例1:</p><p>输入: pattern &#x3D; <code>&quot;abba&quot;</code>, s &#x3D; <code>&quot;dog cat cat dog&quot;</code></p><p>输出: true</p><p>示例 2:</p><p>输入:pattern &#x3D; <code>&quot;abba&quot;</code>, s &#x3D; <code>&quot;dog cat cat fish&quot;</code></p><p>输出: false</p><p>示例 3:</p><p>输入: pattern &#x3D; <code>&quot;aaaa&quot;</code>, s &#x3D; <code>&quot;dog cat cat dog&quot;</code></p><p>输出: false</p><p>提示:</p><p><code>1 &lt;= pattern.length &lt;= 300</code></p><p><code>pattern</code> 只包含小写英文字母</p><p><code>1 &lt;= s.length &lt;= 3000</code></p><p><code>s</code> 只包含小写英文字母和 <code>&#39; &#39;</code></p><p><code>s</code> <strong>不包含</strong> 任何前导或尾随对空格</p><p><code>s</code> 中每个单词都被 <strong>单个空格</strong> 分隔</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ol><li>首先我们需要将我们s中的单词进行分割，然后再开始匹配</li><li>后续匹配思路和前一题一样</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordPattern</span>(<span class="hljs-params">self, pattern: <span class="hljs-built_in">str</span>, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        words = s.split(<span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pattern) != <span class="hljs-built_in">len</span>(words):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        h1 = &#123;&#125;<br>        h2 = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, word <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(pattern, words):<br>            <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> h1 <span class="hljs-keyword">and</span> h1[i] != word) <span class="hljs-keyword">or</span> (word <span class="hljs-keyword">in</span> h2 <span class="hljs-keyword">and</span> h2[word] != i):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            h1[i] = word<br>            h2[word] = i<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(m + n)，执行时间45ms，消耗内存16.3MB</p><h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242 有效的字母异位词"></a>242 有效的字母异位词</h1><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。</p><p>注意：若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code> 互为字母异位词。</p><p>示例 1:</p><p>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”</p><p>输出: true</p><p>示例 2:</p><p>输入: s &#x3D; “rat”, t &#x3D; “car”</p><p>输出: false</p><p>提示:</p><p><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></p><p><code>s</code> 和 <code>t</code> 仅包含小写字母</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><p>用一个defaultdict存储s中的数量，如果t中存在就减少一个，逐个匹配</p><h3 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h3><p>用一个hash表来存储所有的字符和数量，一一匹配，存在就-1。最后记得delete我们的hash并输出结果</p><h3 id="第一版代码"><a href="#第一版代码" class="headerlink" title="第一版代码"></a>第一版代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAnagram</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) != <span class="hljs-built_in">len</span>(t):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        dic = defaultdict(<span class="hljs-built_in">int</span>)<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>            dic[c] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> t:<br>            dic[c] -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> dic.values():<br>            <span class="hljs-keyword">if</span> val != <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="第二版代码"><a href="#第二版代码" class="headerlink" title="第二版代码"></a>第二版代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAnagram</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) != <span class="hljs-built_in">len</span>(t):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        char_count = &#123;&#125;<br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:<br>            char_count[char] = char_count.get(char, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> t:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> char_count:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            char_count[char] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> char_count[char] == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">del</span> char_count[char]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(char_count) == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="第一版-1"><a href="#第一版-1" class="headerlink" title="第一版"></a>第一版</h3><p>时间复杂度O(n)，执行时间44ms，消耗内存16.4MB</p><h3 id="第二版-1"><a href="#第二版-1" class="headerlink" title="第二版"></a>第二版</h3><p>时间复杂度O(n)，执行时间50ms，消耗内存16.3MB</p><h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49 字母异位词分组"></a>49 字母异位词分组</h1><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p>示例 1:</p><p>输入: strs &#x3D; <code>[&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code></p><p>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</p><p>示例 2:</p><p>输入: strs &#x3D; <code>[&quot;&quot;]</code></p><p>输出: [[“”]]</p><p>示例 3:</p><p>输入: strs &#x3D; <code>[&quot;a&quot;]</code></p><p>输出: [[“a”]]</p><p>提示：</p><p><code>1 &lt;= strs.length &lt;= 104</code></p><p><code>0 &lt;= strs[i].length &lt;= 100</code></p><p><code>strs[i]</code> 仅包含小写字母</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><ol><li>见到题目第一时间想到两件事情，第一用hash存储键值对，和前面的题类似用值来进行匹配；第二字母异构意味着两个“单词”之间的字母都是一样的，也就是说经过排序可以得到相同的东西</li><li>通过sorted进行排序后，该字符将之间转换为按照字母顺序排序的字符。这时后续如果还存在和他一样字符就会被加入到hash中，最后我们直接忽略key，输出values就可以得到预期结果</li></ol><p>提示：这里我们使用defaultdict(list)是需要利用list作为默认值，会在不存在的键上初始化一个默认值。而我们使用{}字典则不会这样做，会造成测试样例中strs为空的情况下运行失败。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:<br>        <span class="hljs-built_in">dict</span> = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> strs:<br>            tmp = <span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">sorted</span>(s))<br>            <span class="hljs-keyword">if</span> tmp <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>:<br>                <span class="hljs-built_in">dict</span>[tmp].append(s)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">dict</span>[tmp] = [s]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>.values())<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(m * n log n)，执行时间58ms，消耗内存19.1MB</p><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1 两数之和"></a>1 两数之和</h1><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <code>target</code>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</p><p>输出：[0,1]</p><p>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</p><p>示例 2：</p><p>输入：nums &#x3D; [3,2,4], target &#x3D; 6</p><p>输出：[1,2]</p><p>示例 3：</p><p>输入：nums &#x3D; [3,3], target &#x3D; 6</p><p>输出：[0,1]</p><p>提示：</p><p><code>2 &lt;= nums.length &lt;= 104</code></p><p><code>-109 &lt;= nums[i] &lt;= 109</code></p><p><code>-109 &lt;= target &lt;= 109</code></p><p><strong>只会存在一个有效答案</strong></p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>需要两个数也就是两个指针，当i指向的和j指向的加和能够等于target就直接输出</p><p>提示：用hash去做更快，该思路是用两个循环去做的。后续也会附上用hash去做的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] == target:<br>                    <span class="hljs-keyword">return</span> [i, j]<br></code></pre></td></tr></table></figure><p>用hash去做的代码如下，这个代码整体会比前面的按照题目直译去做快很多，如果只是为了对付笔试可以用前一个，但是面试最好还是用hash，毕竟面试官看你做leetcode第一题都只会用循环去硬怼印象分肯定大打折扣。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pyhton">class Solution:<br>    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:<br>        dic = &#123;&#125;<br>        for i, num in enumerate(nums):<br>            if target - num in dic:<br>                return [dic[target-num], i]<br>            dic[num] = i<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="双循环"><a href="#双循环" class="headerlink" title="双循环"></a>双循环</h3><p>时间复杂度$O(n^2)$，执行时间1824ms，消耗内存17MB</p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>时间复杂度O(n)，执行时间42ms，消耗内存17.6MB</p><h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202 快乐数"></a>202 快乐数</h1><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</p><p>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</p><p>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</p><p>如果 <code>n</code> 是 快乐数 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p>示例 1：</p><p>输入：n &#x3D; 19</p><p>输出：true</p><p>解释：</p><p>12 + 92 &#x3D; 82</p><p>82 + 22 &#x3D; 68</p><p>62 + 82 &#x3D; 100</p><p>12 + 02 + 02 &#x3D; 1</p><p>示例 2：</p><p>输入：n &#x3D; 2</p><p>输出：false</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 231 - 1</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><ol><li>一个函数用set去存储已经出现过的数字，每次循环时将n加入到这个set中</li><li>循环的停止条件为等于1和在seen中</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isHappy</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        seen = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">while</span> n != <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> n <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:<br>            seen.add(n)<br>            n = <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">int</span>(i)**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(n))<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间44ms，消耗内存16.3MB</p><h1 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219 存在重复元素 II"></a>219 存在重复元素 II</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，判断数组中是否存在两个 <strong>不同的索引</strong> <code>i</code> 和 <code>j</code> ，满足 <code>nums[i] == nums[j]</code> 且 <code>abs(i - j) &lt;= k</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3,1], k &#x3D; 3</p><p>输出：true</p><p>示例 2：</p><p>输入：nums &#x3D; [1,0,1,1], k &#x3D; 1</p><p>输出：true</p><p>示例 3：</p><p>输入：nums &#x3D; [1,2,3,1,2,3], k &#x3D; 2</p><p>输出：false</p><p>提示：</p><p><code>1 &lt;= nums.length &lt;= 105</code></p><p><code>-109 &lt;= nums[i] &lt;= 109</code></p><p><code>0 &lt;= k &lt;= 105</code></p><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>用哈希表存索引和值，只要然后按照题目所给的True判断条件写代码。不要忽略最后需要一个False，不然会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">containsNearbyDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        dic = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> num <span class="hljs-keyword">in</span> dic <span class="hljs-keyword">and</span> i - dic[num] &lt;= k:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            dic[num] = i<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间91ms，消耗内存29.3MB</p><h1 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128 最长连续序列"></a>128 最长连续序列</h1><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>明确一点，当我们当前num的前一个数不在我们的hash中，我们就默认当前序列从num开始。那么结束便是当前num的后一个数不在hash中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestConsecutive</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        res = <span class="hljs-number">0</span><br>        num_count = <span class="hljs-built_in">set</span>(nums)<br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> num_count:<br>            <span class="hljs-keyword">if</span> (num - <span class="hljs-number">1</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> num_count:<br>                num_len = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">while</span> (num + <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> num_count:<br>                    num_len += <span class="hljs-number">1</span><br>                    num += <span class="hljs-number">1</span><br>                res = <span class="hljs-built_in">max</span>(res, num_len)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间104ms，消耗内存32.6MB</p><p>根据这个集合给出的题目来看，hash这部分的题目已简单题或中等题考察居多，核心逻辑都是一个——利用hash特有的键值对去进行匹配等操作，所以把握好本质就比较简单了。不过真的不想遇到hash，脑子一转不过来就完犊子。</p><p>最后附上封面的猫猫图片（在这里还是要夸一下iPhone的微距，拍出来真的不错  ）<br><img src="/../img/hash%20blog%20cover.jpg" alt="hash cover"></p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——矩阵</title>
    <link href="/2024/07/30/my-fourth-blog/"/>
    <url>/2024/07/30/my-fourth-blog/</url>
    
    <content type="html"><![CDATA[<p>这篇Blog将分享我在做leetcode面试经典150题中矩阵部分几道题的做题思路和代码。</p><h1 id="36-有效的数组"><a href="#36-有效的数组" class="headerlink" title="36 有效的数组"></a>36 有效的数组</h1><p>请你判断一个 <code>9 x 9</code> 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p><p>数字 <code>1-9</code> 在每一行只能出现一次。<br>数字 <code>1-9</code> 在每一列只能出现一次。<br>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</p><p>注意：</p><p>一个有效的数独（部分已被填充）不一定是可解的。</p><p>只需要根据以上规则，验证已经填入的数字是否有效即可。</p><p>空白格用 <code>&#39;.&#39;</code> 表示。</p><p>示例 1：</p><p><img src="/../img/%E6%9C%89%E6%95%88%E6%95%B0%E7%8B%AC_%E7%A4%BA%E4%BE%8B1.png" alt="示例 1"></p><p>输入：board &#x3D; </p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">[[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>]<br>,[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>,[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br></code></pre></td></tr></table></figure><p>输出：true</p><p>示例 2：</p><p>输入：board &#x3D; </p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">[[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>]<br>,[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>,[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br></code></pre></td></tr></table></figure><p>输出：false</p><p>解释：除了第一行的第一个数字从 <strong>5</strong> 改为 <strong>8</strong> 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</p><p>提示：</p><p><code>board.length == 9</code></p><p><code>board[i].length == 9</code></p><p><code>board[i][j]</code> 是一位数字<code>（1-9）</code>或者 <code>&#39;.&#39;</code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>核心条件就是每行每列每3*3的区域内不能重复</li><li>设置一个索引b来表示该数字在3*3区域内的索引<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidSudoku</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 初始化三个二维列表来跟踪三个维度的数字情况</span><br>        row = [[<span class="hljs-number">0</span>] * <span class="hljs-number">9</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]<br>        col = [[<span class="hljs-number">0</span>] * <span class="hljs-number">9</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]<br>        block = [[<span class="hljs-number">0</span>] * <span class="hljs-number">9</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>                <span class="hljs-keyword">if</span> board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>:<br>                    num = <span class="hljs-built_in">int</span>(board[i][j]) - <span class="hljs-number">1</span> <span class="hljs-comment"># 将数字字符转化为整数并调整为0索引</span><br>                    b = (i // <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + j // <span class="hljs-number">3</span> <span class="hljs-comment"># 建立b索引</span><br>                    <span class="hljs-keyword">if</span> row[i][num] <span class="hljs-keyword">or</span> col[j][num] <span class="hljs-keyword">or</span> block[b][num]:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                    row[i][num] = col[j][num] = block[b][num] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(1)，执行时间56ms，消耗内存16.2MB</p><h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54 螺旋矩阵"></a>54 螺旋矩阵</h1><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong>，返回矩阵中的所有元素。</p><p>示例 1：</p><p><img src="/../img/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5_%E7%A4%BA%E4%BE%8B1.jpg" alt="示例 1"></p><p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</p><p>输出：[1,2,3,6,9,8,7,4,5]</p><p>示例 2：</p><p><img src="/../img/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5_%E7%A4%BA%E4%BE%8B2.jpg" alt="示例 2"></p><p>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</p><p>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p><p>提示：</p><p><code>m == matrix.length</code></p><p><code>n == matrix[i].length</code></p><p><code>1 &lt;= m, n &lt;= 10</code></p><p><code>-100 &lt;= matrix[i][j] &lt;= 100</code></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>相当于走格子，第一行走完走最后一列，最后一列走完走最后一行，最后一行走完走第一列，最后各自缩小一格然后走内侧。</p><p>提示：这里需要注意，从左到右遍历顶部行的时候不能用<code>[0]</code>来表示，会影响后续。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spiralOrder</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> matrix: <span class="hljs-keyword">return</span> []<br>        left, right, top, bottom = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(matrix) - <span class="hljs-number">1</span><br>        res = []<br>        <span class="hljs-keyword">while</span> left &lt;= right <span class="hljs-keyword">and</span> top &lt;= bottom:<br>            <span class="hljs-comment"># 从左到右遍历顶部行</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left, right + <span class="hljs-number">1</span>):<br>                res.append(matrix[top][i])<br>            <span class="hljs-comment"># 从上到下遍历右侧列</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(top + <span class="hljs-number">1</span>, bottom + <span class="hljs-number">1</span>):<br>                res.append(matrix[j][right])<br>            <span class="hljs-keyword">if</span> left &lt; right <span class="hljs-keyword">and</span> top &lt; bottom:<br>                <span class="hljs-comment"># 从右到左遍历底部行</span><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(right - <span class="hljs-number">1</span>, left, -<span class="hljs-number">1</span>):<br>                    res.append(matrix[bottom][i])<br>                <span class="hljs-comment"># 从下到上遍历左侧列</span><br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(bottom, top, -<span class="hljs-number">1</span>):<br>                    res.append(matrix[j][left])<br>            left, right, top, bottom = left + <span class="hljs-number">1</span>, right - <span class="hljs-number">1</span>, top + <span class="hljs-number">1</span>, bottom - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(m*n)，执行用时55ms，消耗内存16.4MB</p><h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48 旋转图像"></a>48 旋转图像</h1><p>给定一个 n × n 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 <code>90</code> 度。</p><p>你必须在 <em><strong>原地</strong></em> 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p>示例 1：</p><p><img src="/../img/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F_%E7%A4%BA%E4%BE%8B1.jpg" alt="示例 1"></p><p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</p><p>输出：[[7,4,1],[8,5,2],[9,6,3]]</p><p>示例 2：</p><p><img src="/../img/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F_%E7%A4%BA%E4%BE%8B2.jpg" alt="示例 2"></p><p>输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</p><p>输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p><p>提示：</p><p><code>n == matrix.length == matrix[i].length</code></p><p><code>1 &lt;= n &lt;= 20</code></p><p><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ol><li>先明确题目要求是讲整个矩阵顺时针旋转90°</li><li>根据每个元素坐标来看，我们只需要将每个元素的坐标交换，最后将整个图像进行逐行反转就能直接完成</li></ol><p>下面有一个比较形象的图来演示一下过程</p><p><img src="/../img/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F_%E6%BC%94%E7%A4%BA.jpg" alt="演示"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        n = <span class="hljs-built_in">len</span>(matrix)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, n):<br>                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            matrix[i].reverse()<br>        <span class="hljs-keyword">return</span> matrix<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O($n^2$)，执行时间36ms，消耗内存16.5MB</p><h1 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73 矩阵置零"></a>73 矩阵置零</h1><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <em><strong>原地</strong></em> 算法。</p><p>示例 1：</p><p><img src="/../img/%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6_%E7%A4%BA%E4%BE%8B1.jpg" alt="示例 1"></p><p>输入：matrix &#x3D; [[1,1,1],[1,0,1],[1,1,1]]</p><p>输出：[[1,0,1],[0,0,0],[1,0,1]]</p><p>示例 2：</p><p><img src="/../img/%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6_%E7%A4%BA%E4%BE%8B2.jpg" alt="示例 2"></p><p>输入：matrix &#x3D; [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</p><p>输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</p><p>提示：</p><p><code>m == matrix.length</code></p><p><code>n == matrix[0].length</code></p><p><code>1 &lt;= m, n &lt;= 200</code></p><p><code>-231 &lt;= matrix[i][j] &lt;= 231 - 1</code></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ol><li>设置两个集合来存储横纵坐标。</li><li>两次遍历，第一次遍历标记为0的元素横纵坐标并分别添加到set中，第二次遍历对元素进行修改。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setZeroes</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> matrix <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(matrix) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> matrix<br>        rows, cols = <span class="hljs-built_in">set</span>(), <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span>:<br>                    rows.add(i)<br>                    cols.add(j)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> rows <span class="hljs-keyword">or</span> j <span class="hljs-keyword">in</span> cols:<br>                    matrix[i][j] = <span class="hljs-number">0</span>    <br>        <span class="hljs-keyword">return</span> matrix<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度$O(m*n)$，执行时间38ms，消耗内存17.1MB</p><h1 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289 生命游戏"></a>289 生命游戏</h1><p>根据 <a href="https://baike.baidu.com/item/%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/22668799?fromtitle=%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F&fromid=2926434">百度百科</a> ，<strong>生命游戏</strong> ，简称为 <strong>生命</strong> ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p><p>给定一个包含 <code>m × n </code>个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： <code>1</code> 即为 活细胞 （live），或 <code>0</code> 即为 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><p>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</p><p>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</p><p>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</p><p>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</p><p>下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 <code>m x n</code> 网格面板 <code>board</code> 的当前状态，返回下一个状态。</p><p>示例 1：</p><p><img src="/../img/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F_%E7%A4%BA%E4%BE%8B1.jpg" alt="示例 1"></p><p>输入：board &#x3D; [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]</p><p>输出：[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]</p><p>示例 2：</p><p><img src="/../img/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F_%E7%A4%BA%E4%BE%8B2.jpg" alt="示例 2"></p><p>输入：board &#x3D; [[1,1],[1,0]]</p><p>输出：[[1,1],[1,1]]</p><p>提示：</p><p><code>m == board.length</code></p><p><code>n == board[i].length</code></p><p><code>1 &lt;= m, n &lt;= 25</code></p><p><code>board[i][j]</code> 为 <code>0</code> 或 <code>1</code></p><h2 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gameOfLife</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board: <span class="hljs-keyword">return</span> <br>        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-built_in">dict</span> = [(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">for</span> dx, dy <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>:<br>                    x, y = i + dx, j + dy<br>                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= x &lt; m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= y &lt; n:<br>                        cnt += board[x][y] &amp; <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (cnt &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> cnt &gt; <span class="hljs-number">3</span>):<br>                    board[i][j] = <span class="hljs-number">3</span><br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> cnt == <span class="hljs-number">3</span>:<br>                    board[i][j] = <span class="hljs-number">2</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                board[i][j] &gt;&gt;= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这个版本的代码直接报错，而后根据相似的思路重新写了一个版本的代码，先讲一下思路。</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ol><li>设置好八个位置的坐标</li><li>设置一个函数用于对某个位置的细胞周围的活细胞进行标记</li><li>根据题目所给出的情况进行处理</li><li>最后对所有位置的细胞进行遍历</li><li>-1表示当前细胞是从活变死，2表示当前细胞是从死变活</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gameOfLife</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> board[<span class="hljs-number">0</span>]:<br>            <span class="hljs-keyword">return</span><br>    <br>        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>        directions = [(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">count_live_neighbors</span>(<span class="hljs-params">x, y</span>):<br>            count = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> dx, dy <span class="hljs-keyword">in</span> directions:<br>                nx, ny = x + dx, y + dy<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; n <span class="hljs-keyword">and</span> <span class="hljs-built_in">abs</span>(board[nx][ny]) == <span class="hljs-number">1</span>:<br>                    count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> count<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                live_neighbors = count_live_neighbors(i, j)<br>                <br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (live_neighbors &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> live_neighbors &gt; <span class="hljs-number">3</span>):<br>                    board[i][j] = -<span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> live_neighbors == <span class="hljs-number">3</span>:<br>                    board[i][j] = <span class="hljs-number">2</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> board[i][j] == -<span class="hljs-number">1</span>:<br>                    board[i][j] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">elif</span> board[i][j] == <span class="hljs-number">2</span>:<br>                    board[i][j] = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度$O(m * n)$，执行时间36ms，消耗内存16.5MB</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode刷题——滑动窗口</title>
    <link href="/2024/07/21/my-third-post/"/>
    <url>/2024/07/21/my-third-post/</url>
    
    <content type="html"><![CDATA[<p>这篇Blog将分享我自己在做Leetcode面试经典150题中滑动窗口部分几道题的思路，let’s go。</p><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> 。</p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的子数组 [$nums_l$, $nums_{l+1}$, …, $nums_{r - 1}$, $nums_r$] ，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p>示例 1：</p><pre><code class="hljs">输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 `[4,3]` 是该条件下的长度最小的子数组。</code></pre><p>示例 2：</p><pre><code class="hljs">输入：target = 4, nums = [1,4,4]输出：1</code></pre><p>示例 3：</p><pre><code class="hljs">输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0</code></pre><p>提示：</p><p><code>1 &lt;= target &lt;= 109</code></p><p><code>1 &lt;= nums.length &lt;= 105</code></p><p><code>1 &lt;= nums[i] &lt;= 105</code></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>第一个while循环中total不断累加end位置上的值</li><li>第二个循环判断total &gt;&#x3D; target，这时满足了条件中所说的大于等于</li><li>用ans来存储数组，并对其进行最小值比较</li><li>total和start都后移，窗口滑动一位</li></ol><p>提示：</p><p>这里的窗口并不是一成不变的，而是不断累加到满足条件，期间窗口可能包含一个两个三个数。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSubArrayLen</span>(<span class="hljs-params">self, target:<span class="hljs-built_in">int</span>, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        ans = n + <span class="hljs-number">1</span><br>        start, end = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        total = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> end &lt; n:<br>            total += nums[end]<br>            <span class="hljs-keyword">while</span> total &gt;= target:<br>                ans = <span class="hljs-built_in">min</span>(ans, end - start + <span class="hljs-number">1</span>)<br>                total -= nums[start]<br>                start += <span class="hljs-number">1</span><br>            end += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> ans == n + <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> ans<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度O(n)，执行用时60ms，消耗内存26.9MB</p><h2 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p><p>示例 1:</p><pre><code class="hljs">输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 `&quot;abc&quot;`，所以其长度为 3。</code></pre><p>示例 2:</p><pre><code class="hljs">输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 `&quot;b&quot;`，所以其长度为 1。</code></pre><p>示例 3:</p><pre><code class="hljs">输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 `&quot;wke&quot;`，所以其长度为 3。请注意，你的答案必须是**子串**的长度，`&quot;pwke&quot;` 是一个子序列，不是子串。</code></pre><p>提示：</p><p><code>0 &lt;= s.length &lt;= 5 * 104</code></p><p><code>s</code> 由英文字母、数字、符号和空格组成</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>首先确定需要使用滑动窗口和哈希表</li><li>哈希表用于存储字符和其对应的索引</li><li>当字符已经存在于哈希表中，对应的滑动窗口左边界移到该字符存储于哈希表中的索引位置</li><li>涉及到四个初始变量。<code>n</code>表示s的长度，<code>ans</code>用于存储结果，哈希表<code>mp</code>，指针<code>j</code>表示左边界</li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        ans = <span class="hljs-number">0</span><br>        mp = &#123;&#125;<br>        j = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">in</span> mp:<br>                j = <span class="hljs-built_in">max</span>(mp[s[i]], j)<br>            ans = <span class="hljs-built_in">max</span>(ans, i - j + <span class="hljs-number">1</span>)<br>            mp[s[i]] = i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度O(n)，执行用时52ms，消耗内存16.5MB</p><h2 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30.串联所有单词的子串"></a>30.串联所有单词的子串</h2><p>给定一个字符串 <code>s</code> 和一个字符串数组 <code>words</code>。 <code>words</code> 中所有字符串 <strong>长度相同</strong>。</p><p><code>s</code> 中的 <strong>串联子串</strong> 是指一个包含  <code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p><ul><li>例如，如果 <code>words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>， 那么 <code>&quot;abcdef&quot;</code>， <code>&quot;abefcd&quot;</code>，<code>&quot;cdabef&quot;</code>， <code>&quot;cdefab&quot;</code>，<code>&quot;efabcd&quot;</code>， 和 <code>&quot;efcdab&quot;</code> 都是串联子串。 <code>&quot;acdbef&quot;</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li></ul><p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p><p>示例1：</p><pre><code class="hljs">输入：s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]输出：`[0,9]`解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。子串 &quot;barfoo&quot; 开始位置是 0。它是 words 中以 [&quot;bar&quot;,&quot;foo&quot;] 顺序排列的连接。子串 &quot;foobar&quot; 开始位置是 9。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。输出顺序无关紧要。返回 [9,0] 也是可以的。</code></pre><p>示例2：</p><pre><code class="hljs">输入：s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]输出：`[]`解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。所以我们返回一个空数组。</code></pre><p>示例 3：</p><pre><code class="hljs">输入：s = &quot;barfoofoobarthefoobarman&quot;, words = [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]输出：`[6,9,12]`解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。子串 &quot;foobarthe&quot; 开始位置是 6。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;] 顺序排列的连接。子串 &quot;barthefoo&quot; 开始位置是 9。它是 words 中以 [&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;] 顺序排列的连接。子串 &quot;thefoobar&quot; 开始位置是 12。它是 words 中以 [&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。</code></pre><p>提示：</p><p><code>1 &lt;= s.length &lt;= 104</code></p><p><code>1 &lt;= words.length &lt;= 5000</code></p><p><code>1 &lt;= words[i].length &lt;= 30</code></p><p><code>words[i]</code> 和 <code>s</code> 由小写英文字母组成</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>最开始初始化五个变量，<code>word_len</code>单词长度，<code>total_len</code>单词长度之和，<code>word_map</code>用Counter记录每个单词出现的次数，<code>ans</code>用于存储结果</li><li>滑动窗口每次滑动一个单词长度，当我们窗口内的单词出现次数和原本的不匹配就移动右边界，直到窗口内单词计数不超过原始计数</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> words:<br>            <span class="hljs-keyword">return</span> []<br><br>        word_len = <span class="hljs-built_in">len</span>(words[<span class="hljs-number">0</span>])<br>        word_count = <span class="hljs-built_in">len</span>(words)<br>        total_len = word_len * word_count<br>        word_map = Counter(words)<br>        ans = []<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(word_len):<br>            left = i<br>            right = i<br>            cur_map = Counter()<br>            <span class="hljs-keyword">while</span> right + word_len &lt;= <span class="hljs-built_in">len</span>(s):<br>                word = s[right:right + word_len]<br>                right += word_len<br>                <span class="hljs-keyword">if</span> word <span class="hljs-keyword">in</span> word_map:<br>                    cur_map[word] += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> cur_map[word] &gt; word_map[word]:<br>                        cur_map[s[left:left + word_len]] -= <span class="hljs-number">1</span><br>                        left += word_len<br>                    <span class="hljs-keyword">if</span> right - left == total_len:<br>                        ans.append(left)<br>                <span class="hljs-keyword">else</span>:<br>                    cur_map.clear()<br>                    left = right<br><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度O(n * m)，执行时间72ms，消耗内存17.1MB</p><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76 最小覆盖子串"></a>76 最小覆盖子串</h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p>注意：</p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p>示例1：</p><pre><code class="hljs">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;输出：&quot;BANC&quot;解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#39;A&#39;、&#39;B&#39; 和 &#39;C&#39;。</code></pre><p>示例 2：</p><pre><code class="hljs">输入：s = &quot;a&quot;, t = &quot;a&quot;输出：&quot;a&quot;解释：整个字符串 s 是最小覆盖子串。</code></pre><p>示例 3:</p><pre><code class="hljs">输入: s = &quot;a&quot;, t = &quot;aa&quot;输出: &quot;&quot;解释: t 中两个字符 &#39;a&#39; 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</code></pre><p>提示：</p><p><code>m == s.length</code><br><code>n == t.length</code><br><code>1 &lt;= m, n &lt;= 105</code><br><code>s</code> 和 <code>t</code> 由英文字母组成</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>初始化五个变量，<code>need</code>用于记录<code>t</code>每个字符的需求数量，<code>missing</code>用于记录还需要匹配的字符数量，<code>left</code>左边界，<code>start</code>起始位置，<code>min_len</code>长度，<code>ans</code>存储结果</li><li>滑动窗口使用right指针遍历字符串<code>s</code>，如果当前字符在<code>need</code>中数量大于0则减少<code>missing</code>表示需求字符少一个</li><li>当<code>missing</code>为0即窗口内包含所有所需字符，移动left继续遍历直到 <code>need[s[left]]</code> 不再小于 0。</li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minWindow</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> t: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>        need = Counter(t)<br>        missing = <span class="hljs-built_in">len</span>(t)<br>        left = start = <span class="hljs-number">0</span><br>        min_len = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        ans = <span class="hljs-string">&quot;&quot;</span><br>        <br>        <span class="hljs-keyword">for</span> right, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s, <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> need[char] &gt; <span class="hljs-number">0</span>:<br>                missing -= <span class="hljs-number">1</span><br>            need[char] -= <span class="hljs-number">1</span><br>            <br>            <span class="hljs-keyword">if</span> missing == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> need[s[left]] &lt; <span class="hljs-number">0</span>:<br>                    need[s[left]] += <span class="hljs-number">1</span><br>                    left += <span class="hljs-number">1</span><br>                    <br>                <span class="hljs-keyword">if</span> right - left &lt; min_len:<br>                    min_len = right - left<br>                    ans = s[left:right]<br>                    <br>                need[s[left]] += <span class="hljs-number">1</span><br>                left += <span class="hljs-number">1</span><br>                missing += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度O(n)，执行用时108ms，消耗内存16.8MB</p><p>好的，滑动窗口部分的题目就四个，到这里就结束了。滑动窗口的核心思路就在于不断移动窗口去匹配题设所给出的条件，之前刷2024春招100题那会还没特别明白这部分，现在也是彻底会了🤣不过还是不想笔试或面试遇到，这个真的好烦。</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卧推训练过程中发现的一个小问题</title>
    <link href="/2024/07/20/My-Second-Blog/"/>
    <url>/2024/07/20/My-Second-Blog/</url>
    
    <content type="html"><![CDATA[<p>满打满算健身也快一年了，身材也有了极其明显的变化。虽然因为长时间坐着不动外加kuku吃碳水导致腰上肉长得飞快，也正因此上半身感觉上下没啥分别。说回正题，这篇Blog主要是想聊一下我自己最近遇到的也是我这么长时间以来完全忽略的一点，还是两个健身房里的大佬一块换着练的时候被指出来的。</p><h1 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h1><p>这个问题说起来也不是很大，实际上就是很多健身博主都在说的卧推的时候手腕的位置。我自己刚开始是听了那些博主的话，乖乖的每次都强行让手腕保持中立位，但每次都感觉非常的别扭。由于是自己练再加上原本就很瘦，我的卧推重量现在也只是60KG做组，之前30、40KG时每次练完胸回来手腕倒是没有不舒服，到45+就开始不对劲了。每次练完胸回来都感觉手腕非常难受，有的时候还需要用云南白药喷雾。自打我开始健身就听说过TFCC，我自己当时也有点担心会不会是，也做了下自测什么的，但最后的结果都是没问题。到这里我已经产生奇怪的念头了，为什么我每次明明戴了护腕还是会不舒服呢？</p><h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><p>直到那天和两个大佬一起练，我才知道我自己的手腕是非常塌的，基本上可以说完美符合网上所说的全靠手腕支撑杠铃。在这里我画了个简图。<br><img src="/../img/second%20blog%20pic.jpg" alt="alt text"><br>可以看到左侧是正常的手腕处于中立位，如果用正常视角来看杠铃杆就是靠我们虎口下面的部分来支持，说到这里还需要提到掰杠，不过这个问题我们后面再说。而右边就是我之前的卧推姿势，手腕非常塌，通过受力分析可以得到一个结论。除了杠铃在手上的重力、我们给杠铃的推力，还有一个向斜下方的力。由于我们以这种姿势卧推是靠手掌托住杠铃，手腕收到的力等于我们的重力。而斜向下的力属于对抗我们重力过程中的副产物，同样作用于手腕。故而我们可以得出结论，斜向下的力和重力双重叠加导致我们的手腕受到了大于杠铃本身的重力。</p><p>那么为什么说当保持中立位的时候我们的手腕不会受到那么大的力呢？这里我们需要了解到一个事情。当我们的手腕在中立位时，我们的手腕、手肘、小臂处于同一条线，力线垂直向下，重力垂直作用于前臂，相当于我们整个前臂来对抗重力。反观塌腕时我们单纯用手腕来对抗，很明显保持中立位是对我们的手腕很友好的。</p><h1 id="掰杠"><a href="#掰杠" class="headerlink" title="掰杠"></a>掰杠</h1><p>再说会掰杠，为什么很多博主会刻意提到掰杠中整个操作。这里我们来观察下，当我们不使用掰杠，单纯用正常的卧推姿势去卧推，我们杠铃位于我们的大鱼际上，这时我们可以发现，杠铃的重心是略微偏离我们的小臂垂直线的，这样可能会造成手腕略微压力增大。而我们手腕微微外旋我们就能发现，大鱼际和小鱼际近似处于一个平面，而平面和我们的小臂垂直线属于垂直。这时我们就可以达到我们前面所说的手腕中立位的“完美”卧推上臂姿势。</p><p>当然并不是说不掰杠就不好，掰杠的作用并不是单纯的为了减弱那么一丢丢力，而是我们的手腕本身就非常脆弱，软组织一旦损伤可以说这辈子都可能健身和say goodbye，毕竟这个软组织恢复慢、影响大，为了我们的日常生活和训练生活，我们一定要在动作标准的情况下尽最大可能避免受伤。</p><p>接下来就要说到掰杠最大的作用了——增加稳定性。健身的人通常都会熟悉一个名词叫做肩胛骨，可以说得肩胛骨者得天下（这话怎么和高中那会的得语文者得天下一模一样，不会提出这句话的人是语文老师吧）。肩胛骨负责了我们上半身非常多的作用，而卧推的准备过程中我们需要沉肩、稳定肩胛骨、稳定下半身、背部肌肉绷紧。这些无一例外都是为了稳定二字。而我们的掰杠，很大程度上是为了辅助我们去稳定肩胛骨，根据我微不足道的观察发现，现代人因为长时间伏案工作、滑手机已经导致我们的肩胛骨很容易形成翼状肩胛。翼状肩胛不仅难看而且非常影响我们的卧推稳定性（本次不讨论翼状肩胛对背部的影响，这个后续会写我自己背部训练还是有一定心得的）。也正因此掰杠提供的额外增加就很好的进行了补充。可以试一试先沉肩然后空手外旋，这时会发现我们的肩胛骨位置有明显的感觉。也正因此换到卧推当中，掰杠可以提供给我们额外的稳定性，让我们不至于把卧推做成诺克萨斯断头台🤣</p><h1 id="结束咯😝"><a href="#结束咯😝" class="headerlink" title="结束咯😝"></a>结束咯😝</h1><p>好的，相信看到这里的朋友已经明白为什么我会写这篇Blog了。从我自身角度来说，被指出问题后我对手腕姿势进行了修改，后续我卧推后也没有再出现特别难受的情况。同时我也去学习了掰杠技巧，进一步增强了卧推（虽然重量依旧没变化，大夏天真的吃啥都掉体重）。所以，我这一年中不断的磨合我的动作，不断上重量，不断学习。之前看到有人说过一句话“健身就是一年增重一年减重改动作的不断循环”，从我个人角度而言，我并不反对这句话，因为我自己这一年也是这么走过来的，从哑铃卧推6KG到现在的杠铃卧推60KG，从辅助引体需要50KG（那会我体重不到60）到现在轻松自重引体。但在这过程中我自己也在不断的反思学习，任何事情都是需要不断学习打磨，不断完善，世间并无一蹴而就的事情。</p><p>好咯，这次的Blog就到这里结束啦，有兴趣的朋友可以去我的IG看我拍的健身照片，不过应该看不出来啥区别，毕竟我发的时候已经有了一些变化了，最早很瘦的应该是没有的。</p>]]></content>
    
    
    <categories>
      
      <category>健身记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>健身</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>360技术综合H卷笔试——编程题记录</title>
    <link href="/2024/07/20/My-First-Blog/"/>
    <url>/2024/07/20/My-First-Blog/</url>
    
    <content type="html"><![CDATA[<p>360是我七月初就已经投的公司，同时也是我今年秋招第一个拿到笔试的公司。在考前按照往年的试卷估计题目应该是40道客观题2道编程题。实际结果也如预期一般，30多道的单选题，为数不多的多选题（每个卷子的题型不一样，maybe我这个卷子的少）以及2个编程题。接下来我将尽可能完整的复刻题目并阐述我自己的做法，同时也会附加我自己的代码，望各位看官满意。</p><h2 id="第一题-加密算法"><a href="#第一题-加密算法" class="headerlink" title="第一题 加密算法"></a><strong>第一题 加密算法</strong></h2><p>有两个人在研究加密算法，一个人提出对只包含小写英文字母的字符串，将 ’a’替换成 ’1’，将 ’b’;替换成 ’2’……，将 ’z’替换成 ’26’。比如一个字符串 ’aabac’（想不起来了，我编的），加密后变成了 ’11213’，但另外一个人提出困难会造成多个结果，就比如 ’11213’也可能是 ’kbm’，会产生多个结果。所以我们要做的就是计算某个加密后的字符串可能对应的原字符串个数，要求取模10^9+7。</p><p>输入：</p><p>第一行n是加密后的字符串长度</p><p>第二行是加密后的字符串</p><p>输出：</p><p>一个正整数表示原字符串个数</p><p>样例输入：</p><p>5</p><p>11213</p><p>样例输出：</p><p>8</p><p>在做题的时候我就感觉这题怎么这么熟悉，考完一看才发现这不就是leetcode 91 解码方法。</p><p>既然提到了那就顺便说一下这道题的思路吧，如果实在需要代码可以直接用笔试题的代码稍微改改应该maybe也能行？</p><p>首先这道题需要对一个问题进行多次匹配求解出多个情况。也就是说字符串’11213’可能被分为’1’和’1213’也可能被分为’11’和’213’类似于这样的不断进行。故而就想到了动态规划来解决。<br>接下来就需要具体构建：</p><ol><li>定义一个数组dp，其中dp[i]表示长度为i的加密字符串可能解码出的原字符串个数。</li><li>设置初始条件dp[0] &#x3D; 1，即空字符串有一种解码方式。</li><li>状态转移：<ul><li>如果当前字符可以作为有效的单字符解码(1 &lt;&#x3D; s[i - 1] &lt;&#x3D; 9)，则dp[i] +&#x3D; dp[i - 1]</li><li>如果当前字符和前一个字符可以作为一个有效的双字符解码(10 &lt;&#x3D; s[i - 2:i] &lt;&#x3D; 26)，则dp[i] +&#x3D; dp[i - 2]</li></ul></li><li>最终结果为dp[n]</li></ol><p>好的，接下来回到笔试的考题加密算法本身。</p><p>首先分析问题，我们需要给每个字母进行一一对应；加密后的字符串可能对应多个原字符串；我们需要对结果进行取模。<br>接下来来说说具体的思路：</p><ol><li>使用动态规划来解决</li><li>创建一个数组dp，其中dp[i]表示前i个数字可能对应的原字符串</li><li>对每个位置i，我们需要考虑单独解码和组合解码</li></ol><p>借助这个大致思路得到了下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_possible_string</span>(<span class="hljs-params">encoded</span>):<br>    MOD = <span class="hljs-number">1000000007</span><br>    n = <span class="hljs-built_in">len</span>(encoded)<br>    dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> encoded[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 单独解码</span><br>        <span class="hljs-keyword">if</span> encoded[i - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;0&#x27;</span>:<br>            dp[i] = dp[i - <span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 组合解码</span><br>        two_digit = <span class="hljs-built_in">int</span>(encoded[i - <span class="hljs-number">2</span>:i])<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">10</span> &lt;= two_digit &lt;= <span class="hljs-number">26</span>:<br>            dp[i] = (dp[i] + dp[i - <span class="hljs-number">2</span>]) % MOD<br><br>    <span class="hljs-keyword">return</span> dp[n]<br><br><span class="hljs-comment"># 输入</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>encoded = <span class="hljs-built_in">input</span>()<br><br><span class="hljs-comment"># 输出</span><br>result = count_possible_string(encoded)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>到这里第一题就结束了，不过我需要说明一点的是，我的代码并不是最优代码，只是能AC这道题，这里也只是提供一种代码和一种思路。</p><h2 id="第二题-传染病防控"><a href="#第二题-传染病防控" class="headerlink" title="第二题 传染病防控"></a>第二题 传染病防控</h2><p>某市正在进行传染病防控，某市有n个人，每个人有一个位置$(x_{i},y_{i})$。现在已知有一个是高风险人员，但不知道是谁。同时我们定义一个安全距离k，如果某个人和这个高风险人员的距离不超过k，那么这个人也将被列为高风险人员。所以我们现在需要帮工作人员得到最多的高风险人员数量。两个人$(x_1,y_1),(x_2,y_2)$的距离公式为$|x_1-x_2| + |y_1 - y_2|$。</p><p>输入描述：</p><p>一行两个整数n，k</p><p>接下来一行n个整数分别表示$x_1$到$x_n$</p><p>接下来一行n个整数分别表示$y_1$到$y_n$</p><p>输出描述：</p><p>输出一个整数表示最多的高风险人员数量</p><p>样例输入：（这里因为debug了好几遍输了好几遍所以还有记录，可以用原本的数）</p><p>5 2</p><p>8 6 1 5 1</p><p>4 4 3 4 6</p><p>样例输出：</p><p>3</p><p>首先明确一点，这个距离公式就是常用的曼哈顿距离，所以在正式写算法前需要先把这个距离公式给写了。</p><p>接下来说一下我的大致思路：</p><ol><li>首先构建图，根据输入的坐标和距离构建邻接矩阵<code>ajd</code></li><li>图的遍历：这里根据惯例选择DFS或BFS来遍历图，我选的是BFS，以此计算出某一点出发的最大连通节点数。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">max_high_risk</span>(<span class="hljs-params">n, k, x, y</span>):<br>    <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br>    <span class="hljs-comment"># 曼哈顿距离公式</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">manhatten_distance</span>(<span class="hljs-params">x1, y1, x2, y2</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(x1 - x2) + <span class="hljs-built_in">abs</span>(y1 - y2)<br><br>    <span class="hljs-comment"># 构建邻接表，adj[i]表示与第i个人相邻的所有人</span><br>    adj = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">if</span> manhatten_distance(x[i], y[i], x[j], y[j]) &lt;= k:<br>                adj[i].append(j)<br>                adj[j].append(i)<br><br>    <span class="hljs-comment"># 构建BFS            </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">start</span>):<br>        queue = deque([start])<br>        visited = <span class="hljs-built_in">set</span>([start])<br>        count = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> queue:<br>            current = queue.popleft()<br>            <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> adj[current]:<br>                <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>                    queue.append(neighbor)<br>                    visited.add(neighbor)<br>                    count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> count<br><br>    max_count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        max_count = <span class="hljs-built_in">max</span>(max_count, bfs(i))<br>    <span class="hljs-keyword">return</span> max_count<br><br><span class="hljs-comment"># 输入</span><br>n, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>x = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>y = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br><span class="hljs-comment"># 输出</span><br><span class="hljs-built_in">print</span>(max_high_risk(n, k, x, y))<br></code></pre></td></tr></table></figure><p>到这里第二题也就结束了，我当时这道题debug了好几遍，第一次是输入不对，第二次是邻接矩阵出问题，到第三次才成功AC。再次说明我的代码仅仅只能通过所有样例完成这道题，并不是最优解。</p><p>最后附上一张在食堂吃饭的时候拍到的学长，超乖的一只猫咪，就是动作有那么一丝丝不文雅。</p><p><img src="/../img/first%20blog%20cover.jpg" alt="alt text"></p>]]></content>
    
    
    <categories>
      
      <category>笔试记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔试</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
