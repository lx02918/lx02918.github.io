<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>go-study-fourth-day</title>
    <link href="/2024/08/12/go-study-fourth-day/"/>
    <url>/2024/08/12/go-study-fourth-day/</url>
    
    <content type="html"><![CDATA[<p>今儿继续学go吧。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>这个一看到第一反应就是python的，感觉go就是受到了python的影响。</p><h2 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h2><p>从定义上看和python的差不多，相同的唯一类型的一组、已编号、长度固定、可通过索引来进行修改</p><p>声明格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier [<span class="hljs-built_in">len</span>]<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>所有元素都会在建立时被自动初始化为0</p><p>在初始化、打印数组元素、处理元素时都可以用<code>for</code>循环去做，和python一样</p><p>在循环中需要注意如果写成<code>i &lt;= len(arr)</code>，会导致数组越界，因为<code>len(arr)</code>是数组的长度，而<code>i</code>是索引，所以应该写成<code>i &lt; len(arr)</code>。</p><p>循环的话可以有两种写法</p><p>第一种是<code>for i := 0; i &lt; len(arr); i++ &#123; &#125;</code>，这种写法可以保证循环的次数是数组的长度，但是不推荐这种写法，因为不够简洁。</p><p>第二种是<code>for i, v := range arr &#123; &#125;</code>，这种写法可以直接遍历数组的所有元素，<code>i</code>是索引，<code>v</code>是元素的值。</p><p>go的数组是值类型（和C&#x2F;C++不同），所以在函数中修改数组元素的值，不会影响到原数组的值。所以可以通过<code>var arr1 = new([5]int)</code>建立</p><p>那么既然go的数组是值类型，那就可以用<code>new()</code>来创建数组，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr1 = <span class="hljs-built_in">new</span>([<span class="hljs-number">5</span>]<span class="hljs-type">int</span>)<br><br><span class="hljs-keyword">var</span> arr2 [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>这两个又有什么区别呢</p><p>首先第一种是创建了一个指针数组的指针，指向了一个在堆上分配的数组，所以<code>arr1</code>是一个指针，<code>arr1[0]</code>是一个指针，<code>*arr1[0]</code>才是数组的第一个元素。</p><p>第二种是创建了一个数组，在栈上分配内存，<code>arr2</code>是一个数组，<code>arr2[0]</code>是数组的第一个元素。</p><p>从使用场景上看想在多个函数之间共享数组或需要动态分配数组大小，可以使用指针（new）。如果大小固定，且只在一个函数内使用，直接声明数组会更好</p><p>所以在想把一个数组赋给另一个数组时，需要再做一次数组内存的拷贝</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">arr2 := *arr1<br>arr2[<span class="hljs-number">2</span>] = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>这样两个数组就分别有了不同的值，且赋值后修改 arr2 对 arr1 不会影响</p><p>所以在函数中将数组传入参数时，会直接拷贝副本而非对数组本身进行操作。如果想修改原数组就需要使用<code>&amp;</code>引用来传数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(a [3]<span class="hljs-type">int</span>)</span></span> &#123; fmt.Println(a) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fp</span><span class="hljs-params">(a *[3]<span class="hljs-type">int</span>)</span></span> &#123; fmt.Println(a) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> ar [<span class="hljs-number">3</span>]<span class="hljs-type">int</span><br>f(ar) <span class="hljs-comment">// passes a copy of ar</span><br>fp(&amp;ar) <span class="hljs-comment">// passes a pointer to ar</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">[0 0 0]</span><br><span class="hljs-comment">&amp;[0 0 0]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>还有一种就是生成数组切片然后传递给函数</p><h3 id="数组常量"><a href="#数组常量" class="headerlink" title="数组常量"></a>数组常量</h3><p>如果数组的值已经提前知道了就可以用数组常量来初始化数组，而不是依次使用<code>[]=</code>来初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> arrAge = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">18</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">22</span>, <span class="hljs-number">16</span>&#125;<br><span class="hljs-keyword">var</span> arrLazy = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">22</span>&#125;<br><span class="hljs-comment">// var arrLazy = []int&#123;5, 6, 7, 8, 22&#125;</span><br><span class="hljs-keyword">var</span> arrKeyValue = [<span class="hljs-number">5</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-number">3</span>: <span class="hljs-string">&quot;Chris&quot;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&quot;Ron&quot;</span>&#125;<br><span class="hljs-comment">//var arrKeyValue = []string&#123;3: &quot;Chris&quot;, 4: &quot;Ron&quot;&#125;</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arrAge); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Age at %d is %d\n&quot;</span>, i, arrAge[i])<br>&#125;<br>fmt.Println()<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arrLazy); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Number at %d is %d\n&quot;</span>, i, arrLazy[i])<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arrKeyValue); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Person at %d is %s\n&quot;</span>, i, arrKeyValue[i])<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面的代码示例可以看出有三种办法来初始化</p><ol><li><p><code>var arrAge = [5]int&#123;18, 20, 15, 22, 16&#125;</code>这种方式是直接初始化数组，数组的长度和元素个数都必须一致。这种办法中我们可以在后续不填充和元素个数一样的，也就是我们只指定左侧开始的部分元素，后续编译器会把没有初始化的元素补0。<code>[10]int &#123;1, 2, 3&#125;</code>这样便会在后续直接补0。</p></li><li><p><code>var arrLazy = [...]int&#123;5, 6, 7, 8, 22&#125;</code>这种方式是使用<code>...</code>语法来声明数组，省略了数组的长度，go会根据元素个数来推断数组的长度。忽略后从技术上来看就变成了切片。</p></li><li><p><code>var arrKeyValue = [5]string&#123;3: &quot;Chris&quot;, 4: &quot;Ron&quot;&#125;</code>这种方式是使用索引来初始化数组，索引必须小于数组的长度，否则会报错。这里的数组长度同样可以写成<code>...</code></p></li></ol><p>同样我们可以取任意数组常量的地址来作为新实例的指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fp</span><span class="hljs-params">(a *[3]<span class="hljs-type">int</span>)</span></span> &#123; fmt.Println(a) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>fp(&amp;[<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;i, i * i, i * i * i&#125;)<br>&#125;<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">&amp;[0 0 0]</span><br><span class="hljs-comment">&amp;[1 1 1]</span><br><span class="hljs-comment">&amp;[2 4 8]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>本质上和python差不多，就是写法上不一样，给个例子就行了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">const</span> (<br>WIDTH  = <span class="hljs-number">1920</span><br>HEIGHT = <span class="hljs-number">1080</span><br>)<br><br><span class="hljs-keyword">type</span> pixel <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> screen [WIDTH][HEIGHT]pixel<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> y := <span class="hljs-number">0</span>; y &lt; HEIGHT; y++ &#123;<br><span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; WIDTH; x++ &#123;<br>screen[x][y] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="将数组传给函数"><a href="#将数组传给函数" class="headerlink" title="将数组传给函数"></a>将数组传给函数</h3><p>将数组传递给函数时如果数组较大将消耗很多内存，这时有两种方法可以解决</p><ul><li>传递数组的指针</li><li>传递数组的切片<br>例子中是第一种方法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>array := [<span class="hljs-number">3</span>]<span class="hljs-type">float64</span>&#123;<span class="hljs-number">7.0</span>, <span class="hljs-number">8.5</span>, <span class="hljs-number">9.1</span>&#125;<br>x := Sum(&amp;array) <span class="hljs-comment">// Note the explicit address-of operator</span><br><span class="hljs-comment">// to pass a pointer to the array</span><br>fmt.Printf(<span class="hljs-string">&quot;The sum of the array is: %f&quot;</span>, x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span><span class="hljs-params">(a *[3]<span class="hljs-type">float64</span>)</span></span> (sum <span class="hljs-type">float64</span>) &#123;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> a &#123; <span class="hljs-comment">// derefencing *a to get back to the array is not necessary!</span><br>sum += v<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片（slice）是对数组的一组连续片段的引用（该数组为匿名数组，也是相关数组），从名字上看类似于python的切片，但实际上和python的list类似而不是切片。</p><p>该片段可能是整个数组，也可能是有起始和终止索引所构成的子集片段。但索引并不包含在整个子集中。</p><p>切片还提供了相关数组的动态窗口（可以拿来做滑动窗口和DP好像，确信）</p><p>由于切片是自带索引的，所以<code>len()</code>, <code>cap()</code>, <code>append()</code>等操作都可以直接使用。</p><p>这里需要说的是<code>cap()</code>，该函数可以测量切片的计算容量最大可以为多少，等于切片的长度 + 数组切片之外的长度。</p><p>举个例子如果有一个切片<code>s</code>，<code>cap(s)</code>就是从索引0到<code>len(s)</code>的元素个数，而<code>len(s)</code>是切片的长度。切片的长度不会超过它的容量，也即<code>0&lt;=s&lt;=cap(s)</code>。</p><p>由于切片是带有索引机制，结合python带索引的东西都是可变的我们可以推理出，切片也可能是可变的。而事实证明切片是可变的，并且是在运行过程中可以改变大小，最小为0，最大为整个数组大小。</p><p>如果多个切片引用同一个数组，则他们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。</p><p>切片的优点是引用，由于不需要额外的内存且比直接使用数组更加高效，所以go中更多的使用切片。</p><h2 id="声明和初始化-1"><a href="#声明和初始化-1" class="headerlink" title="声明和初始化"></a>声明和初始化</h2><p>声明格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier []<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>这里不需要说明长度，切片在未初始化前长度默认为nil，长度为0</p><p>初始化格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> slice1 []<span class="hljs-keyword">type</span> = arr1[start:end]<br></code></pre></td></tr></table></figure><p>这里表示 <code>slice1</code> 是由数组 <code>arr1</code> 从 <code>start</code> 索引到 <code>end-1</code> 索引的切片，包括 <code>start</code> ，不包括 <code>end</code> 。</p><p>如果写<code>var slice []type = arr[:]</code>，则表示 <code>slice</code> 是 <code>arr</code> 的一个切片，等价于 <code>slice = arr[0:len(arr)]</code>。</p><p>arr[2:]表示从索引2开始到数组末尾的切片，arr[:3]表示从数组开头到索引3-1的切片。</p><p>如果想去掉最后一个元素，则为<code>slice = arr[:len(arr)-1]</code>。</p><p>一个由数字 1、2、3 组成的切片可以这么生成：s :&#x3D; [3]int{1,2,3}[:]（注：应先用 s :&#x3D; [3]int{1, 2, 3} 生成数组, 再使用 s[:] 转成切片）甚至更简单的 s :&#x3D; []int{1,2,3}。</p><p>s2 :&#x3D; s[:] 是用切片组成的切片，拥有相同的元素，但是仍然指向相同的相关数组。</p><p>由于前面提到切片的上限是 <code>cap(s)</code> 所以如果继续扩展将会报错。</p><p>对每个切片下面的情况是成立的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s == s[:i] + s[i:] <span class="hljs-comment">// i是一个整数且: 0 &lt;= i &lt;= len(s)</span><br><span class="hljs-built_in">len</span>(s) &lt;= <span class="hljs-built_in">cap</span>(s)<br></code></pre></td></tr></table></figure><p>在前面说数组时提到我们可以不指定长度使用<code>...</code>来表明他长度不固定，让编译器自己去识别。那我们忽略掉<code>...</code>就可以得到切片的初始化了。<code>var x = []int&#123;1,2,3&#125;</code>。这样就创建了一个长度为5的数字同时创建了一个相关切片。</p><p>切片在内存中实际上是一个有三个域的结构体——指向相关数组的指针、切片长度、切片容量。</p><figure>  <img src="/2024/08/12/go-study-fourth-day/7_2_1.png" class="" title="7.2 Silence in Memory">  <figcaption>7.2 Silence in Memory</figcaption></figure><p>从图中看到，<code>y[0] = 3</code>且<code>y[1] = 5</code>。切片y[0:4] &#x3D; [3, 5, 7, 11]。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">6</span>]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> slice1 []<span class="hljs-type">int</span> = arr1[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>] <span class="hljs-comment">// index 5 niet meegerekend!</span><br><br><span class="hljs-comment">// load the array with integers: 0,1,2,3,4,5</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr1); i++ &#123;<br>arr1[i] = i<br>&#125;<br><br><span class="hljs-comment">// print the slice:</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice1); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Slice at %d is %d\n&quot;</span>, i, slice1[i])<br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;The length of arr1 is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(arr1))<br>fmt.Printf(<span class="hljs-string">&quot;The length of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1))<br>fmt.Printf(<span class="hljs-string">&quot;The capacity of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">cap</span>(slice1))<br><br><span class="hljs-comment">// grow the slice:</span><br>slice1 = slice1[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice1); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Slice at %d is %d\n&quot;</span>, i, slice1[i])<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;The length of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1))<br>fmt.Printf(<span class="hljs-string">&quot;The capacity of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">cap</span>(slice1))<br><br><span class="hljs-comment">// grow the slice beyond capacity:</span><br><span class="hljs-comment">// slice1 = slice1[0:7 ] // panic: runtime error: slice bounds out of range</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">Slice at 0 is 2</span><br><span class="hljs-comment">Slice at 1 is 3</span><br><span class="hljs-comment">Slice at 2 is 4</span><br><span class="hljs-comment">Slice at 3 is 5</span><br><span class="hljs-comment">The length of arr1 is 6</span><br><span class="hljs-comment">The length of slice1 is 4</span><br><span class="hljs-comment">The capacity of slice1 is 6</span><br><span class="hljs-comment">Slice at 0 is 2</span><br><span class="hljs-comment">Slice at 1 is 3</span><br><span class="hljs-comment">Slice at 2 is 4</span><br><span class="hljs-comment">Slice at 3 is 5</span><br><span class="hljs-comment">The length of slice1 is 4</span><br><span class="hljs-comment">The capacity of slice1 is 6</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>如果<code>s2</code>是一个切片，我们可以使用<code>s2[1:]</code>来表示将切片向后移一位，而结尾没有后移。而我们使用<code>s2[-1:]</code>就会报错，因为切片不能被重新分片以获得数组的前一个元素。</p><p>由于切片本身就是引用，所以绝不可以再使用一个指针去引用索引。</p><h2 id="将切片传递给函数"><a href="#将切片传递给函数" class="headerlink" title="将切片传递给函数"></a>将切片传递给函数</h2><p>如果一个函数需要调用数组，则我们可以创建一个切片并引用传递函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>s := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(a); i++ &#123;<br>s += a[i]<br>&#125;<br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>sum(arr[:])<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用make-创建一个切片"><a href="#用make-创建一个切片" class="headerlink" title="用make()创建一个切片"></a>用make()创建一个切片</h2><p>当相关数组还没被定义时可以使用<code>make()</code>来创建一个切片，同时创建好相关数组<code>var slice1 []type = make([]type, len)</code>。也可以简写为<code>slice1 := make([]type, len)</code>，这里的<code>len</code>表示切片的长度也是<code>slice</code>的初始长度。</p><p>举个例子<code>s2 := make([]int, 5)</code>表示创建一个长度为5的切片，初始值都是0。那么<code>cap(s2) == len(s2) == 5</code>。</p><p><code>make()</code>可以接受两个参数，元素类型和切片的元素个数。</p><p>如果创建一个<code>slice1</code>且不想占用整个数组，而是占用以<code>len</code>为个数，那么只要<code>slice1 = make([]type, len, cap)</code>就可以了。</p><p><code>make()</code>的使用方法是<code>func make([]T, len, cap)</code>，其中<code>len</code>表示切片的长度，<code>cap</code>表示切片的容量。<code>cap</code>为可选。</p><p>下面两种方法可以创建相同的切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>)<br><span class="hljs-built_in">new</span>([<span class="hljs-number">100</span>]<span class="hljs-type">int</span>)[<span class="hljs-number">0</span>:<span class="hljs-number">50</span>]<br></code></pre></td></tr></table></figure><figure>  <img src="/2024/08/12/go-study-fourth-day/7_2_2.png" class="" title="使用make()生成切片的内存结构">  <figcaption>使用make()生成切片的内存结构</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> slice1 []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><span class="hljs-comment">// load the array/slice:</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice1); i++ &#123;<br>slice1[i] = <span class="hljs-number">5</span> * i<br>&#125;<br><br><span class="hljs-comment">// print the slice:</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice1); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Slice at %d is %d\n&quot;</span>, i, slice1[i])<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\nThe length of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">len</span>(slice1))<br>fmt.Printf(<span class="hljs-string">&quot;The capacity of slice1 is %d\n&quot;</span>, <span class="hljs-built_in">cap</span>(slice1))<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">Slice at 0 is 0  </span><br><span class="hljs-comment">Slice at 1 is 5  </span><br><span class="hljs-comment">Slice at 2 is 10  </span><br><span class="hljs-comment">Slice at 3 is 15  </span><br><span class="hljs-comment">Slice at 4 is 20  </span><br><span class="hljs-comment">Slice at 5 is 25  </span><br><span class="hljs-comment">Slice at 6 is 30  </span><br><span class="hljs-comment">Slice at 7 is 35  </span><br><span class="hljs-comment">Slice at 8 is 40  </span><br><span class="hljs-comment">Slice at 9 is 45  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">The length of slice1 is 10  </span><br><span class="hljs-comment">The capacity of slice1 is 10  </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="new-和make-的区别"><a href="#new-和make-的区别" class="headerlink" title="new()和make()的区别"></a>new()和make()的区别</h2><p><code>make()</code>是用来创建数组的，<code>new()</code>是用来创建指针的。</p><p><code>new(T)</code>为每个新的类型<code>T</code>分配一片内存，初始化为<code>0</code>并返回类型为<code>*T</code>的内存地址。所以这种方法返回的是 <strong>一个指向类型为<code>T</code>值为<code>0</code>的地址的指针</strong> ，适用于值类型如数组和结构体。</p><p><code>make(T)</code> <strong>返回一个类型为<code>T</code>的初始值</strong> ，适用于三种类型，切片、<code>map</code>、<code>channel</code>。</p><p>也就是说<code>new()</code>用来分配内存，<code>make()</code>用来初始化。</p><p>总结一下就是，由于<code>slice</code>、<code>map</code>、<code>channel</code>都是引用类型，三者都存在对于内存中存在多个组成部分，需要对内存进行初始化后才可以使用，这里就需要<code>make()</code>。而<code>new()</code>是直接获取一个地址，不进行初始化。所以需要使用<code>make()</code>来初始化并获取地址，而非简单使用<code>new()</code>获取地址。</p><figure>  <img src="/2024/08/12/go-study-fourth-day/7_2_3.png" class="" title="new()和make()的不同">  <figcaption>new()和make()的不同</figcaption></figure><p>第一幅图</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p *[]<span class="hljs-type">int</span> = <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>) <span class="hljs-comment">// *p == nil; with len and cap 0</span><br>p := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p>第二幅图</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">p := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>在第二幅图中，实际上切片已经被初始化，但指向了一个空指针。</p><p>上面方法实际上并不实用，更常见的是以下两种</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>)<br><br>或<br><br>v := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><p>这样分配了有50个<code>int</code>值的数组，并且创建了一个长度为10，容量为50的切片<code>v</code>，该切片指向了前10个元素。</p><h2 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h2><p>多维切片和多维数组类似，也是可以由多个一维切片组成，且长度可变。这里也需要用到<code>make()</code>对内层切片进行单独分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个 2x3 的二维切片</span><br>    matrix := [][]<span class="hljs-type">int</span>&#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>        &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;,<br>    &#125;<br><br>    <span class="hljs-comment">// 打印二维切片</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[i]); j++ &#123;<br>            fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, matrix[i][j])<br>        &#125;<br>        fmt.Println() <span class="hljs-comment">// 换行</span><br>    &#125;<br><br>    <span class="hljs-comment">// 修改某个元素</span><br>    matrix[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">10</span> <span class="hljs-comment">// 将第二行第三列的值改为 10</span><br><br>    <span class="hljs-comment">// 再次打印二维切片</span><br>    fmt.Println(<span class="hljs-string">&quot;修改后的二维切片:&quot;</span>)<br>    <span class="hljs-keyword">for</span> _, row := <span class="hljs-keyword">range</span> matrix &#123;<br>        fmt.Println(row)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里发现go和python通过循环对多维数组进行操作有点类似，下面进行对比</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[i]); j++ &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, matrix[i][j])<br>    &#125;<br>    fmt.Println()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON">matrix = [<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>    [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[i])):<br>        <span class="hljs-built_in">print</span>(matrix[i][j], end=<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——链表</title>
    <link href="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141 环形链表"></a>141 环形链表</h1><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：<code>pos</code> <strong>不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。<br>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/141.1.png" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/141.2.png" class="" title="示例2">  <figcaption>示例2</figcaption></figure><pre><code class="hljs">输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p>示例 3：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/141.3.png" class="" title="示例3">  <figcaption>示例3</figcaption></figure><pre><code class="hljs">输入：head = [1], pos = -1输出：false解释：链表中没有环。</code></pre><p>提示：</p><p>链表中节点的数目范围是 <code>[0, 104]</code><br><code>-105 &lt;= Node.val &lt;= 105</code><br><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>环形链表顾名思义就是链表中存在一个环，当节点遍历到能够连接到环的位置能够回到前面。</p><p>所以我们可以用快慢指针，快指针一次走两步慢指针一次走一步，只要这两个能够相遇则为有环，如果不能就表示无环。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        slow = fast = head<br>        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span>:<br>            slow = slow.<span class="hljs-built_in">next</span><br>            fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> slow == fast:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间76ms，消耗内存18.8MB</p><p>这里提交后发现这个的执行时间还是太慢了，所以我们对这个进行优化。</p><h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>既然我们用两个指针会导致整个代码的速度变慢，把我们就只用一个指针，用一个集合去记录已经走过的位置，只要能够回来就表示这里有环，如果不能就表示无环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        visited = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">while</span> head:<br>            <span class="hljs-keyword">if</span> head <span class="hljs-keyword">in</span> visited:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            visited.add(head)<br>            head = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间46ms，消耗内存19.1MB</p><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2 两数相加"></a>2 两数相加</h1><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/2.1.png" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.</code></pre><p>示例 2：</p><pre><code class="hljs">输入：l1 = [0], l2 = [0]输出：[0]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1]</code></pre><p>提示：</p><p>每个链表中的节点数在范围 <code>[1, 100]</code> 内</p><p><code>0 &lt;= Node.val &lt;= 9</code></p><p>题目数据保证列表表示的数字不含前导零</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这里需要提前知道题目没给的条件，这个是在实例中有体现，我们遇到加和为两位数后，我们需要进位，所以我们需要一个进位的变量。</p><p>这里我们需要用到一个divmod函数来解决这个问题，函数输入为两个数，返回值为一个元组，第一个元素为商，第二个元素为余数。</p><p>其余的就是取数、加和、下一个的问题了</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        curr = dummy<br>        carry = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2 <span class="hljs-keyword">or</span> carry:<br>            val1 = val2 = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> l1:<br>                val1 = l1.val<br>                l1 = l1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> l2:<br>                val2 = l2.val<br>                l2 = l2.<span class="hljs-built_in">next</span><br>            carry, val = <span class="hljs-built_in">divmod</span>(val1 + val2 + carry, <span class="hljs-number">10</span>)<br>            curr.<span class="hljs-built_in">next</span> = ListNode(val)<br>            curr = curr.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间61ms，消耗内存16.4MB</p><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21 合并两个有序链表"></a>21 合并两个有序链表</h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/21.1.jpg" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：l1 = [], l2 = []输出：[]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：l1 = [], l2 = [0]输出：[0]</code></pre><p>提示：</p><p>两个链表的节点数目范围是 <code>[0, 50]</code></p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><p>l1 和 l2 均按 <strong>非递减顺序</strong> 排列</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这里我们就还是设置两个节点，均为头结点的前一位，然后设置一个辅助节点，用来存储合并后的链表。</p><p>然后我们比较两个链表的头结点，谁小就把谁的头结点放到辅助节点的后面，然后把这个节点的指针指向下一个节点，然后继续比较，直到两个链表都为空。</p><p>最后把辅助节点的下一个节点作为合并后的链表的头结点。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        curr = dummy<br>        <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:<br>            <span class="hljs-keyword">if</span> list1.val &lt; list2.val:<br>                curr.<span class="hljs-built_in">next</span> = list1<br>                list1 = list1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                curr.<span class="hljs-built_in">next</span> = list2<br>                list2 = list2.<span class="hljs-built_in">next</span><br>            curr = curr.<span class="hljs-built_in">next</span><br>        curr.<span class="hljs-built_in">next</span> = list1 <span class="hljs-keyword">or</span> list2<br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间40ms，消耗内存16.4MB</p><h1 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138 随机链表的复制"></a>138 随机链表的复制</h1><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 <a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a>。 深拷贝应该正好由 <code>n</code> 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p><p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p><p>返回复制链表的头节点。</p><p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p><p><code>val</code>：一个表示 <code>Node.val</code> 的整数。<br><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为  <code>null</code> 。<br>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p><p>示例 1：<br><img src="/../img/138_1.png" alt="示例1"></p><pre><code class="hljs">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</code></pre><p>示例 2：<br><img src="/../img/138_2.png" alt="示例2"></p><pre><code class="hljs">输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]]</code></pre><p>示例 3：<br><img src="/../img/138_3.png" alt="示例3"></p><pre><code class="hljs">输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]]</code></pre><p>提示：</p><p><code>0 &lt;= n &lt;= 1000</code></p><p><code>-104 &lt;= Node.val &lt;= 104</code></p><p><code>Node.random</code> 为 <code>null</code> 或指向链表中的节点。</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这里我们可以借助字典来实现。</p><p>首先明确一点，我们可以采用两次循环来完成，一次获取val，一次获取next和random</p><p>最后直接返回第一个节点即可。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">copyRandomList</span>(<span class="hljs-params">self, head: <span class="hljs-string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="hljs-string">&#x27;Optional[Node]&#x27;</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        curr = head<br>        dic = &#123;&#125;<br>        <span class="hljs-keyword">while</span> curr:<br>            dic[curr] = Node(curr.val)<br>            curr = curr.<span class="hljs-built_in">next</span><br>            <br>        curr = head<br>        <span class="hljs-keyword">while</span> curr:<br>            dic[curr].<span class="hljs-built_in">next</span> = dic.get(curr.<span class="hljs-built_in">next</span>)<br>            dic[curr].random = dic.get(curr.random)<br>            curr = curr.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dic.get(head)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间48ms，消耗内存17.2MB</p><h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92 反转链表 II"></a>92 反转链表 II</h1><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 反转后的链表 。</p><p>示例 1：</p><pre><code class="hljs">输入：head = [1,2,3,4,5], left = 2, right = 4输出：[1,4,3,2,5]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：head = [5], left = 1, right = 1输出：[5]</code></pre><p>提示：</p><p>链表中节点数目为 <code>n</code></p><p><code>1 &lt;= n &lt;= 500</code></p><p><code>-500 &lt;= Node.val &lt;= 500</code></p><p><code>1 &lt;= left &lt;= right &lt;= n</code></p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>首先需要知道一点，我们在设置头结点前面一个虚拟节点的时候，需要用一个类似pre的字符去表示，直接使用头结点<code>dummy</code>会导致后续出现异常导致无法完全测试。</p><p>然后反转部分我的思路是直接原地操作，不进行拆开后后续拼接，所以时间复杂度上会相对来说高一些。之前反转链表中使用过拆开后拼接，这种情况下时间复杂度会降低，但是也会由于思路的混乱导致最后测试失败。</p><p>这里需要注意的另外一点是，我们这里只使用两个节点进行直接操作。刚开始我也使用了添加一个tail进行操作，但是会导致后续反转逻辑写起来比较复杂。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseBetween</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        dummy.<span class="hljs-built_in">next</span> = head<br>        pre = dummy<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m - <span class="hljs-number">1</span>):<br>            pre = pre.<span class="hljs-built_in">next</span><br>        start = pre.<span class="hljs-built_in">next</span><br>        then = start.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - m):<br>            start.<span class="hljs-built_in">next</span> = then.<span class="hljs-built_in">next</span><br>            then.<span class="hljs-built_in">next</span> = pre.<span class="hljs-built_in">next</span><br>            pre.<span class="hljs-built_in">next</span> = then<br>            then = start.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span> <br></code></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间46ms，消耗内存16.3MB</p><h1 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25 K 个一组翻转链表"></a>25 K 个一组翻转链表</h1><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/25_1.jpg" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：head = [1,2,3,4,5], k = 2输出：[2,1,4,3,5]</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/25_2.jpg" class="" title="示例2">  <figcaption>示例2</figcaption></figure><pre><code class="hljs">输入：head = [1,2,3,4,5], k = 3输出：[3,2,1,4,5]</code></pre><p>提示：</p><p>链表中的节点数目为 <code>n</code></p><p><code>1 &lt;= k &lt;= n &lt;= 5000</code></p><p><code>0 &lt;= Node.val &lt;= 1000</code></p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>这里其实反转思路和前一道题一模一样。</p><p>需要注意的是我这里没用一个额外的数去累加计数，而是将整个需要反转的进行递归。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseKGroup</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        a = b = head<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> b:<br>                <span class="hljs-keyword">return</span> head<br>            b = b.<span class="hljs-built_in">next</span>  <br>        newHead = <span class="hljs-variable language_">self</span>.reverse(a, b)<br>        a.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.reverseKGroup(b, k)<br>        <span class="hljs-keyword">return</span> newHead<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">self, a, b</span>):<br>        prev = <span class="hljs-literal">None</span><br>        curr = a<br>        <span class="hljs-keyword">while</span> curr != b:<br>            <span class="hljs-built_in">next</span> = curr.<span class="hljs-built_in">next</span><br>            curr.<span class="hljs-built_in">next</span> = prev<br>            prev = curr<br>            curr = <span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> prev<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间37ms，消耗内存17.1MB</p><h1 id="19-删除链表的倒数第-N-个节点"><a href="#19-删除链表的倒数第-N-个节点" class="headerlink" title="19 删除链表的倒数第 N 个节点"></a>19 删除链表的倒数第 N 个节点</h1><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p>示例 1：</p><pre><code class="hljs">输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：head = [1], n = 1输出：[]</code></pre><p>示例 3：</p><pre><code class="hljs">输入：head = [1,2], n = 1输出：[1]</code></pre><p>提示：</p><p>链表中结点的数目为 <code>sz</code></p><p><code>1 &lt;= sz &lt;= 30</code></p><p><code>0 &lt;= Node.val &lt;= 100</code></p><p><code>1 &lt;= n &lt;= sz</code></p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>首先按照数组字符串的思路直接倒序遍历找到节点删除就可以，但链表是不能进行倒序遍历和直接获取长度的。所以我们就需要自己去通过循环得到相关的内容。</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        dummy.<span class="hljs-built_in">next</span> = head<br>        cur, length = head, <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 获取长度</span><br>        <span class="hljs-keyword">while</span> cur:<br>            length += <span class="hljs-number">1</span><br>            cur = cur.<span class="hljs-built_in">next</span><br>        cur = dummy<br>        <span class="hljs-comment"># 找到倒数第 n 个节点</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length - n):<br>            cur = cur.<span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 删除节点</span><br>        cur.<span class="hljs-built_in">next</span> = cur.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间39ms，消耗内存16.3MB</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>这里我用了快慢指针去，思路上都差不多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> n &lt;= <span class="hljs-number">0</span>:  <span class="hljs-comment"># 增加对n的合理性检查</span><br>            <span class="hljs-keyword">return</span> head<br>        <br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        dummy.<span class="hljs-built_in">next</span> = head<br>        first = second = dummy<br>        <br>        <span class="hljs-comment"># 先将first指针移动n+1步</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> first:  <span class="hljs-comment"># 如果n大于链表长度，直接返回</span><br>                <span class="hljs-keyword">return</span> head<br>            first = first.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-comment"># 同时移动first和second指针，直到first到达链表末尾</span><br>        <span class="hljs-keyword">while</span> first:<br>            first = first.<span class="hljs-built_in">next</span><br>            second = second.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-comment"># 删除节点</span><br>        second.<span class="hljs-built_in">next</span> = second.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h1 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82 删除排序链表中的重复元素 II"></a>82 删除排序链表中的重复元素 II</h1><p>给定一个已排序的链表的头 <code>head</code> ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p><p>示例 1：</p><pre><code class="hljs">输入：head = [1,2,3,3,4,4,5]输出：[1,2,5]</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/82_2.jpg" class="" title="示例2">  <figcaption>示例2</figcaption></figure>    输入：head = [1,1,1,2,3]    输出：[2,3] <p>提示：</p><p>链表中节点数目在范围 <code>[0, 300]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><p>题目数据保证链表已经按升序 <strong>排列</strong></p><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>这里首先要注意一点也是我之前做了好几次一直过不去的原因。当我们发现两个节点值相同时，应该用一个变量去存储值，而不是直接进行后续的循环操作，直接进行操作将一直持续不断的遍历两个节点而非继续往后走。</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteDuplicates</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        dummy = ListNode(<span class="hljs-number">0</span>)<br>        dummy.<span class="hljs-built_in">next</span> = head<br>        curr = dummy<br>        <span class="hljs-keyword">while</span> curr.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> curr.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>:<br>            <span class="hljs-keyword">if</span> curr.<span class="hljs-built_in">next</span>.val == curr.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span>.val:<br>                duplicate_val = curr.<span class="hljs-built_in">next</span>.val<br>                <span class="hljs-keyword">while</span> curr.<span class="hljs-built_in">next</span> <span class="hljs-keyword">and</span> curr.<span class="hljs-built_in">next</span>.val == duplicate_val:<br>                    curr.<span class="hljs-built_in">next</span> = curr.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                curr = curr.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间45ms，消耗内存16.3MB</p><h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61 旋转链表"></a>61 旋转链表</h1><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 k 个位置。</p><p>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/61_1.jpg" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：head = [1,2,3,4,5], k = 2输出：[4,5,1,2,3]</code></pre><p>示例 2：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/61_2.jpg" class="" title="示例2">  <figcaption>示例2</figcaption></figure><pre><code class="hljs">输入：head = [0,1,2], k = 4输出：[2,0,1]</code></pre><p>提示：</p><p>链表中节点的数目在范围 <code>[0, 500]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><p><code>0 &lt;= k &lt;= 2 * 109</code></p><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>首先知道我们每个节点往前移k个就相当于倒数第k个节点之后的节点移到头结点前。</p><p>其次我们计算长度后，我们对k进行操作，k就相当于k对长度取余，因为k大于长度时我们进行后续操作就相当于走了一圈又继续走。</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotateRight</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        curr = head<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> curr:<br>            count += <span class="hljs-number">1</span><br>            curr = curr.<span class="hljs-built_in">next</span><br>        k = k % count<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> head<br>        fast = slow = head<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            fast = fast.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> fast.<span class="hljs-built_in">next</span>:<br>            slow = slow.<span class="hljs-built_in">next</span><br>            fast = fast.<span class="hljs-built_in">next</span><br>        new_head = slow.<span class="hljs-built_in">next</span><br>        slow.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        fast.<span class="hljs-built_in">next</span> = head<br>        <span class="hljs-keyword">return</span> new_head<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-9"><a href="#时间复杂度-9" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间40ms，消耗内存16.4MB</p><h1 id="86-分割链表"><a href="#86-分割链表" class="headerlink" title="86 分割链表"></a>86 分割链表</h1><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p><p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p><p>示例 1：</p><figure>  <img src="/2024/08/09/leetcode-%E9%93%BE%E8%A1%A8/86_1.jpg" class="" title="示例1">  <figcaption>示例1</figcaption></figure><pre><code class="hljs">输入：head = [1,4,3,2,5,2], x = 3输出：[1,2,2,4,3,5]</code></pre><p>示例 2：</p><pre><code class="hljs">输入：head = [2,1], x = 2输出：[1,2]</code></pre><p>提示：</p><p>链表中节点的数目在范围 <code>[0, 200]</code> 内</p><p><code>-100 &lt;= Node.val &lt;= 100</code></p><p><code>-200 &lt;= x &lt;= 200</code></p><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>看到题目第一反应是二分法，大于k的在右边，小于的在左边。</p><p>然后我们就可以用相似的思路去做。我们建立两个表用来存储大于和小于的节点，其次我们在遍历后直接将两个表一拼接就直接完成了。</p><p>切记我们需要在最后将大于的那个表的尾节点指向None，不然就会形成环。</p><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        smaller = ListNode(<span class="hljs-number">0</span>)<br>        bigger = ListNode(<span class="hljs-number">0</span>)<br>        small, big = smaller, bigger<br>        <span class="hljs-keyword">while</span> head:<br>            <span class="hljs-keyword">if</span> head.val &lt; x:<br>                small.<span class="hljs-built_in">next</span> = head<br>                small = small.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                big.<span class="hljs-built_in">next</span> = head<br>                big = big.<span class="hljs-built_in">next</span>  <br>            head = head.<span class="hljs-built_in">next</span><br>        small.<span class="hljs-built_in">next</span> = bigger.<span class="hljs-built_in">next</span><br>        big.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> smaller.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-10"><a href="#时间复杂度-10" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间38ms，消耗内存16.3MB</p><h1 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146 LRU 缓存"></a>146 LRU 缓存</h1><p>请你设计并实现一个满足  <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。<br>实现 <code>LRUCache</code> 类：<br><code>LRUCache(int capacity)</code> 以 正整数 作为容量 <code>capacity</code> 初始化 LRU 缓存<br><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。<br><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 逐出 最久未使用的关键字。<br>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p>示例：</p><pre><code class="hljs">输入[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;lRUCache.get(1);    // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;lRUCache.get(2);    // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;lRUCache.get(1);    // 返回 -1 (未找到)lRUCache.get(3);    // 返回 3lRUCache.get(4);    // 返回 4</code></pre><p>提示：</p><p><code>1 &lt;= capacity &lt;= 3000</code></p><p><code>0 &lt;= key &lt;= 10000</code></p><p><code>0 &lt;= value &lt;= 105</code></p><p>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></p><h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>这道题有那么亿点点绕，所以思路上写的比较详细</p><p>首先我们需要完成两个操作</p><ul><li><code>get(key)</code>: 如果key存在于缓存中，则返回对应的值，否则返回-1。</li><li><code>put(key, value)</code>: 将key-value对插入缓存中。如果key已经存在，更新其值；如果key不存在并且缓存已满，则移除最近最少使用的项。</li></ul><p>然后我们来说明如何实现</p><ol><li>初始化：构建一个空哈希表和一个带有哨兵头尾节点的双向链表</li><li><code>get(key)</code>：<ul><li>如果不存在，直接返回-1</li><li>如果存在，找到对应节点，将其从链表中移除并添加到链表末尾，以表示它是最近使用的元素</li></ul></li><li><code>put(key, value)</code>：<ul><li>如果key已经在缓存中，更新其值，并将该节点移动到链表的末尾。</li><li>如果key不存在，创建一个新节点并插入到链表末尾。</li><li>如果插入后缓存超出了容量，移除链表头部的节点（即最近最少使用的节点），并从哈希表中删除对应的键。</li></ul></li><li>操作解释<ul><li><code>_add</code>：将节点添加到双向链表的末尾，这表示该节点是最新被访问的。</li><li><code>_remove</code>：将节点从双向链表中删除，这个操作主要用于在<code>get</code>或<code>put</code>操作时调整节点的位置，以及在缓存容量超出限制时移除最老的节点。</li></ul></li></ol><h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CreatNode</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key = <span class="hljs-number">0</span>, value = <span class="hljs-number">0</span></span>):<br>        <span class="hljs-variable language_">self</span>.key = key<br>        <span class="hljs-variable language_">self</span>.value = value<br>        <span class="hljs-variable language_">self</span>.prev = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span> = &#123;&#125;<br>        <span class="hljs-variable language_">self</span>.head = CreatNode()<br>        <span class="hljs-variable language_">self</span>.tail = CreatNode()<br>        <span class="hljs-variable language_">self</span>.head.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.tail<br>        <span class="hljs-variable language_">self</span>.tail.prev = <span class="hljs-variable language_">self</span>.head<br>        <span class="hljs-variable language_">self</span>.capacity = capacity<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        node = <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>[key]<br>        <span class="hljs-variable language_">self</span>._remove(node)<br>        <span class="hljs-variable language_">self</span>._add(node)<br>        <span class="hljs-keyword">return</span> node.value<br>    <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span>, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>:<br>            node = <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>[key]<br>            node.value = value<br>            <span class="hljs-variable language_">self</span>._remove(node)<br>            <span class="hljs-variable language_">self</span>._add(node)<br>        <span class="hljs-keyword">else</span>:<br>            node = CreatNode(key, value)<br>            <span class="hljs-variable language_">self</span>._add(node)<br>            <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>[key] = node<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>) &gt; <span class="hljs-variable language_">self</span>.capacity:<br>                <span class="hljs-keyword">del</span> <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">hash</span>[<span class="hljs-variable language_">self</span>.head.<span class="hljs-built_in">next</span>.key]<br>                <span class="hljs-variable language_">self</span>._remove(<span class="hljs-variable language_">self</span>.head.<span class="hljs-built_in">next</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_remove</span>(<span class="hljs-params">self, node</span>):<br>        prev = node.prev<br>        <span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span><br>        prev.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>        <span class="hljs-built_in">next</span>.prev = prev<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_add</span>(<span class="hljs-params">self, node</span>):<br>        prev = <span class="hljs-variable language_">self</span>.tail.prev<br>        prev.<span class="hljs-built_in">next</span> = node<br>        node.prev = prev<br>        node.<span class="hljs-built_in">next</span> = <span class="hljs-variable language_">self</span>.tail<br>        <span class="hljs-variable language_">self</span>.tail.prev = node<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-11"><a href="#时间复杂度-11" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(1)，执行时间457ms，消耗内存75.6MB</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>区间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go学习记录——第三天</title>
    <link href="/2024/08/09/go-study-third-day/"/>
    <url>/2024/08/09/go-study-third-day/</url>
    
    <content type="html"><![CDATA[<p>今天也继续学习go吧。今天找了下《The Way to Go》这本书的中译本，书作者是Ivo Balbaert。也非常感谢翻译者们的努力，在这里贴上链接<a href="https://github.com/unknwon/the-way-to-go_ZH_CN.git">The Way to Go</a>，也希望大家能支持下翻译者们，给项目加个小星星。</p><p>根据对比，这个讲的比较完整，咱就准备根据这个进行学习，后续也会找一些其他资料来学习。早知道就直接在GitHub上找资料来学习了🤣，事实证明GitHub才是好东西。</p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>go的指针不同于C的指针，go的指针不能进行算术运算，但是可以通过指针控制特定集合的数据结构、分配的数量及内存的访问模式。</p><p>go的取地址符号是<code>&amp;</code>，放在变量前即可获得该变量的地址。</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i1 = <span class="hljs-number">5</span><br>fmt.Printf(<span class="hljs-string">&quot;An integer: %d, its location in memory: %p\n&quot;</span>, i1, &amp;i1)<br><br><span class="hljs-keyword">var</span> intP *<span class="hljs-type">int</span><br>intP = &amp;i1<br>fmt.Printf(<span class="hljs-string">&quot;The value at memory location %p is %d\n&quot;</span>, intP, *intP)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的第一个输出的便是i1的地址</p><p>而在第二个输出中，定义了一个指向int的指针，用*i表示，然后我们用intP就可以调用。而后intP的值为i1的地址，所以输出的结果为5且地址为原始i1的地址。</p><p>指针格式化标识符为<code>%p</code>。（关于这个后续写个表格都列一下，好像还蛮多的）</p><p>然后捋一下第二个输出，intP -&gt; &amp;i1，所以引用了i1。没有指向任何东西的时候指针的默认值为nil，通常来说指针缩写是<code>prt</code></p><p>再来另外一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-string">&quot;good bye&quot;</span><br><span class="hljs-keyword">var</span> p *<span class="hljs-type">string</span> = &amp;s<br>*p = <span class="hljs-string">&quot;ciao&quot;</span><br><br>fmt.Printf(<span class="hljs-string">&quot;Here is the pointer p: %p\n&quot;</span>, p)  <span class="hljs-comment">// prints address</span><br>fmt.Printf(<span class="hljs-string">&quot;Here is the string *p: %s\n&quot;</span>, *p) <span class="hljs-comment">// prints string</span><br>fmt.Printf(<span class="hljs-string">&quot;Here is the string  s: %s\n&quot;</span>, s)  <span class="hljs-comment">// prints same string</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">Here is the pointer p: 0x2540820</span><br><span class="hljs-comment">Here is the string *p: ciao</span><br><span class="hljs-comment">Here is the string s: ciao</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这里可以看到，当我们在使用指针的时候，第一个输出由于还没有进行操作，所以p指向的是s的地址。而第二个输出*p已经被赋了新值，而后s也被改变了，所以输出都是ciao。</p><p>需要注意的是指针不能获取字面量和常量的地址。</p><p>指针的一个高级应用是你可以传递一个变量的引用（如函数的参数），这样不会传递变量的拷贝。指针传递是很廉价的，只占用 4 个或 8 个字节。当程序在工作中需要占用大量的内存，或很多变量，或者两者都有，使用指针会减少内存占用和提高效率。被指向的变量也保存在内存中，直到没有任何指针指向它们，所以从它们被创建开始就具有相互独立的生命周期。</p><p>另一方面（虽然不太可能），由于一个指针导致的间接引用（一个进程执行了另一个地址），指针的过度频繁使用也会导致性能下降。</p><p>指针也可以指向另一个指针，并且可以进行任意深度的嵌套，导致你可以有多级的间接引用，但在大多数情况这会使你的代码结构不清晰。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>这里将根据这本书的相关内容对之前学习的内容进行补充。</p><p>首先先做一下书中提出的问题</p><p>如下的两个函数调用有什么不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">(A) <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">(a *A)</span></span> &#123;<br>        b = a<br>    &#125;<br><br>(B) <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">(a A)</span></span> &#123;<br>        b = &amp;a<br>    &#125;<br></code></pre></td></tr></table></figure><p>首先A中，a指向了指针*A，所以在后续是可以直接对A值本身进行修改，也就是说b现在指向了和a一样的地址，后续函数内对b的修改同样会影响a</p><p>B中，a指向的是值A，而b指向的是a的地址（副本），也就是调用了这个值（副本），并不会影响a原本的值</p><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>函数返回值可以使用<code>return</code>或<code>return var</code>，但这里就有一个问题，返回值是一个表达式的时候可能会因为没有明确的目标而报错（虽然我写python的时候也老干这个，但好像没啥影响）。所以尽可能用简短的，好辨识的返回值来命名，尽可能减少使用表达式。</p><h2 id="改变外部变量"><a href="#改变外部变量" class="headerlink" title="改变外部变量"></a>改变外部变量</h2><p>这里就需要用到指针了，实例如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// this function changes reply:</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Multiply</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>, reply *<span class="hljs-type">int</span>)</span></span> &#123;<br>    *reply = a * b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    n := <span class="hljs-number">0</span><br>    reply := &amp;n<br>    Multiply(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, reply)<br>    fmt.Println(<span class="hljs-string">&quot;Multiply:&quot;</span>, *reply) <span class="hljs-comment">// Multiply: 50</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以看到，我们在主函数部分让reply指向了n的地址，后续我们在Multiply函数中对reply的修改会影响到n，也就是通过*reply修改了外部变量的值。这里我们就是按引用传递而不是按值传递.</p><h2 id="传递变长参数"><a href="#传递变长参数" class="headerlink" title="传递变长参数"></a>传递变长参数</h2><p>如果函数的最后一个参数是<code>...type</code>的形式，这个函数就可以处理一个变长的参数，这个长度可以为0，故而被称为变参函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(a, b, arg ...<span class="hljs-type">int</span>)</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greeting</span><span class="hljs-params">(prefix <span class="hljs-type">string</span>, who ...<span class="hljs-type">string</span>)</span></span><br>Greeting(<span class="hljs-string">&quot;hello:&quot;</span>, <span class="hljs-string">&quot;Joe&quot;</span>, <span class="hljs-string">&quot;Anna&quot;</span>, <span class="hljs-string">&quot;Eileen&quot;</span>)<br></code></pre></td></tr></table></figure><p>在<code>Greeting</code>函数中，变量<code>who</code>便是变长参数，值便是<code>[]string&#123;&quot;Joe&quot;, &quot;Anna&quot;, &quot;Eileen&quot;&#125;</code></p><p>如果参数被存储在一个 slice 类型的变量 <code>slice</code> 中，则可以通过 <code>slice...</code> 的形式来传递参数，调用变参函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>x := min(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)<br>fmt.Printf(<span class="hljs-string">&quot;The minimum is: %d\n&quot;</span>, x)<br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>&#125;<br>x = min(slice...)<br>fmt.Printf(<span class="hljs-string">&quot;The minimum in the slice is: %d&quot;</span>, x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(s ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s)==<span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>min := s[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">if</span> v &lt; min &#123;<br>min = v<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> min<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">The minimum is: 0</span><br><span class="hljs-comment">The minimum in the slice is: 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>一个接受变长参数的函数可以将这个参数作为其他函数的参数进行传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F1</span><span class="hljs-params">(s ...<span class="hljs-type">string</span>)</span></span> &#123;<br>F2(s...)<br>F3(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F2</span><span class="hljs-params">(s ...<span class="hljs-type">string</span>)</span></span> &#123; &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F3</span><span class="hljs-params">(s []<span class="hljs-type">string</span>)</span></span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>变长参数可以作为对应类型的slice进行二次传递</p><p>如果变长参数的类型不同，有两种方式可以解决</p><ol><li>使用结构，定义一个结构类型，假设它叫<code>Options</code>，用于存储所有可能的参数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Options <span class="hljs-keyword">struct</span> &#123;<br>par1 type1,<br>par2 type2,<br>...<br>&#125;<br></code></pre></td></tr></table></figure>函数 F1() 可以使用正常的参数 a 和 b，以及一个没有任何初始化的 Options 结构： F1(a, b, Options {})。如果需要对选项进行初始化，则可以使用 F1(a, b, Options {par1:val1, par2:val2})。</li><li>使用空接口，如果一个变长参数的类型没有被指定，则默认为空接口interface{}，则就可以接入任何类型的参数。这种情况下我们不仅可以接入任何类型的参数，即使参数长度不固定也是没问题的。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">typecheck</span><span class="hljs-params">(..,..,values … <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> values &#123;<br><span class="hljs-keyword">switch</span> v := value.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-type">int</span>: …<br><span class="hljs-keyword">case</span> float: …<br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>: …<br><span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>: …<br><span class="hljs-keyword">default</span>: …<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="defer和追踪"><a href="#defer和追踪" class="headerlink" title="defer和追踪"></a>defer和追踪</h2><p>关键词<code>defer</code>允许我们推迟到函数返回之前（或任意位置执行<code>return</code>语句之后）一刻才执行某个语句或函数。而返回的原因就是在<code>return</code>中同样包含一些操作，并不是单纯返回一个值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>function1()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function1</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;In function1 at the top\n&quot;</span>)<br><span class="hljs-keyword">defer</span> function2()<br>fmt.Printf(<span class="hljs-string">&quot;In function1 at the bottom!\n&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function2</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Function2: Deferred until the end of the calling function!\n&quot;</span>)<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">In Function1 at the top</span><br><span class="hljs-comment">In Function1 at the bottom!</span><br><span class="hljs-comment">Function2: Deferred until the end of the calling function!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这里我们在执行后可以看到是在function1的第二个Println之后才去执行function2。我们再对比下去掉<code>defer</code>关键词的结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">In function1 at the top<br>Function2: Deferred until the end of the calling function!<br>In function1 at the bottom!<br></code></pre></td></tr></table></figure><p>这里我们就可以很清楚的看到，加入了<code>defer</code>关键词，我们的function2就被在运行到的时候被挂起，等function1的执行结束后立刻接在后面，这也就是概念中提到的推迟。</p><p>使用<code>defer</code>关键词还可以接受参数，下面这个例子就是因为defer直接接受了参数i &#x3D; 0，然后挂起。即使后面i &#x3D; 1还是会用挂起时的数进行输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">defer</span> fmt.Println(i)<br>i++<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当有多个<code>defer</code>行被注册时，将会以逆序进行运行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, i)<br>&#125;<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">4 3 2 1 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>defer</code>关键词的特性可以使得我们能够进行一些特殊的操作</p><ol><li>关闭文件流<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// open a file  </span><br><span class="hljs-keyword">defer</span> file.Close()<br></code></pre></td></tr></table></figure></li><li>解锁一个加锁的资源<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">mu.Lock()  <br><span class="hljs-keyword">defer</span> mu.Unlock() <br></code></pre></td></tr></table></figure></li><li>打印最终的报告<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">printHeader()  <br><span class="hljs-keyword">defer</span> printFooter()<br></code></pre></td></tr></table></figure></li><li>关闭数据库链接<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// open a database connection  </span><br><span class="hljs-keyword">defer</span> disconnectFromDB()   <br></code></pre></td></tr></table></figure></li></ol><p>下面一个实例来结合上面的第四种操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>doDBOperations()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connectToDB</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;ok, connected to db&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">disconnectFromDB</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;ok, disconnected from db&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doDBOperations</span><span class="hljs-params">()</span></span> &#123;<br>connectToDB()<br>fmt.Println(<span class="hljs-string">&quot;Defering the database disconnect.&quot;</span>)<br><span class="hljs-keyword">defer</span> disconnectFromDB() <span class="hljs-comment">//function called here with defer</span><br>fmt.Println(<span class="hljs-string">&quot;Doing some DB operations ...&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;Oops! some crash or network error ...&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;Returning from function here!&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-comment">//terminate the program</span><br><span class="hljs-comment">// deferred function executed here just before actually returning, even if</span><br><span class="hljs-comment">// there is a return or abnormal termination before</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">ok, connected to db</span><br><span class="hljs-comment">Defering the database disconnect.</span><br><span class="hljs-comment">Doing some DB operations ...</span><br><span class="hljs-comment">Oops! some crash or network error ...</span><br><span class="hljs-comment">Returning from function here!</span><br><span class="hljs-comment">ok, disconnected from db</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>还可以使用<code>defer</code>来实现追踪，下面两个函数就是很简单的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;entering:&quot;</span>, s) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">untrace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;leaving:&quot;</span>, s) &#125;<br></code></pre></td></tr></table></figure><p>结合到实际中就是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span>   &#123; fmt.Println(<span class="hljs-string">&quot;entering:&quot;</span>, s) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">untrace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;leaving:&quot;</span>, s) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br>trace(<span class="hljs-string">&quot;a&quot;</span>)<br><span class="hljs-keyword">defer</span> untrace(<span class="hljs-string">&quot;a&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;in a&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br>trace(<span class="hljs-string">&quot;b&quot;</span>)<br><span class="hljs-keyword">defer</span> untrace(<span class="hljs-string">&quot;b&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;in b&quot;</span>)<br>a()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>b()<br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">entering: b</span><br><span class="hljs-comment">in b</span><br><span class="hljs-comment">entering: a</span><br><span class="hljs-comment">in a</span><br><span class="hljs-comment">leaving: a</span><br><span class="hljs-comment">leaving: b</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这里leaving先a后b是因为挂起是b先挂起，所以后输出</p><p>这里还有一个例子说明另一种<code>defer</code>语句，也就是使用<code>defer</code>语句来记录函数的参数和返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func1</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>log.Printf(<span class="hljs-string">&quot;func1(%q) = %d, %v&quot;</span>, s, n, err)<br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">7</span>, io.EOF<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>func1(<span class="hljs-string">&quot;Go&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">2024/08/09 15:17:05 func1(&quot;Go&quot;) = 7, EOF</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><code>close()</code></td><td>用于管道通信</td></tr><tr><td><code>len()</code>、<code>cap()</code></td><td><code>len()</code> 用于返回某个类型的长度或数量（字符串、数组、切片、<code>map</code> 和管道）；<code>cap()</code> 是容量的意思，用于返回某个类型的最大容量（只能用于数组、切片和管道，不能用于 <code>map</code>）</td></tr><tr><td><code>new()</code>、<code>make()</code></td><td><code>new()</code> 和 <code>make()</code> 均是用于分配内存：<code>new()</code> 用于值类型和用户定义的类型，如自定义结构，<code>make</code> 用于内置引用类型（切片、<code>map</code> 和管道）。它们的用法就像是函数，但是将类型作为参数：<code>new(type)</code>、<code>make(type)</code>。<code>new(T)</code> 分配类型 <code>T</code> 的零值并返回其地址，也就是指向类型 <code>T</code> 的指针。它也可以被用于基本类型：<code>v := new(int)</code>。<code>make(T)</code> 返回类型 <code>T</code> 的初始化之后的值，因此它比 <code>new()</code> 进行更多的工作。<code>new()</code> 是一个函数，不要忘记它的括号。</td></tr><tr><td><code>copy()</code>、<code>append()</code></td><td>用于复制和连接切片</td></tr><tr><td><code>panic()</code>、<code>recover()</code></td><td>两者均用于错误处理机制</td></tr><tr><td><code>print()</code>、<code>println()</code></td><td>底层打印函数，在部署环境中建议使用 <code>fmt</code> 包</td></tr><tr><td><code>complex()</code>、<code>real ()</code>、<code>imag()</code></td><td>用于创建和操作复数</td></tr></tbody></table><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>最经典的就是计算斐波那契数列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>result := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>result = fibonacci(i)<br>fmt.Printf(<span class="hljs-string">&quot;fibonacci(%d) is: %d\n&quot;</span>, i, result)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> (res <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<br>res = <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>res = fibonacci(n<span class="hljs-number">-1</span>) + fibonacci(n<span class="hljs-number">-2</span>)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">fibonacci(0) is: 1</span><br><span class="hljs-comment">fibonacci(1) is: 1</span><br><span class="hljs-comment">fibonacci(2) is: 2</span><br><span class="hljs-comment">fibonacci(3) is: 3</span><br><span class="hljs-comment">fibonacci(4) is: 5</span><br><span class="hljs-comment">fibonacci(5) is: 8</span><br><span class="hljs-comment">fibonacci(6) is: 13</span><br><span class="hljs-comment">fibonacci(7) is: 21</span><br><span class="hljs-comment">fibonacci(8) is: 34</span><br><span class="hljs-comment">fibonacci(9) is: 55</span><br><span class="hljs-comment">fibonacci(10) is: 89</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>go还可以函数之间相互递归调用，由于go的特性，函数声明的位置可以任意</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d is even: is %t\n&quot;</span>, <span class="hljs-number">16</span>, even(<span class="hljs-number">16</span>)) <span class="hljs-comment">// 16 is even: is true</span><br>fmt.Printf(<span class="hljs-string">&quot;%d is odd: is %t\n&quot;</span>, <span class="hljs-number">17</span>, odd(<span class="hljs-number">17</span>))<br><span class="hljs-comment">// 17 is odd: is true</span><br>fmt.Printf(<span class="hljs-string">&quot;%d is odd: is %t\n&quot;</span>, <span class="hljs-number">18</span>, odd(<span class="hljs-number">18</span>))<br><span class="hljs-comment">// 18 is odd: is false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">even</span><span class="hljs-params">(nr <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> nr == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> odd(RevSign(nr) - <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">odd</span><span class="hljs-params">(nr <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> nr == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> even(RevSign(nr) - <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RevSign</span><span class="hljs-params">(nr <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> nr &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> -nr<br>&#125;<br><span class="hljs-keyword">return</span> nr<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">16 is even: is true</span><br><span class="hljs-comment">17 is odd: is true</span><br><span class="hljs-comment">18 is odd: is false</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="闭包的补充"><a href="#闭包的补充" class="headerlink" title="闭包的补充"></a>闭包的补充</h2><p>实例中将会看到函数<code>Add2()</code>和<code>Adder()</code>均返回签名为<code>func(b_int) int</code>的函数</p><p><code>Add2()</code>不接受任何参数，而<code>Adder()</code>接受一个int类型的参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// make an Add2 function, give it a name p2, and call it:</span><br>p2 := Add2()<br>fmt.Printf(<span class="hljs-string">&quot;Call Add2 for 3 gives: %v\n&quot;</span>, p2(<span class="hljs-number">3</span>))<br><span class="hljs-comment">// make a special Adder function, a gets value 2:</span><br>TwoAdder := Adder(<span class="hljs-number">2</span>)<br>fmt.Printf(<span class="hljs-string">&quot;The result is: %v\n&quot;</span>, TwoAdder(<span class="hljs-number">3</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add2</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> b + <span class="hljs-number">2</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Adder</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面这个实例是另外一种写法实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f = Adder()<br>fmt.Print(f(<span class="hljs-number">1</span>), <span class="hljs-string">&quot; - &quot;</span>)<br>fmt.Print(f(<span class="hljs-number">20</span>), <span class="hljs-string">&quot; - &quot;</span>)<br>fmt.Print(f(<span class="hljs-number">300</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Adder</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(delta <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>x += delta<br><span class="hljs-keyword">return</span> x<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用闭包调试"><a href="#使用闭包调试" class="headerlink" title="使用闭包调试"></a>使用闭包调试</h2><p>在分析和调试复杂程序时，无数个函数在代码之间相互调用，如果能准确知道哪个文件中哪个函数在运行会对分析有很大的帮助。可以使用 <code>runtime</code> 或 <code>log</code> 包中的特殊函数来实现这样的功能。包 <code>runtime</code> 中的函数 <code>Caller()</code> 提供了相应的信息，因此可以在需要的时候实现一个 <code>where()</code> 闭包函数来打印函数执行的位置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">where := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>_, file, line, _ := runtime.Caller(<span class="hljs-number">1</span>)<br>log.Printf(<span class="hljs-string">&quot;%s:%d&quot;</span>, file, line)<br>&#125;<br>where()<br><span class="hljs-comment">// some code</span><br>where()<br><span class="hljs-comment">// some more code</span><br>where()<br></code></pre></td></tr></table></figure><p>也可以设置<code>log</code>包中的<code>flag</code>参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">log.SetFlags(log.Llongfile)<br>log.Print(<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p>或使用更精简版的<code>where()</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> where = log.Print<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span> &#123;<br>where()<br>... some code<br>where()<br>... some code<br>where()<br>&#125;<br></code></pre></td></tr></table></figure><p>这部分还是等后面再深入学吧🤣，咱连很多基础内容都没学呢。</p><p>得嘞，今儿就到这吧，bye~</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——栈</title>
    <link href="/2024/08/08/leetcode-%E6%A0%88/"/>
    <url>/2024/08/08/leetcode-%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20 有效的括号"></a>20 有效的括号</h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li><p>左括号必须用相同类型的右括号闭合。</p></li><li><p>左括号必须以正确的顺序闭合。</p></li><li><p>每个右括号都有一个对应的相同类型的左括号。</p></li></ol><p>示例 1：</p><pre><code class="hljs">输入：s = &quot;()&quot;输出：true</code></pre><p>示例 2：</p><pre><code class="hljs">输入：s = &quot;()[]&#123;&#125;&quot;输出：true</code></pre><p>示例 3：</p><pre><code class="hljs">输入：s = &quot;(]&quot;输出：false</code></pre><p>提示：</p><p><code>1 &lt;= s.length &lt;= 104</code></p><p><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题基本上都多多少少做过、听过，思路基本上就是一个，遇到括号左边压入栈，遇到括号右边就匹配，成功就弹出栈顶失败就false</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        stack = []<br>        dic = &#123;<span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>:<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>:<span class="hljs-string">&#x27;&#125;&#x27;</span>&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> dic:<br>                stack.append(i)<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> dic[stack.pop()] != i:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间43ms，消耗内存16.5MB</p><h1 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71 简化路径"></a>71 简化路径</h1><p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 <code>Unix</code> 风格 <strong>绝对路径</strong> （以 <code>&#39;/&#39;</code> 开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>&#39;//&#39;</code>）都被视为单个斜杠 <code>&#39;/&#39; </code>。 对于此问题，任何其他格式的点（例如，’<code>...</code>‘）均被视为文件&#x2F;目录名称。</p><p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p><p>始终以斜杠 <code>&#39;/&#39;</code> 开头。<br>两个目录名之间必须只有一个斜杠 <code>&#39;/&#39;</code> 。<br>最后一个目录名（如果存在）不能 以 <code>&#39;/&#39;</code> 结尾。<br>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘<code>.</code>‘ 或 ‘<code>..</code>‘）。<br>返回简化后得到的 <strong>规范路径</strong> 。</p><p>示例 1：</p><pre><code class="hljs">输入：path = &quot;/home/&quot;输出：&quot;/home&quot;解释：注意，最后一个目录名后面没有斜杠。 </code></pre><p>示例 2：</p><pre><code class="hljs">输入：path = &quot;/../&quot;输出：&quot;/&quot;解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</code></pre><p>示例 3：</p><pre><code class="hljs">输入：path = &quot;/home//foo/&quot;输出：&quot;/home/foo&quot;解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</code></pre><p>示例 4：</p><pre><code class="hljs">输入：path = &quot;/a/./b/../../c/&quot;输出：&quot;/c&quot;</code></pre><p>提示：</p><p><code>1 &lt;= path.length &lt;= 3000</code></p><p><code>path</code> 由英文字母，数字，<code>&#39;.&#39;</code>，<code>&#39;/&#39;</code> 或 <code>&#39;_&#39;</code> 组成。</p><p><code>path</code> 是一个有效的 Unix 风格绝对路径。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先将所有的<code>/</code>给去掉，然后在我们没遇到<code>&#39; &#39;</code>, <code>&#39;.&#39;</code>, <code>&#39;..&#39;</code>时就会直接压入当前元素，然后当我们遇到<code>&#39;..&#39;</code>就直接将栈顶元素弹出，因为要返回上一级。最后用<code>/</code>连接每个字符并在最前面添加一个<code>/</code></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">simplifyPath</span>(<span class="hljs-params">self, path: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        stack = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> path.split(<span class="hljs-string">&#x27;/&#x27;</span>):<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;..&#x27;</span> <span class="hljs-keyword">and</span> stack:<br>                stack.pop()<br>            <span class="hljs-keyword">elif</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;..&#x27;</span>]:<br>                stack.append(i)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;/&#x27;</span> + <span class="hljs-string">&#x27;/&#x27;</span>.join(stack)<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间49ms，消耗内存16.3MB</p><h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155 最小栈"></a>155 最小栈</h1><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><p><code>MinStack()</code> 初始化堆栈对象。<br><code>void push(int val)</code> 将元素val推入堆栈。<br><code>void pop()</code> 删除堆栈顶部的元素。<br><code>int top()</code> 获取堆栈顶部的元素。<br><code>int getMin()</code> 获取堆栈中的最小元素。</p><p>示例 1:</p><p>输入：</p><pre><code class="hljs">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]</code></pre><p>输出：</p><pre><code class="hljs">[null,null,null,null,-3,null,0,-2] </code></pre><p>解释：</p><pre><code class="hljs">MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre><p>提示：</p><p><code>-231 &lt;= val &lt;= 231 - 1</code></p><p><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</p><p><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 104</code> 次</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这里基本上都是采用辅助栈的形式去做，做法其实大差不差</p><p>四个函数分别说一下</p><p><code>push</code>，每当我们push一个新值进来，如果小于等于辅助栈的栈顶则一起push到辅助栈，也就更新了最小值</p><p><code>pop</code>，如果栈顶和辅助栈的栈顶一样，两个都pop，保证最小值在辅助栈中</p><p><code>top</code>，返回主栈栈顶元素</p><p><code>getMin</code>，返回辅助栈栈顶元素也即最小值</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span>:<br>    <span class="hljs-comment"># 初始化两个栈，一个用于存储所有元素，另一个用于存储最小元素</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.stack = []<br>        <span class="hljs-variable language_">self</span>.min_stack = []<br><br>    <span class="hljs-comment"># 向栈中添加元素，并更新最小元素栈</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-variable language_">self</span>.stack.append(val)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.min_stack <span class="hljs-keyword">or</span> val &lt;= <span class="hljs-variable language_">self</span>.min_stack[-<span class="hljs-number">1</span>]:<br>            <span class="hljs-variable language_">self</span>.min_stack.append(val)<br><br>    <span class="hljs-comment"># 从栈中移除元素，并更新最小元素栈</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        x = <span class="hljs-variable language_">self</span>.stack.pop()<br>        <span class="hljs-keyword">if</span> x == <span class="hljs-variable language_">self</span>.min_stack[-<span class="hljs-number">1</span>]:<br>            <span class="hljs-variable language_">self</span>.min_stack.pop()<br><br>    <span class="hljs-comment"># 获取栈顶元素</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.stack[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-comment"># 获取栈中的最小元素</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMin</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.min_stack[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(1)，执行时间59ms，消耗内存20MB</p><p>这里容易有一个误区就是pop的时候我们把辅助栈的最小元素给pop了，那么我们是不是就没有辅助栈了呢。并不是，辅助栈也是会被更新的，如果我们在pop的下一个就需要运行getMin了，那得到的就肯定为空了。当我们在后续还有新的push，那必然获得的就不是这个为空的了。</p><h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150 逆波兰表达式求值"></a>150 逆波兰表达式求值</h1><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p>注意：</p><p>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</p><p>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</p><p>两个整数之间的除法总是 <strong>向零截断</strong> 。</p><p>表达式中不含除零运算。</p><p>输入是一个根据逆波兰表示法表示的算术表达式。</p><p>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</p><p>示例 1：</p><pre><code class="hljs">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]输出：9解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</code></pre><p>示例 2：</p><pre><code class="hljs">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]输出：6解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</code></pre><p>示例 3：</p><pre><code class="hljs">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]输出：22解释：该算式转化为常见的中缀算术表达式为：((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22</code></pre><p>提示：</p><p><code>1 &lt;= tokens.length &lt;= 104</code></p><p><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</p><p>逆波兰表达式：</p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><p>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</p><p>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</p><p>逆波兰表达式主要有以下两个优点：</p><p>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + *</code> 也可以依据次序计算出正确结果。</p><p>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先第一个需要理解的点是逆波兰表达式是一个后缀表达式，所以我们可以先将后缀表达式转换为逆波兰表达式，并计算结果。而我们常用的计算式是中缀表达式，所以明白了这点就可以大概构思出怎么做。</p><p>接下来我们需要想到几个问题。</p><p>第一当用例中出现负数怎么办，负数我们可以直接转换为<code>-</code> + <code>num</code>这样就变相的改成了计算式，然后数字直接int为整数就行。</p><p>第二，当我们看到题目中的第三条时会有一个很无语的事情，就是除法需要 <strong>向零截断</strong>，而python的除余结果是直接向下取整。然而，在我们第一步的操作后，我们直接解决了这个问题，唯一需要注意的是我们除式的结果需要转化为int型变量</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">evalRPN</span>(<span class="hljs-params">self, tokens: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        stack = []<br>        dic = &#123;<span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">lambda</span> x,y:x+y, <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">lambda</span> x,y:x-y, <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">lambda</span> x,y:x*y, <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">lambda</span> x,y:<span class="hljs-built_in">int</span>(x/y)&#125;<br>        <span class="hljs-comment"># 定义一个字典dic，存储运算符和对应的lambda函数，用于执行相应的算术操作</span><br>        <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> tokens:<br>            <span class="hljs-comment"># 遍历tokens列表中的每一个token</span><br>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">in</span> dic:<br>                <span class="hljs-comment"># 如果token是运算符</span><br>                y = stack.pop()<br>                x = stack.pop()<br>                <span class="hljs-comment"># 从stack中弹出两个操作数</span><br>                stack.append(dic[token](x,y))<br>                <span class="hljs-comment"># 执行相应的算术操作，并将结果压入stack</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 如果token是操作数</span><br>                stack.append(<span class="hljs-built_in">int</span>(token))<br>                <span class="hljs-comment"># 将token转换为整数并压入stack</span><br>        <span class="hljs-keyword">return</span> stack[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># 返回stack中唯一的元素，即逆波兰表达式的计算结果</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间40ms，消耗内存18.2MB</p><h1 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224 基本计算器"></a>224 基本计算器</h1><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval() </code>。</p><p>示例 1：</p><pre><code class="hljs">输入：s = &quot;1 + 1&quot;输出：2</code></pre><p>示例 2：</p><pre><code class="hljs">输入：s = &quot; 2-1 + 2 &quot;输出：3</code></pre><p>示例 3：</p><pre><code class="hljs">输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;输出：23</code></pre><p>提示：</p><p><code>1 &lt;= s.length &lt;= 3 * 105</code></p><p><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</p><p><code>s</code> 表示一个有效的表达式</p><p><code>&#39;+&#39;</code> 不能用作一元运算(例如， <code>&quot;+1&quot;</code> 和 <code>&quot;+(2 + 3)&quot;</code> 无效)</p><p><code>&#39;-&#39;</code> 可以用作一元运算(即 <code>&quot;-1&quot;</code> 和 <code>&quot;-(2 + 3)&quot;</code> 是有效的)</p><p>输入中不存在两个连续的操作符</p><p>每个数字和运行的计算将适合于一个有符号的 <strong>32位</strong> 整数</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这个问题的核心是如何处理加减法运算，并正确处理括号内的优先级。我们可以通过以下步骤来解决问题：</p><ol><li><p>符号转换：我们将 <code>+</code> 用 <code>1</code> 表示，将 <code>-</code> 用 <code>-1</code> 表示。这样，当遇到加减号时，可以通过将当前数字乘以符号值来简化运算过程。</p></li><li><p>处理括号：当遇到左括号 <code>(</code> 时，需要将当前的计算结果和运算符号压入栈中，保存当前的运算状态。这是因为括号内的运算结果会影响括号外的结果。遇到右括号 <code>)</code> 时，需要弹出栈顶的运算符号和结果，并将括号内的计算结果与之相结合。</p></li></ol><p>示例<br>例如对于表达式 <code>(1+(4+5+2)-3)+(6+8)</code>，我们首先处理最内层的括号，然后逐步将结果合并到外层的运算中。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        stack = []<br>        num = <span class="hljs-number">0</span><br>        sign = <span class="hljs-number">1</span>  <span class="hljs-comment"># 1表示加号，-1表示减号</span><br>        result = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> char.isdigit():<br>                num = num * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(char)<br>            <span class="hljs-keyword">elif</span> char == <span class="hljs-string">&#x27;+&#x27;</span>:<br>                result += sign * num<br>                num = <span class="hljs-number">0</span><br>                sign = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> char == <span class="hljs-string">&#x27;-&#x27;</span>:<br>                result += sign * num<br>                num = <span class="hljs-number">0</span><br>                sign = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> char == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                stack.append(result)<br>                stack.append(sign)<br>                result = <span class="hljs-number">0</span><br>                sign = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> char == <span class="hljs-string">&#x27;)&#x27;</span>:<br>                result += sign * num<br>                num = <span class="hljs-number">0</span><br>                result *= stack.pop()  <span class="hljs-comment"># 乘以括号前的符号</span><br>                result += stack.pop()  <span class="hljs-comment"># 加上括号前的结果</span><br>        <br>        <span class="hljs-comment"># 处理最后一个数字</span><br>        result += sign * num<br>        <br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度：O(n)，执行时间57ms，消耗内存16.9MB</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>区间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go学习记录——第二天</title>
    <link href="/2024/08/08/go-study-second-day/"/>
    <url>/2024/08/08/go-study-second-day/</url>
    
    <content type="html"><![CDATA[<p>今儿继续学go，争取多学点吧，不过感觉困死了，不一定能学多少。</p><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p>惊奇的发现go是没有while循环的，全靠for实现</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>一共三种形式</p><ol><li><code>for init; condition; post &#123;&#125;</code></li><li><code>for condition &#123;&#125;</code></li><li><code>for &#123;&#125;</code></li></ol><p>第一种就是和C差不多的，初始化；条件；后置语句，用来控制循环的次数</p><p>第二种类似于while</p><p>第三种用来无限循环，直到遇到break</p><p>for循环还能对map、slice、数组、字符串进行迭代循环，语法如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> oldMap &#123;<br>    newMap[key] = value<br>&#125;<br></code></pre></td></tr></table></figure><p>其中key和value都是可以省略的，省略的话就只会迭代key，或者只会迭代value</p><p>如果想只读key</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> oldMap<br></code></pre></td></tr></table></figure><p>如果想只读value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> oldMap<br></code></pre></td></tr></table></figure><h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><p>和别的一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> [condition |  ( init; condition; increment ) | Range]<br>&#123;<br>   <span class="hljs-keyword">for</span> [condition |  ( init; condition; increment ) | Range]<br>   &#123;<br>      statement(s)<br>   &#125;<br>   statement(s)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p><code>for</code> 和 <code>switch</code> 都可以用</p><p>唯一需要注意啊的是break和别的不同的一点是可以添加<code>label</code>也就是标签。使用时可以添加在最前面就比如下面这个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>outerLoop: <span class="hljs-comment">// 定义一个名为 outerLoop 的标签</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++ &#123;<br><span class="hljs-keyword">if</span> j == <span class="hljs-number">3</span> &#123;<br><span class="hljs-keyword">break</span> outerLoop <span class="hljs-comment">// 跳出 outerLoop 标签的循环</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;i=%d, j=%d\n&quot;</span>, i, j)<br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;循环结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用outerLoop标记了两层循环，最后跳出循环后继续走下面的代码</p><p>switch和select都可以用break，但通常都用于最后一个case。但select中如果想使用break，虽然可以但理论上由于是非阻塞式循环，是在所有通道匹配后才会输出，break就会影响这个效果。所以通常使用return或goto来跳出循环。</p><p>但这里还有一个问题，由于goto是直接直接去到标记的位置，所以对select来说其实会影响代码的可读性，所以通常还是用return。关于goto后面还会有内容。</p><p>return的例子如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>c2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(time.Second)<br>c1 &lt;- <span class="hljs-number">1</span><br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>c2 &lt;- <span class="hljs-string">&quot;hello&quot;</span><br>&#125;()<br><br><span class="hljs-comment">// 使用 return 跳出 select 语句</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> v := &lt;-c1:<br>fmt.Println(<span class="hljs-string">&quot;received from c1:&quot;</span>, v)<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// 退出函数</span><br><span class="hljs-keyword">case</span> v := &lt;-c2:<br>fmt.Println(<span class="hljs-string">&quot;received from c2:&quot;</span>, v)<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// 退出函数</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>和别的没什么区别</p><p>唯一需要注意的不同就是label</p><p>go的continue也可以使用label去进行操作，例子如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>outerLoop: <span class="hljs-comment">// 定义一个名为 outerLoop 的标签</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++ &#123;<br><span class="hljs-keyword">if</span> j == <span class="hljs-number">3</span> &#123;<br><span class="hljs-keyword">continue</span> outerLoop <span class="hljs-comment">// 跳过当前外层循环的剩余迭代</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;i=%d, j=%d\n&quot;</span>, i, j)<br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;循环结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><p>goto就像前面说的，无条件直达某个位置，这也就导致了代码的结构性和可读性变差，所以能不用就不用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">goto</span> label;<br>..<br>.<br>label: statement;<br></code></pre></td></tr></table></figure><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 定义局部变量 */</span><br>   <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br><br>   <span class="hljs-comment">/* 循环 */</span><br>   LOOP: <span class="hljs-keyword">for</span> a &lt; <span class="hljs-number">20</span> &#123;<br>      <span class="hljs-keyword">if</span> a == <span class="hljs-number">15</span> &#123;<br>         <span class="hljs-comment">/* 跳过迭代 */</span><br>         a = a + <span class="hljs-number">1</span><br>         <span class="hljs-keyword">goto</span> LOOP<br>      &#125;<br>      fmt.Printf(<span class="hljs-string">&quot;a的值为 : %d\n&quot;</span>, a)<br>      a++     <br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-literal">true</span>  &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;这是无限循环。\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>和别的一样，概念没啥好说的</p><p>函数格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function_name</span><span class="hljs-params">( [parameter list] )</span></span> [return_types] &#123;<br>   函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>func：函数从<code>func</code>开始声明<br>function_name：函数名称<br>parameter list：参数列表<br>return_types：返回类型，可以省略<br>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 函数返回两个数的最大值 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(num1, num2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-comment">/* 声明局部变量 */</span><br>   <span class="hljs-keyword">var</span> result <span class="hljs-type">int</span><br><br>   <span class="hljs-keyword">if</span> (num1 &gt; num2) &#123;<br>      result = num1<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      result = num2<br>   &#125;<br>   <span class="hljs-keyword">return</span> result <br>&#125;<br></code></pre></td></tr></table></figure><p>函数调用和python没区别，一个道理</p><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数参数依旧是形参非实参</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 定义相互交换值的函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br><br>   temp = x <span class="hljs-comment">/* 保存 x 的值 */</span><br>   x = y    <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>   y = temp <span class="hljs-comment">/* 将 temp 值赋给 y*/</span><br><br>   <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终如果调用函数，则函数内将交换值，但全局变量并不会变。</p><h2 id="引用传递值"><a href="#引用传递值" class="headerlink" title="引用传递值"></a>引用传递值</h2><p>这里用到指针进行操作，由于指针指向的是实际存储地址，所以在交换后将直接对变量所指向的地址进行改变，进而改变变量值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 定义交换值函数*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x *<span class="hljs-type">int</span>, y *<span class="hljs-type">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">var</span> temp <span class="hljs-type">int</span><br>   temp = *x    <span class="hljs-comment">/* 保持 x 地址上的值 */</span><br>   *x = *y      <span class="hljs-comment">/* 将 y 值赋给 x */</span><br>   *y = temp    <span class="hljs-comment">/* 将 temp 值赋给 y */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数作为实参"><a href="#函数作为实参" class="headerlink" title="函数作为实参"></a>函数作为实参</h2><p>go中可以将函数直接传递给某个变量而作为实参</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-comment">/* 声明函数变量 */</span><br>   getSquareRoot := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>      <span class="hljs-keyword">return</span> math.Sqrt(x)<br>   &#125;<br><br>   <span class="hljs-comment">/* 使用函数 */</span><br>   fmt.Println(getSquareRoot(<span class="hljs-number">9</span>))<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包（匿名函数）"><a href="#闭包（匿名函数）" class="headerlink" title="闭包（匿名函数）"></a>闭包（匿名函数）</h2><p>匿名函数是一个“内联”语句或表达式，优点在于可以直接使用函数内的变量，不用声明。</p><p>匿名函数是无需命名的函数，可以被赋值给变量，方便后续调用。它们可以访问定义时的外部变量，但只访问了这些变量的副本，不会改变外部变量的值。</p><p>当调用匿名函数并传递参数时，参数会覆盖函数内部的同名变量，函数执行完毕后，这些参数会恢复到初始状态。</p><p>匿名函数的优势在于可以方便地创建临时函数，避免重复代码。</p><p>闭包是匿名函数的一个重要特性，它允许匿名函数访问外部变量，即使外部函数已经执行完毕。这里访问的是外部变量的初始参数，而不是副本。</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getSequence</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>   i:=<span class="hljs-number">0</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>      i+=<span class="hljs-number">1</span><br>     <span class="hljs-keyword">return</span> i  <br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-comment">/* nextNumber 为一个函数，函数 i 为 0 */</span><br>   nextNumber := getSequence()  <br><br>   <span class="hljs-comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span><br>   fmt.Println(nextNumber())<br>   fmt.Println(nextNumber())<br>   fmt.Println(nextNumber())<br>   <br>   <span class="hljs-comment">/* 创建新的函数 nextNumber1，并查看结果 */</span><br>   nextNumber1 := getSequence()  <br>   fmt.Println(nextNumber1())<br>   fmt.Println(nextNumber1())<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">output:</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>go中除了函数还有方法，是与特定类型（结构体、接口等）关联的函数，将接收者作为函数的第一个参数。接收者可以是值类型（值拷贝）或指针类型（指针引用）。方法调用时，会将接收者作为第一个参数传递给方法函数，然后方法函数会根据接收者的值或指针进行计算。</p><p>方法的声明格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(variable_name variable_data_type)</span></span> function_name() [return_type]&#123;<br>   <span class="hljs-comment">/* 函数体*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Rectangle <span class="hljs-keyword">struct</span> &#123;<br>Width  <span class="hljs-type">int</span><br>Height <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 方法：计算矩形的面积</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r Rectangle)</span></span> Area() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> r.Width * r.Height<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>rect := Rectangle&#123;Width: <span class="hljs-number">10</span>, Height: <span class="hljs-number">5</span>&#125;<br>area := rect.Area() <span class="hljs-comment">// 调用方法</span><br>fmt.Println(<span class="hljs-string">&quot;面积:&quot;</span>, area) <span class="hljs-comment">// 输出：面积: 50</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Area</code> 方法与 <code>Rectangle</code> 类型关联。当调用 <code>rect.Area()</code> 时，<code>rect</code> 作为接收者被传递给 <code>Area</code> 方法，方法内部使用 <code>r.Width</code> 和 <code>r.Height</code> 计算面积。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>方法是与特定类型关联的函数。</li><li>方法的第一个参数是接收者，可以是值类型或指针类型。</li><li>方法调用时，会将接收者作为第一个参数传递给方法函数。</li><li>方法函数会根据接收者的值或指针进行计算。</li></ul><h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>作用域控制代码中各种元素的使用范围，如包、结构体、变量、函数、方法、常量</p><p>具体来看可以分成三个</p><ul><li>局部变量——函数级作用域</li><li>全局变量——包级作用域</li><li>块级作用域</li><li>形参变量——函数参数</li></ul><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>函数内定义的变量称为局部变量，参数和返回值均为局部变量</p><p>变量用<code>var</code>定义</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 声明局部变量 */</span><br>   <span class="hljs-keyword">var</span> a, b, c <span class="hljs-type">int</span> <br><br>   <span class="hljs-comment">/* 初始化参数 */</span><br>   a = <span class="hljs-number">10</span><br>   b = <span class="hljs-number">20</span><br>   c = a + b<br><br>   fmt.Printf (<span class="hljs-string">&quot;结果： a = %d, b = %d and c = %d\n&quot;</span>, a, b, c)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>函数外定义的变量称为全局变量全局变量可以在整个包（甚至包导出后）使用</p><p>变量用<code>var</code>定义，在包的顶部定义</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">/* 声明全局变量 */</span><br><span class="hljs-keyword">var</span> g <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>   <span class="hljs-comment">/* 声明局部变量 */</span><br>   <span class="hljs-keyword">var</span> a, b <span class="hljs-type">int</span><br><br>   <span class="hljs-comment">/* 初始化参数 */</span><br>   a = <span class="hljs-number">10</span><br>   b = <span class="hljs-number">20</span><br>   g = a + b<br><br>   fmt.Printf(<span class="hljs-string">&quot;结果： a = %d, b = %d and g = %d\n&quot;</span>, a, b, g)<br>&#125;<br></code></pre></td></tr></table></figure><p>在整个代码中，全局变量和局部变量的名称可以是一样的，但在函数内优先使用局部变量。这个和别的是一样的</p><h2 id="形参变量"><a href="#形参变量" class="headerlink" title="形参变量"></a>形参变量</h2><p>形参变量只能在函数内使用，一般作为函数内的局部变量使用</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>在代码块（<code>for</code>, <code>if</code>, <code>switch</code> 等）中，变量的作用范围为这个代码块。</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br>        blockVar := <span class="hljs-number">30</span> <span class="hljs-comment">// 块级作用域</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>今天就到这里吧，虽然但是，总感觉最近学习状态好差，得想办法调整调整了。</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go学习记录——第一天</title>
    <link href="/2024/08/07/go-study-first-day/"/>
    <url>/2024/08/07/go-study-first-day/</url>
    
    <content type="html"><![CDATA[<h1 id="go的基本组成部分"><a href="#go的基本组成部分" class="headerlink" title="go的基本组成部分"></a>go的基本组成部分</h1><ul><li>包声明</li><li>引入包</li><li>函数</li><li>变量</li><li>语句 &amp; 表达式</li><li>注释</li></ul><h1 id="go变量声明"><a href="#go变量声明" class="headerlink" title="go变量声明"></a>go变量声明</h1><p>go中用var来声明变量，语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> variableName dataType<br></code></pre></td></tr></table></figure><p>其中，variableName为变量名，dataType为变量的数据类型。</p><p>一次声明多个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    variable1 dataType1<br>    variable2 dataType2<br>    variable3 dataType3<br>)<br></code></pre></td></tr></table></figure><p>第一种，指定变量类型，如果没有初始化则默认为0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v_name v_type<br>v_name = value<br>或<br><span class="hljs-keyword">var</span> v_name v_type = value<br></code></pre></td></tr></table></figure><p>第二种，不指定类型，由编译器自动推导</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v_name = value<br></code></pre></td></tr></table></figure><p>第三种，短变量声明，在函数内使用，注意当已经进行了变量声明再使用短声明会报错。短声明只适用于函数内使用，不能在全局作用域使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">v_name := value<br></code></pre></td></tr></table></figure><p>第四种，多变量声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    v1, v2, v3 = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;hello&quot;</span><br>)<br>或<br><span class="hljs-keyword">var</span> v1, v2, v3 = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-comment">// 这个为主使用，和python类似，迁移起来较快</span><br>或<br>v1, v2, v3 := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><h1 id="go常量声明"><a href="#go常量声明" class="headerlink" title="go常量声明"></a>go常量声明</h1><p>只能使用布尔型、数字型（int, float, 复数）和字符串型</p><p>常量定义格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> constantName  [<span class="hljs-keyword">type</span>]= value<br></code></pre></td></tr></table></figure><p>多个常量声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> constantName1, constantName2 = value1, value2<br></code></pre></td></tr></table></figure><p>常量中可以使用内置函数进行运算，如len(), cap(), unsafe.Sizeof()等。</p><h2 id="inta"><a href="#inta" class="headerlink" title="inta"></a>inta</h2><p>inta是go中的特殊常量，可以当作一个可以被编译成功的常量</p><p>inta在const关键词出现时将被重置为0，const中每加一行都将使inta加1。</p><p>inta可以做枚举值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    a = inta<br>    b = inta<br>    c = inta<br></code></pre></td></tr></table></figure><p>inta也可以做一个类似行索引的功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    a = inta<br>    b<br>    c<br>)<br></code></pre></td></tr></table></figure><p>输出的结果就是<code>a=0, b=1, c=2</code>。</p><p>inta用法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>a = <span class="hljs-literal">iota</span><br>b<br>c<br>d = <span class="hljs-string">&quot;ha&quot;</span><br>e<br>f = <span class="hljs-number">100</span><br>g<br>h = <span class="hljs-literal">iota</span><br>i<br>)<br><br>fmt.Println(a, b, c, d, e, f, g, h, i)<br>&#125;<br><span class="hljs-comment">// output：</span><br><span class="hljs-comment">// 0 1 2 ha 4 100 6 7 8</span><br></code></pre></td></tr></table></figure><h1 id="go的运算符"><a href="#go的运算符" class="headerlink" title="go的运算符"></a>go的运算符</h1><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><ol><li><p>++ 自增，和+&#x3D;1类似</p></li><li><p>– 自减，和-&#x3D;1类似</p></li></ol><p>别的和python一样</p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>和python一样，直接忽略</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ol><li><p>&amp;&amp; -&gt; and</p></li><li><p>|| -&gt; or</p></li><li><p>!  -&gt; not</p></li></ol><p>从字母换成了符号，其他没区别</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ol><li><p>&amp;  -&gt; 按位与</p></li><li><p>|  -&gt; 按位或</p></li><li><p>^  -&gt; 按位异或</p></li><li><p>&lt;&lt; -&gt; 左移</p></li><li><blockquote><blockquote><p>-&gt; 右移</p></blockquote></blockquote></li><li><p>~  -&gt; 按位取反</p></li></ol><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ol><li>&lt;&lt;&#x3D; -&gt; 左移后赋值</li><li><blockquote><blockquote><p>&#x3D; -&gt; 右移后赋值</p></blockquote></blockquote></li><li>&amp;&#x3D;  -&gt; 按位与后赋值</li><li>|&#x3D;  -&gt; 按位或后赋值</li><li>^&#x3D;  -&gt; 按位异或后赋值</li></ol><p>其他和python一样</p><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><ol><li>&amp; -&gt; 返回实际地址</li><li>‘*’  -&gt; 指针变量</li></ol><h2 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h2><table><thead><tr><th>优先级</th><th>运算符</th></tr></thead><tbody><tr><td>1 一元运算符</td><td>*   &amp;（取地址） +（正号） -（负号）! ~（按位异或）</td></tr><tr><td>2 乘除类运算符</td><td>*  &#x2F;  %  &lt;&lt;  &gt;&gt; &amp;（按位与） &amp;^（按位清除）</td></tr><tr><td>3 加减类运算符</td><td>+  - ‘</td></tr><tr><td>4 关系运算符</td><td>&#x3D;&#x3D; !&#x3D;  &lt;  &lt;&#x3D;  &gt;  &gt;&#x3D;</td></tr><tr><td>5 逻辑运算符</td><td>&amp;&amp;  逻辑或（符号markdown无法显示就用文字代替了）</td></tr></tbody></table><h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><p>和python一样，但编写方式有些不同</p><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 布尔表达式 &#123;<br>   <span class="hljs-comment">/* 在布尔表达式为 true 时执行 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 布尔表达式 &#123;<br>   <span class="hljs-comment">/* 在布尔表达式为 true 时执行 */</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">/* 在布尔表达式为 false 时执行 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="if…else-if…else"><a href="#if…else-if…else" class="headerlink" title="if…else if…else"></a>if…else if…else</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 布尔表达式<span class="hljs-number">1</span> &#123;<br>   <span class="hljs-comment">/* 在布尔表达式1为 true 时执行 */</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> 布尔表达式<span class="hljs-number">2</span> &#123;<br>   <span class="hljs-comment">/* 在布尔表达式2为 true 时执行 */</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">/* 在布尔表达式1和表达式2都为 false 时执行 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> 表达式 &#123;<br>   <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:<br>      <span class="hljs-comment">/* 当表达式的值等于值1时执行 */</span><br>      <span class="hljs-keyword">break</span><br>   <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>      <span class="hljs-comment">/* 当表达式的值等于值2时执行 */</span><br>      <span class="hljs-keyword">break</span><br>   <span class="hljs-keyword">default</span>:<br>      <span class="hljs-comment">/* 当以上都不满足时执行 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Type-Swith"><a href="#Type-Swith" class="headerlink" title="Type Swith"></a>Type Swith</h3><p>用于判断某个interface变量的实际类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> x.(<span class="hljs-keyword">type</span>)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-keyword">type</span>:<br>       statement(s);      <br>    <span class="hljs-keyword">case</span> <span class="hljs-keyword">type</span>:<br>       statement(s); <br>    <span class="hljs-comment">/* 你可以定义任意个数的case */</span><br>    <span class="hljs-keyword">default</span>: <span class="hljs-comment">/* 可选 */</span><br>       statement(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>例子如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125;<br>     <br>   <span class="hljs-keyword">switch</span> i := x.(<span class="hljs-keyword">type</span>) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:   <br>         fmt.Printf(<span class="hljs-string">&quot; x 的类型 :%T&quot;</span>,i)                <br>      <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:   <br>         fmt.Printf(<span class="hljs-string">&quot;x 是 int 型&quot;</span>)                       <br>      <span class="hljs-keyword">case</span> <span class="hljs-type">float64</span>:<br>         fmt.Printf(<span class="hljs-string">&quot;x 是 float64 型&quot;</span>)           <br>      <span class="hljs-keyword">case</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">float64</span>:<br>         fmt.Printf(<span class="hljs-string">&quot;x 是 func(int) 型&quot;</span>)                      <br>      <span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>, <span class="hljs-type">string</span>:<br>         fmt.Printf(<span class="hljs-string">&quot;x 是 bool 或 string 型&quot;</span> )       <br>      <span class="hljs-keyword">default</span>:<br>         fmt.Printf(<span class="hljs-string">&quot;未知型&quot;</span>)     <br>   &#125;   <br>&#125;<br><br>output:<br>x 的类型 : &lt;<span class="hljs-literal">nil</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="fullthrough"><a href="#fullthrough" class="headerlink" title="fullthrough"></a>fullthrough</h3><p>强制执行case后语句，不会判断是否为true<br>即使用了fullthrough，也可以直接用break跳出switch</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>此select非彼select。不是SQL中的那个查看</p><p>这里的select虽然类似switch，但只能作用于通道，一个case只能进行接受或发送</p><p>select会监听每个通道，只要有一个case准备好了就立马执行。如果多个准备好就随机挑选一个。如果一个都没准备好执行default。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br>  <span class="hljs-keyword">case</span> &lt;- channel1:<br>    <span class="hljs-comment">// 执行的代码</span><br>  <span class="hljs-keyword">case</span> value := &lt;- channel2:<br>    <span class="hljs-comment">// 执行的代码</span><br>  <span class="hljs-keyword">case</span> channel3 &lt;- value:<br>    <span class="hljs-comment">// 执行的代码</span><br><br>    <span class="hljs-comment">// 你可以定义任意数量的 case</span><br><br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 所有通道都没有准备好，执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意</p><ul><li>每一个case都必须对应一个通道</li><li>所有channel表达式都会被求值</li><li>所有被发送的表达式都会被求值</li><li>如果有default则会在case均未准备好时执行。如果没有则会阻塞，直到有通道可以运行。Go不会重新对channel或值进行求值</li></ul><p>今儿的就学到这里吧，感觉上在语句写法上和C类似。不过可能是我一直用Python所以还有点不习惯用花括号来作为代码块的感觉。慢慢习惯吧，今儿没啥心情，感觉学不下去了，休息咯~</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL学习记录——第四天</title>
    <link href="/2024/08/07/postgresql-study-fourth-day/"/>
    <url>/2024/08/07/postgresql-study-fourth-day/</url>
    
    <content type="html"><![CDATA[<h1 id="view"><a href="#view" class="headerlink" title="view"></a>view</h1><p>view是PostgreSQL中非常重要的概念，它可以将多个表的关系组合在一起，并提供一个统一的视图，使得用户可以访问到所需要的数据。</p><p>view并不是一个真正的表，只是一个通过查询语句定义的虚拟表，因此，它并不占用磁盘空间，也不存储数据。</p><p>可以包含一个表中的所有行也可以是指定的一个或多个表选定行</p><p>view可以允许用户实现以下几点</p><ul><li>用户或用户组认为更自然的更直观的查找结构数据的方式</li><li>限制数据访问，用户只能访问到被允许的优先数据而不是完整的表</li><li>汇总数据，将多个表的数据汇总到一个视图中，方便用户查看</li><li>简化复杂的查询，通过view可以简化复杂的查询，使得查询更加简单</li></ul><p>PG的视图是只读，无法进行任何修改操作的，只能查询。</p><h2 id="创建view"><a href="#创建view" class="headerlink" title="创建view"></a>创建view</h2><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [TEMP <span class="hljs-operator">|</span> TEMPORARY] <span class="hljs-keyword">VIEW</span> view_name <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> column1, column2.....<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">condition</span>];<br></code></pre></td></tr></table></figure><p>可以在SELECT语句中包含多个表，与正常SQL的查询语句一样。</p><p>导入表的操作和前文一样</p><p>然后进行如下操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> COMPANY_VIEW <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> ID, NAME, AGE<br><span class="hljs-keyword">FROM</span>  COMPANY;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> COMPANY_VIEW;<br></code></pre></td></tr></table></figure><p>最后结果如下</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coq">id | <span class="hljs-type">name</span>  | <span class="hljs-type">age</span><br>----+-------+-----<br>  <span class="hljs-number">1</span> | <span class="hljs-type">Paul</span>  |  <span class="hljs-type">32</span><br>  <span class="hljs-number">2</span> | <span class="hljs-type">Allen</span> |  <span class="hljs-type">25</span><br>  <span class="hljs-number">3</span> | <span class="hljs-type">Teddy</span> |  <span class="hljs-type">23</span><br>  <span class="hljs-number">4</span> | <span class="hljs-type">Mark</span>  |  <span class="hljs-type">25</span><br>  <span class="hljs-number">5</span> | <span class="hljs-type">David</span> |  <span class="hljs-type">27</span><br>  <span class="hljs-number">6</span> | <span class="hljs-type">Kim</span>   |  <span class="hljs-type">22</span><br>  <span class="hljs-number">7</span> | <span class="hljs-type">James</span> |  <span class="hljs-type">24</span><br>(<span class="hljs-number">7</span> rows)<br></code></pre></td></tr></table></figure><h2 id="删除view"><a href="#删除view" class="headerlink" title="删除view"></a>删除view</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> view_name;    <br></code></pre></td></tr></table></figure><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>终于来到了面试必考环节之一（真的被ACID弄得很烦了，时不时就会被拉出来鞭尸）</p><p>基本概念这里就不说了，和MySQL一样。</p><p>只说几点不同的</p><ul><li>PG完全支持ACID，而MySQL只支持部分ACID特性</li><li>PG的事务默认是关闭自动提交，而MySQL默认是开启自动提交</li><li>PG的事务支持回滚，而MySQL不支持</li><li>PG的隔离等级默认为提交读，而MySQL的隔离等级默认为可重复读</li><li>PG的锁机制更加细致，而MySQL的锁机制更加粗糙</li></ul><p>事务的控制是通过下面几个命令完成的</p><p><code>BEGIN TRANSACTION</code>开始事务</p><p><code>COMMIT</code>提交事务</p><p><code>ROLLBACK</code>回滚事务</p><p>事务控制命令只与 INSERT、UPDATE 和 DELETE 一起使用，他们不能在创建表或删除表时使用。</p><h2 id="BEGIN-TRANSACTION"><a href="#BEGIN-TRANSACTION" class="headerlink" title="BEGIN TRANSACTION"></a>BEGIN TRANSACTION</h2><p>事务可以通过命令开始事务并持续下去，直到遇到下一个<code>COMMIT</code>或<code>ROLLBACK</code>命令。</p><p>下面是一个简单的语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><br>或者<br><br><span class="hljs-keyword">BEGIN</span> TRANSACTION;<br></code></pre></td></tr></table></figure><h2 id="COMMIT"><a href="#COMMIT" class="headerlink" title="COMMIT"></a>COMMIT</h2><p>将事务更改的内容提交到数据库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">COMMIT</span>;<br><br>或者<br><br><span class="hljs-keyword">END</span> TRANSACTION;<br></code></pre></td></tr></table></figure><h2 id="ROLLBACK"><a href="#ROLLBACK" class="headerlink" title="ROLLBACK"></a>ROLLBACK</h2><p>撤销还 <strong>未保存</strong> 的事务，即回滚</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>然后是例子，还是用前面的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">WHERE</span> AGE <span class="hljs-operator">=</span> <span class="hljs-number">25</span>;<br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">WHERE</span> AGE <span class="hljs-operator">=</span> <span class="hljs-number">25</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>关于这部分我都不想说了，S锁X锁，不是考锁和隔离级别的关系就是考锁的类型不然就是考死锁。还有悲观锁乐观锁，这个就遇到过一次，不过看面经好像考察次数确实不是很多。</p><p>概念部分太熟悉了直接跳过</p><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">LOCK [ <span class="hljs-keyword">TABLE</span> ]<br>name<br> <span class="hljs-keyword">IN</span><br>lock_mode<br></code></pre></td></tr></table></figure><p>name是当前要锁定表的名称，如果在表名前指定就是锁当前表，如果为指定则锁表及其子表</p><p>lock_name锁定模式指定和哪个锁冲突，不指定的话会使用限制最大的访问独占模式。</p><p>下面是PG支持的锁定模式</p><ol><li>ACCESS SHARE (AccessShareLock)<ul><li>用于SELECT查询，防止表被删除或结构被修改。</li><li>仅与ACCESS EXCLUSIVE冲突。</li></ul></li><li>ROW SHARE (RowShareLock)<ul><li>用于SELECT … FOR UPDATE和SELECT … FOR SHARE，允许读取和共享行级锁。</li><li>与EXCLUSIVE和ACCESS EXCLUSIVE冲突。</li></ul></li><li>ROW EXCLUSIVE (RowExclusiveLock)<ul><li>用于INSERT、UPDATE、DELETE操作，允许行级修改。</li><li>与SHARE、SHARE ROW EXCLUSIVE、EXCLUSIVE和ACCESS EXCLUSIVE冲突。</li></ul></li><li>SHARE UPDATE EXCLUSIVE (ShareUpdateExclusiveLock)<ul><li>用于VACUUM操作，允许更新但不允许删除。</li><li>与SHARE UPDATE EXCLUSIVE、SHARE、SHARE ROW EXCLUSIVE、5 EXCLUSIVE和ACCESS EXCLUSIVE冲突。</li></ul></li><li>SHARE (ShareLock)<ul><li>用于CREATE INDEX操作，允许共享读取但不允许写入。</li><li>与ROW EXCLUSIVE、EXCLUSIVE和ACCESS EXCLUSIVE冲突。</li></ul></li><li>SHARE ROW EXCLUSIVE (ShareRowExclusiveLock)<ul><li>用于某些DDL操作，允许共享读取但限制写入。</li><li>与ROW EXCLUSIVE、SHARE、SHARE ROW EXCLUSIVE、EXCLUSIVE和ACCESS EXCLUSIVE冲突。</li></ul></li><li>EXCLUSIVE (ExclusiveLock)<ul><li>用于某些DDL操作，允许独占访问。</li><li>与ROW SHARE、ROW EXCLUSIVE、SHARE UPDATE EXCLUSIVE、SHARE、SHARE ROW EXCLUSIVE、EXCLUSIVE和ACCESS EXCLUSIVE冲突。</li></ul></li><li>ACCESS EXCLUSIVE (AccessExclusiveLock)<ul><li>用于ALTER TABLE、DROP TABLE等操作，完全独占访问。</li><li>与所有其他锁定模式冲突。</li></ul></li></ol><p>PG中LOCK语句只在事务模式下才能使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">BEGIN</span>;<br>LOCK <span class="hljs-keyword">TABLE</span> company1 <span class="hljs-keyword">IN</span> ACCESS EXCLUSIVE MODE;<br></code></pre></td></tr></table></figure><p>语句的结果是</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">TABLE</span><br></code></pre></td></tr></table></figure><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>基本一样，不再多说</p><h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><p>除了root用户，其他用户在创建数据库、表、视图等对象时，需要有相应的权限。</p><p>权限的控制是通过GRANT和REVOKE命令完成的。</p><h2 id="GRANT"><a href="#GRANT" class="headerlink" title="GRANT"></a>GRANT</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> privilege [, ...]<br><span class="hljs-keyword">ON</span> object [, ...]<br><span class="hljs-keyword">TO</span> &#123; PUBLIC <span class="hljs-operator">|</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">group</span> <span class="hljs-operator">|</span> username &#125;<br></code></pre></td></tr></table></figure><p>privilege是权限类型，包括SELECT、INSERT、UPDATE、DELETE、TRUNCATE、REFERENCES、TRIGGER、CREATE、CONNECT、TEMPORARY、EXECUTE、USAGE等。</p><p>object是要授予权限的对象，包括数据库、表、视图等。</p><p>PUBLIC是所有用户的公共权限，GROUP是用户组的权限，username是具体的用户名。</p><h2 id="REVOKE"><a href="#REVOKE" class="headerlink" title="REVOKE"></a>REVOKE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> privilege [, ...]<br><span class="hljs-keyword">ON</span> object [, ...]<br><span class="hljs-keyword">FROM</span> &#123; PUBLIC <span class="hljs-operator">|</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">group</span> <span class="hljs-operator">|</span> username &#125;<br></code></pre></td></tr></table></figure><p>REVOKE命令的语法和GRANT命令的语法基本相同，只不过是将GRANT命令变成了REVOKE命令。</p><p>好咯，到这里基本的和稍微进阶一点的操作就都学完了。接下来准备开始学习GO语言和前端三件套了💖。</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL学习记录——第三天</title>
    <link href="/2024/08/06/postgresql-study-third-day/"/>
    <url>/2024/08/06/postgresql-study-third-day/</url>
    
    <content type="html"><![CDATA[<p>今天继续学PG，感觉前面的基本操作还比较快，毕竟用的也不少。到后面稍微开始有点慢了，继续努力吧✌️</p><h1 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h1><p>在表中默认可以输入NULL，但从前面建过的表中就能知道可以指定该列不能驶入输入NULL。</p><p>语法大致如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> COMPANY(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   NAME           TEXT    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   AGE            <span class="hljs-type">INT</span>     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   ADDRESS        <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>   SALARY         <span class="hljs-type">REAL</span><br>);<br></code></pre></td></tr></table></figure><p><code>NOT NULL</code>在使用后将使该列如果没有字段输入将无法更新记录，有<code>NULL</code>的可以不添加字段也能更新记录。</p><p><code>NULL</code>和其他语言里一样都表示空，但空并不是一个数，他是不存在，而<code>0</code>是存在。所以<code>NULL</code>和<code>0</code>是不等价的。</p><p>这里添加的表和上一篇blog中JOIN部分的预先准备一样（因为咱没搭载服务器，没法开下载链接🤣）</p><p>使用下面的命令进行操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> COMPANY <span class="hljs-keyword">SET</span> ADDRESS <span class="hljs-operator">=</span> <span class="hljs-keyword">NULL</span>, SALARY <span class="hljs-operator">=</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">WHERE</span> ID <span class="hljs-keyword">IN</span> (<span class="hljs-number">6</span>, <span class="hljs-number">7</span>);<br></code></pre></td></tr></table></figure><h2 id="IS-NOT-NULL"><a href="#IS-NOT-NULL" class="headerlink" title="IS NOT NULL"></a>IS NOT NULL</h2><p>前面说了空现在说不为空（又莫名想到了leetcode上写if not _）。</p><p>用该命令列出所有薪资不为空的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  ID, NAME, AGE, ADDRESS, SALARY <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">WHERE</span> SALARY <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><h2 id="IS-NULL"><a href="#IS-NULL" class="headerlink" title="IS NULL"></a>IS NULL</h2><p>用下面命令列出为空的记录（直接处刑，把没工资的列出来然后开咯~）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  ID, NAME, AGE, ADDRESS, SALARY <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">WHERE</span> SALARY <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><h1 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h1><p>别名和其他的一样都是用<code>AS</code>去设置，大概写一下语法就进入下一个part</p><p>表的别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2....<br><span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">AS</span> alias_name<br><span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">condition</span>];<br></code></pre></td></tr></table></figure><p>列的别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column_name <span class="hljs-keyword">AS</span> alias_name<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">condition</span>];<br></code></pre></td></tr></table></figure><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>这部分原来没咋用过，目测需要花点时间了</p><p>触发器就是数据库的回调函数，会在指定的数据库事件发生时自动执行&#x2F;调用。</p><p>找资料的时候看到的几个PG的触发器比较重要的点，加了点我自己的理解</p><ul><li>触发器可以在下面几种情况下触发<ul><li>在执行操作之前（在检查约束并尝试插入、删除、更新之前）</li><li>在执行操作之后（在检查约束并插入、删除、更新之后）</li><li>更新操作（在对一个表进行插入、删除、更新时）</li></ul></li><li>触发器的<code>FOR EACH ROW</code>属性是可选的，如果选中则在操作修改时每一行调用一次。</li><li>选中<code>FOR EACH STATEMENT</code>属性时，不管修改多少行都只会执行一次。</li><li>WHEN子句和触发器操作在引用NEW.column-name 和 OLD.column-name 表单插入、删除或更新时可以访问每一行元素。</li><li>如果存在 WHEN 子句，PostgreSQL 语句只会执行 WHEN 子句成立的那一行，如果没有 WHEN 子句，PostgreSQL 语句会在每一行执行。</li><li><code>BEFORE</code> 和 <code>AFTER</code> 决定触发器在什么时候执行。</li><li>要修改的表必须和当前操作数据库在一个目录下，不可以使用调用</li><li>约束触发器<ul><li>约束触发器并不是在事件发生前后执行而是可以在指定的时间点触发</li><li>约束触发器可以使用约束选项<code>IMMEDIATE</code>和<code>DEFERRED</code>来调整执行时间</li></ul></li></ul><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">TRIGGER</span> trigger_name [BEFORE<span class="hljs-operator">|</span>AFTER<span class="hljs-operator">|</span>INSTEAD <span class="hljs-keyword">OF</span>] event_name<br><span class="hljs-keyword">ON</span> table_name<br>[<br> <span class="hljs-comment">-- 触发器逻辑....</span><br>];<br></code></pre></td></tr></table></figure><p><code>event_name</code> 可以是在所提到的表 <code>table_name</code> 上的 <code>INSERT</code>、<code>DELETE</code> 和 <code>UPDATE</code> 数据库操作。您可以在表名后选择指定 <code>FOR EACH ROW</code>。</p><p>UPDATE在单表或多表上的示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">TRIGGER</span> trigger_name [BEFORE<span class="hljs-operator">|</span>AFTER] <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">OF</span> column_name<br><span class="hljs-keyword">ON</span> table_name<br>[<br> <span class="hljs-comment">-- 触发器逻辑....</span><br>];<br></code></pre></td></tr></table></figure><p>用<code>DROP TABLE COMPANY;</code>删掉前面part用的COMPANY表，建立一个新的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> COMPANY(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   NAME           TEXT    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   AGE            <span class="hljs-type">INT</span>     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   ADDRESS        <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>   SALARY         <span class="hljs-type">REAL</span><br>);<br></code></pre></td></tr></table></figure><p>然后再建一个对照表AUDIT</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> AUDIT(<br>   EMP_ID <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   ENTRY_DATE TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>);<br></code></pre></td></tr></table></figure><p>然后开始操作，首先建立一个函数</p><p>建立之前先说一下我对函数的基本语法的理解。</p><p>这是我用chatGPT搞的一个示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">FUNCTION</span> get_sum(a <span class="hljs-type">NUMERIC</span>, b <span class="hljs-type">NUMERIC</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">NUMERIC</span> <span class="hljs-keyword">AS</span> $$<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">RETURN</span> a <span class="hljs-operator">+</span> b;<br><span class="hljs-keyword">END</span>;<br>$$ <span class="hljs-keyword">LANGUAGE</span> plpgsql;<br></code></pre></td></tr></table></figure><p>通过直译我们可以发现，创建函数的基本语句就是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">OR</span> REPLACE] <span class="hljs-keyword">FUNCTION</span> 函数名称 (参数列表)<br><span class="hljs-keyword">RETURNS</span> 返回类型 <span class="hljs-keyword">AS</span> $$<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-comment">-- 函数主体</span><br>    <span class="hljs-comment">-- 包含SQL语句和/或过程语言代码</span><br><span class="hljs-keyword">END</span>;<br>$$<br> <span class="hljs-keyword">LANGUAGE</span> 语言名称;<br></code></pre></td></tr></table></figure><p>然后我们回到建立函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">FUNCTION</span> auditlogfunc() <span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-keyword">AS</span> $example_table$<br>   <span class="hljs-keyword">BEGIN</span><br>      <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> AUDIT(EMP_ID, ENTRY_DATE) <span class="hljs-keyword">VALUES</span> (new.ID, <span class="hljs-built_in">current_timestamp</span>);<br>      <span class="hljs-keyword">RETURN</span> <span class="hljs-keyword">NEW</span>;<br>   <span class="hljs-keyword">END</span>;<br>$example_table$ <span class="hljs-keyword">LANGUAGE</span> plpgsql;<br></code></pre></td></tr></table></figure><p>创建后我们来建立触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> example_trigger AFTER <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> COMPANY <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">EXECUTE</span> <span class="hljs-keyword">PROCEDURE</span> auditlogfunc();<br></code></pre></td></tr></table></figure><p>然后向表中插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Paul&#x27;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;California&#x27;</span>, <span class="hljs-number">20000.00</span> );<br></code></pre></td></tr></table></figure><p>插入后我们用SELECT去找AUDIT库就可以看到我们已经添加了数据了。</p><h2 id="列出触发器"><a href="#列出触发器" class="headerlink" title="列出触发器"></a>列出触发器</h2><p>列出所有触发器的语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pg_trigger;<br></code></pre></td></tr></table></figure><p>然后再来看看列出特定触发器的语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> tgname <span class="hljs-keyword">FROM</span> pg_trigger, pg_class <span class="hljs-keyword">WHERE</span> tgrelid<span class="hljs-operator">=</span>pg_class.oid <span class="hljs-keyword">AND</span> relname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;company&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">trigger</span> $&#123;trigger_name&#125; <span class="hljs-keyword">on</span> $&#123;table_of_trigger_dependent&#125;;<br></code></pre></td></tr></table></figure><p>删除我们前面建立的触发器的命令如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">trigger</span> example_trigger <span class="hljs-keyword">on</span> company;<br></code></pre></td></tr></table></figure><p>触发器我自己感觉是更适合大量任务进行时的自动化，可以节省很多人力成本。不过这点好像面试不会特别去考，也不知道为啥。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>终于来到了面试官最最最最喜爱的索引，我自己的经历我感觉除了三范式这个问题出现概率高之外，就是索引会考很多。我自己就遇到过下面几个问题（特指MySQL，毕竟我简历上写的MySQL）</p><ul><li>什么是索引，为什么用索引</li><li>索引的数据结构，他们之间有什么区别</li><li>索引的种类有哪些</li><li>B树和B+树有啥区别（这个我当时懵掉了，之前还复习过）</li><li>索引的使用场景</li><li>之后我也会把我大概能遇到的想到的写成Blog然后发布出来，应该会更倾向于机器学习，毕竟这个我更擅长。</li></ul><p>基本概念咱就跳过，都是一样的，不知道的拖出去乱棍打死</p><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name;<br></code></pre></td></tr></table></figure><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><p>基于表的具体一列去建立索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name (column_name);<br></code></pre></td></tr></table></figure><h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p>基于表的多列去建立索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name (column1_name, column2_name);<br></code></pre></td></tr></table></figure><p>不管是单列还是组合索引都需要建立在频繁多次使用WHERE的情况下，反推出使用场景之一就是频繁使用WHERE的情况下。</p><p>只有一列被使用就用单列索引，多列被使用就用多列索引</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引是为了提高性能、保证数据完整性，保证无重复值进入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX index_name<br><span class="hljs-keyword">on</span> table_name (column_name);<br></code></pre></td></tr></table></figure><h3 id="局部索引"><a href="#局部索引" class="headerlink" title="局部索引"></a>局部索引</h3><p>局部索引是在子集上建立索引，子集由一个条件表达式上定义，索引只包含符合条件的行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name(column_list)<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure><h3 id="隐式索引"><a href="#隐式索引" class="headerlink" title="隐式索引"></a>隐式索引</h3><p>数据库会自动创建</p><h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name;<br></code></pre></td></tr></table></figure><h2 id="索引准则"><a href="#索引准则" class="headerlink" title="索引准则"></a>索引准则</h2><ul><li>适合于中大型表，不适合于小表，小表一般全表扫描更快</li><li>不适用于需要频繁进行大批量的增删改的操作，更适合于大量查询的表</li><li>不应该在含有大量NULL的上</li><li>不应该建立在需要被频繁操作的列上</li><li>多个字段经常一起被查询可以考虑建立联合索引</li><li>多个字段且字段没有重复可以考虑唯一索引</li><li>字段多且有重复考虑普通索引</li></ul><h1 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h1><p>ALTER TABLE 用于添加、修改、删除一张已经存在的表，也可以用来添加和删除约束。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> column_name datatype;<br></code></pre></td></tr></table></figure><h3 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> column_name;<br></code></pre></td></tr></table></figure><h3 id="修改数据类型"><a href="#修改数据类型" class="headerlink" title="修改数据类型"></a>修改数据类型</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> column_name TYPE datatype;<br></code></pre></td></tr></table></figure><h3 id="添加UNIQUE约束"><a href="#添加UNIQUE约束" class="headerlink" title="添加UNIQUE约束"></a>添加UNIQUE约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> MyUniqueConstraint <span class="hljs-keyword">UNIQUE</span>(column1, column2...);<br></code></pre></td></tr></table></figure><h3 id="添加CHECK约束"><a href="#添加CHECK约束" class="headerlink" title="添加CHECK约束"></a>添加CHECK约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> MyUniqueConstraint <span class="hljs-keyword">CHECK</span> (<span class="hljs-keyword">CONDITION</span>);<br></code></pre></td></tr></table></figure><h3 id="添加主键"><a href="#添加主键" class="headerlink" title="添加主键"></a>添加主键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> MyPrimaryKey <span class="hljs-keyword">PRIMARY</span> KEY (column1, column2...);<br></code></pre></td></tr></table></figure><h3 id="添加NOT-NULL约束"><a href="#添加NOT-NULL约束" class="headerlink" title="添加NOT NULL约束"></a>添加NOT NULL约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> column_name <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NOT</span> NNULL;<br></code></pre></td></tr></table></figure><h3 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> MyUniqueConstraint;<br></code></pre></td></tr></table></figure><p>对应MySQL是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">DROP</span> INDEX MyUniqueConstraint;<br></code></pre></td></tr></table></figure><h3 id="删除主键"><a href="#删除主键" class="headerlink" title="删除主键"></a>删除主键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> MyPrimaryKey;<br></code></pre></td></tr></table></figure><p>对应MySQL是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY;<br></code></pre></td></tr></table></figure><h3 id="删除NOT-NULL约束"><a href="#删除NOT-NULL约束" class="headerlink" title="删除NOT NULL约束"></a>删除NOT NULL约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> column_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><h1 id="TRUNCATE-TABLE"><a href="#TRUNCATE-TABLE" class="headerlink" title="TRUNCATE TABLE"></a>TRUNCATE TABLE</h1><p>在使用<code>DROP TABLE TABLE_NAME</code>时会直接删除表内容和表结构，如果想使用该表就需要重新建立</p><p><code>TRUNCATE TABLE</code>就可以只删除表内容保留表结构，并且由于他不扫描表，所以速度上比<code>DELETE</code>更快</p><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span>  table_name;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——区间</title>
    <link href="/2024/08/05/leetcode_%E5%8C%BA%E9%97%B4/"/>
    <url>/2024/08/05/leetcode_%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="228-汇总矩阵"><a href="#228-汇总矩阵" class="headerlink" title="228 汇总矩阵"></a>228 汇总矩阵</h1><p>给定一个  <strong>无重复元素</strong> 的 <strong>有序</strong> 整数数组 <code>nums</code> 。</p><p>返回 <strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表 。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。</p><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><p>“<code>a-&gt;b&quot;</code> ，如果 <code>a != b</code><br>“<code>a</code>“ ，如果 <code>a == b</code></p><p>示例 1：</p><p>输入：nums &#x3D; [0,1,2,4,5,7]</p><p>输出：[“0-&gt;2”,”4-&gt;5”,”7”]</p><p>解释：区间范围是：</p><p>[0,2] –&gt; “0-&gt;2”</p><p>[4,5] –&gt; “4-&gt;5”</p><p>[7,7] –&gt; “7”</p><p>示例 2：</p><p>输入：nums &#x3D; [0,2,3,4,6,8,9]</p><p>输出：[“0”,”2-&gt;4”,”6”,”8-&gt;9”]</p><p>解释：区间范围是：</p><p>[0,0] –&gt; “0”</p><p>[2,4] –&gt; “2-&gt;4”</p><p>[6,6] –&gt; “6”</p><p>[8,9] –&gt; “8-&gt;9”</p><p>提示：</p><p><code>0 &lt;= nums.length &lt;= 20</code></p><p><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></p><p><code>nums</code> 中的所有值都 <strong>互不相同</strong></p><p><code>nums</code> 按升序排列</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到题目第一时间想到两种情况</p><ol><li>如果当前指针和下一个指针两个位置的数相等，将当前指针位置存储到数组中并后移两个指针。</li><li>如果当前指针和下一个指针位置不相等，则下一个指针再往前一个位置。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">summaryRanges</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">help_func</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span>, j: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(nums[i]) <span class="hljs-keyword">if</span> i == j <span class="hljs-keyword">else</span> <span class="hljs-built_in">str</span>(nums[i]) + <span class="hljs-string">&#x27;-&gt;&#x27;</span> + <span class="hljs-built_in">str</span>(nums[j])<br>        <br>        i, n, ans = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums), []<br>        <span class="hljs-keyword">while</span> i &lt; n:<br>            j = i<br>            <span class="hljs-keyword">while</span> j + <span class="hljs-number">1</span> &lt; n <span class="hljs-keyword">and</span> nums[j + <span class="hljs-number">1</span>] == nums[j] + <span class="hljs-number">1</span>:<br>                j += <span class="hljs-number">1</span><br>            ans.append(help_func(i, j))<br>            i = j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间30ms，消耗内存16.2MB</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>刚开始想到的是三指针，但这种情况下，i和j同步往前移，k在i一开始的位置。但是这样后来一想完全没必要，反而浪费了时间。所以双指针直接就能解决，需要检测动的只有一个指针。</p><p>然后看到一个运行速度更快的算法，思路都是一样的，但是这个的执行时间更少。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">summaryRanges</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        <span class="hljs-string">&#x27;&#x27;&#x27;i最多执行n次，O(n)&#x27;&#x27;&#x27;</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        ans = []<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt;n: <span class="hljs-comment"># i从左到右遍历</span><br>            start = i<br>            <span class="hljs-keyword">while</span> i &lt;n -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[i] + <span class="hljs-number">1</span>== nums[i+<span class="hljs-number">1</span>]:  <span class="hljs-comment"># 一直遍历下去直到不连续</span><br>                i += <span class="hljs-number">1</span><br>            s = <span class="hljs-built_in">str</span>(nums[start])<br>            <span class="hljs-keyword">if</span> start &lt; i:<br>                s += <span class="hljs-string">&#x27;-&gt;&#x27;</span><br>                s += <span class="hljs-built_in">str</span>(nums[i])<br>            ans.append(s)<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="56-合并数组"><a href="#56-合并数组" class="headerlink" title="56 合并数组"></a>56 合并数组</h1><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p>示例 1：</p><p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</p><p>输出：[[1,6],[8,10],[15,18]]</p><p>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]。</p><p>示例 2：</p><p>输入：intervals &#x3D; [[1,4],[4,5]]</p><p>输出：[[1,5]]</p><p>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p><p>提示：</p><p><code>1 &lt;= intervals.length &lt;= 104</code></p><p><code>intervals[i].length == 2</code></p><p><code>0 &lt;= starti &lt;= endi &lt;= 104</code></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题一拿到肯定会有点懵，因为第一眼看肯定不知道这俩玩意咋能合并。</p><p>仔细拆解后会发现，题目给出的示例已经给我们怎么去写条件了，当我们当前区间的第一个元素比钱一个区间的第二个元素小或者相等，这时我们就满足了条件。</p><p>然后我们需要找到谁作为新区间的第二个元素，这里很明显就是前一个区间的第二个元素和当前区间的第二个元素较大的那个。</p><p>最后需要强调一个事情就是[-1][1]指的是列表中[-1]指最后一个区间，[1]指第二个元素。代码中ans[-1][1]就是ans列表中的最后一个区间（也就是离当前区间最近的）中第二个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        intervals.sort()<br>        ans = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> intervals:<br>            <span class="hljs-keyword">if</span> ans <span class="hljs-keyword">and</span> i[<span class="hljs-number">0</span>] &lt;= ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:<br>                ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], i[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">else</span>:<br>                ans.append(i)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n log n)，执行时间54ms，消耗内存19.5MB</p><h2 id="反思-1"><a href="#反思-1" class="headerlink" title="反思"></a>反思</h2><p>后来查看了一下其他人的代码，后面的内容大差不差但在排序上使用了lambda来写条件，可以节约时间。但思路上看了几个其他人的都是一样的，先排序后循环比大小。</p><h1 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57 插入区间"></a>57 插入区间</h1><p>给你一个 <strong>无重叠的</strong> ，按照区间起始端点排序的区间列表 <code>intervals</code>，其中 <code>intervals[i] = [starti, endi]</code> 表示第 <code>i</code> 个区间的开始和结束，并且 <code>intervals</code> 按照 <code>starti</code> 升序排列。同样给定一个区间 <code>newInterval = [start, end]</code> 表示另一个区间的开始和结束。</p><p>在 <code>intervals</code> 中插入区间 <code>newInterval</code>，使得 <code>intervals</code> 依然按照 <code>starti</code> 升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。</p><p>返回插入之后的 <code>intervals</code>。</p><p>注意 你不需要原地修改 <code>intervals</code>。你可以创建一个新数组然后返回它。</p><p>示例 1：</p><p>输入：intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]</p><p>输出：[[1,5],[6,9]]</p><p>示例 2：</p><p>输入：intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</p><p>输出：[[1,2],[3,10],[12,16]]</p><p>解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</p><p>提示：</p><p><code>0 &lt;= intervals.length &lt;= 104</code></p><p><code>intervals[i].length == 2</code></p><p><code>0 &lt;= starti &lt;= endi &lt;= 105</code></p><p><code>intervals</code> 根据 <code>starti</code> 按 <strong>升序</strong> 排列</p><p><code>newInterval.length == 2</code></p><p><code>0 &lt;= start &lt;= end &lt;= 105</code></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这道题和前面一道题的唯二不同就在于我们需要先将新区间插入到列表，然后在循环阶段需要引入start和end，其余和前一题一摸一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], newInterval: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        intervals.append(newInterval)<br>        intervals.sort()<br>        ans = [intervals[<span class="hljs-number">0</span>]]<br>        <span class="hljs-keyword">for</span> s, e <span class="hljs-keyword">in</span> intervals[<span class="hljs-number">1</span>:]:<br>            <span class="hljs-keyword">if</span> ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; s:<br>                ans.append([s, e])<br>            <span class="hljs-keyword">else</span>:<br>                ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], e)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n log n)，执行时间49ms，消耗内存18.5MB</p><h2 id="反思-2"><a href="#反思-2" class="headerlink" title="反思"></a>反思</h2><p>这里给出我第一次做的时候的错误代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, intervals: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], newInterval: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        intervals.append(newInterval)<br>        intervals.sort()<br>        ans = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> intervals:<br>            <span class="hljs-keyword">if</span> ans <span class="hljs-keyword">and</span> i[<span class="hljs-number">0</span>] &lt;= ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:<br>                ans[-<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(ans[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], i[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">else</span>:<br>                ans.append(i)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>没有修改循环部分的代码，导致更新了结束的时间忽略了开始时间导致区间格式错误。</p><h1 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452 用最少数量的箭引爆气球"></a>452 用最少数量的箭引爆气球</h1><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code> ，其中<code>points[i] = [x_start, x_end]</code> 表示水平直径在 <code>xstart</code> 和 <code>xend</code> 之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>xstart</code>，<code>xend</code>， 且满足  <code>xstart ≤ x ≤ xend</code>，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 <code>points</code> ，返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数 。</p><p>示例 1：</p><p>输入：points &#x3D; [[10,16],[2,8],[1,6],[7,12]]</p><p>输出：2</p><p>解释：气球可以用2支箭来爆破:</p><p>-在x &#x3D; 6处射出箭，击破气球[2,8]和[1,6]。</p><p>-在x &#x3D; 11处发射箭，击破气球[10,16]和[7,12]。</p><p>示例 2：</p><p>输入：points &#x3D; [[1,2],[3,4],[5,6],[7,8]]</p><p>输出：4</p><p>解释：每个气球需要射出一支箭，总共需要4支箭。</p><p>示例 3：</p><p>输入：points &#x3D; [[1,2],[2,3],[3,4],[4,5]]</p><p>输出：2</p><p>解释：气球可以用2支箭来爆破:</p><ul><li><p>在x &#x3D; 2处发射箭，击破气球[1,2]和[2,3]。</p></li><li><p>在x &#x3D; 4处射出箭，击破气球[3,4]和[4,5]。</p></li></ul><p>提示:</p><p><code>1 &lt;= points.length &lt;= 105</code></p><p><code>points[i].length == 2</code></p><p><code>-231 &lt;= xstart &lt; xend &lt;= 231 - 1</code></p><p>这里找了张评论区一个大哥画的示意图</p><p><img src="/../img/leetcode%E5%8C%BA%E9%97%B4%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%94%E2%80%94452.png" alt="示意图"></p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ol><li>首先对整个气球架的点进行排序，并且把第一个start和end初始化。</li><li>循环中从第二个气球开始，然后思路和前一道题类似，更新最大最小值。</li><li>然后不满足条件了进入else，箭数量加1然后更新点坐标。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMinArrowShots</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        points.sort()<br>        arrow = <span class="hljs-number">0</span><br>        start, end = points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(points)):<br>            <span class="hljs-keyword">if</span> start &lt;= points[i][<span class="hljs-number">0</span>] &lt;= end:<br>                start = <span class="hljs-built_in">max</span>(start, points[i][<span class="hljs-number">0</span>])<br>                end = <span class="hljs-built_in">min</span>(end, points[i][<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">else</span>:<br>                arrow += <span class="hljs-number">1</span><br>                start, end = points[i][<span class="hljs-number">0</span>], points[i][<span class="hljs-number">1</span>]<br>        arrow += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> arrow<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n log n)，执行时间370ms，消耗内存49.5MB</p><h2 id="反思-3"><a href="#反思-3" class="headerlink" title="反思"></a>反思</h2><p>我这个做法相对来说不是很常见的写法，太过直译。下面附上大多数人的做法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMinArrowShots</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> points:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        points.sort(key=<span class="hljs-keyword">lambda</span> balloon: balloon[<span class="hljs-number">1</span>])<br>        pos = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>        ans = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> balloon <span class="hljs-keyword">in</span> points:<br>            <span class="hljs-keyword">if</span> balloon[<span class="hljs-number">0</span>] &gt; pos:<br>                pos = balloon[<span class="hljs-number">1</span>]<br>                ans += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>大部分人的思路都是类似这个，内容可能有差距但思路大差不差。</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>区间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL学习记录——第二天</title>
    <link href="/2024/08/05/postgresql-study-second-day/"/>
    <url>/2024/08/05/postgresql-study-second-day/</url>
    
    <content type="html"><![CDATA[<p>今天准备继续学PG的高级操作，至于为什么过了一个周末才有开始学，那当然是因为上班时间拿来学习周末时间拿来玩啦~</p><p>今天差不多就是约束、JOIN、UNION、别名、索引、触发器、事务、锁这些，gogogo。</p><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>在观感上感觉和MySQL的差不多，但是在查询相关资料后发现还是有些许区别。</p><h2 id="和MySQL区别"><a href="#和MySQL区别" class="headerlink" title="和MySQL区别"></a>和MySQL区别</h2><p>首先明确一点，他们都支持五大约束（不知道的拖出去乱棍打死！面试经常考的都不知道！）。</p><p>PG自带了一个MySQL中没有的约束——排他约束（EXCLUDE）。同时在检查约束（CHECK）上会更加完善，能够支持更复杂的约束条件。</p><p>PG可以给约束别名，而MySQL只能使用原本的名称，这点上如果按照实际操作来看其实没什么差别，一个就是按照原本的英文去写一个就是按照自己的习惯去修改名称。直接用英文的话感觉上会更习惯日常操作。</p><p>PG支持部分约束和表达式约束（部分约束好像我之前面试的时候有被考到过，太久远了忘记了。），能够实现更复杂的操作。</p><h2 id="PG常见约束"><a href="#PG常见约束" class="headerlink" title="PG常见约束"></a>PG常见约束</h2><ul><li>NOT NULL 非空约束</li><li>UNIQUE 唯一约束</li><li>PREMARY key 主键约束</li><li>FOREIGH key 外键约束</li><li>CHECK 检查约束</li><li>EXCLUSION 排他约束</li></ul><h2 id="NOT-NULL"><a href="#NOT-NULL" class="headerlink" title="NOT NULL"></a>NOT NULL</h2><p>默认情况下，列可以为NULL，但如果不让这列为NULL就可以设置此约束。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> COMPANY1(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   NAME           TEXT    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   AGE            <span class="hljs-type">INT</span>     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   ADDRESS        <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>   SALARY         <span class="hljs-type">REAL</span><br>);<br></code></pre></td></tr></table></figure><p>命令中就给几个列附了非空约束    </p><h2 id="UNIQUE"><a href="#UNIQUE" class="headerlink" title="UNIQUE"></a>UNIQUE</h2><p>唯一性约束可以使该列是唯一的，不存在其他列和该列相同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> COMPANY3(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   NAME           TEXT    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   AGE            <span class="hljs-type">INT</span>     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span>,<br>   ADDRESS        <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>   SALARY         <span class="hljs-type">REAL</span>    <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">50000.00</span><br>);<br></code></pre></td></tr></table></figure><h2 id="PRIMARY-KEY"><a href="#PRIMARY-KEY" class="headerlink" title="PRIMARY KEY"></a>PRIMARY KEY</h2><p>主键约束用于数据库中每条记录的唯一表标识，在设置时UNIQUE可以为多个，但PRIMARY KEY只能有一个，同时可以使用主键来引用表中的行，也可以通过将主键设置为其他表的外键来创建表之间的关联。</p><p>在前两个例子中，ID都是被设置为主键的。</p><h2 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h2><p>外键约束就是该表的制定列中的值必须匹配到另一个表的某一行中出现的值。通常用来建立两个表中的连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> DEPARTMENT1(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   DEPT           <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   EMP_ID         <span class="hljs-type">INT</span>      <span class="hljs-keyword">references</span> COMPANY2(ID)<br>);<br></code></pre></td></tr></table></figure><p>这里是在建立好COMPANY2的基础上建立的DEPARTMENT1，也就是说EMP_ID依托于COMPANY2的ID，EMP_ID就是外键。</p><h2 id="CHECK"><a href="#CHECK" class="headerlink" title="CHECK"></a>CHECK</h2><p>检查约束就是用来限制该列中的值的，在给列添加值时，符合条件的就会被添加，如果为false（不符合条件）就无法输入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> COMPANY4(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   NAME           TEXT    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   AGE            <span class="hljs-type">INT</span>     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   ADDRESS        <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>   SALARY         <span class="hljs-type">REAL</span>    <span class="hljs-keyword">CHECK</span>(SALARY <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>)<br>);<br></code></pre></td></tr></table></figure><p>我们这里建立的COMPANY4中给SALARY一个检查约束，条件是值大于0，也就是说只有大于0的值会被输入，反之不会。</p><h2 id="EXCLUSION"><a href="#EXCLUSION" class="headerlink" title="EXCLUSION"></a>EXCLUSION</h2><p>排他约束确保如果使用指定的运算符在指定列或表达式上比较任意两行，至少其中一个运算符比较将返回false或null。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> COMPANY5(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   NAME           TEXT,<br>   AGE            <span class="hljs-type">INT</span>,<br>   ADDRESS        <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>   SALARY         <span class="hljs-type">REAL</span>,<br>   EXCLUDE <span class="hljs-keyword">USING</span> gist<br>   (NAME <span class="hljs-keyword">WITH</span> <span class="hljs-operator">=</span>,  <span class="hljs-comment">-- 如果满足 NAME 相同，AGE 不相同则不允许插入，否则允许插入</span><br>   AGE <span class="hljs-keyword">WITH</span> <span class="hljs-operator">&lt;&gt;</span>)   <span class="hljs-comment">-- 其比较的结果是如果整个表达式返回 true，则不允许插入，否则允许</span><br>);<br></code></pre></td></tr></table></figure><p>USING gist 是用于构建和执行的索引一种类型。</p><p>这里需要注意的是，在使用这个SQL语句前记得用<code>CREATE EXTENSION IF NOT EXISTS btree_gist;</code>来开启扩展，不然会无法创建。</p><p>然后插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY5 <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Paul&#x27;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;California&#x27;</span>, <span class="hljs-number">20000.00</span> );<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY5 <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Paul&#x27;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;Texas&#x27;</span>, <span class="hljs-number">20000.00</span> );<br><span class="hljs-comment">-- 此条数据的 NAME 与第一条相同，且 AGE 与第一条也相同，故满足插入条件</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY5 <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Allen&#x27;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&#x27;California&#x27;</span>, <span class="hljs-number">20000.00</span> );<br><span class="hljs-comment">-- 此数据与上面数据的 NAME 相同，但 AGE 不相同，故不允许插入</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">ERROR:  conflicting key <span class="hljs-keyword">value</span> violates exclusion <span class="hljs-keyword">constraint</span> &quot;company7_name_age_excl&quot;<br>DETAIL:  Key (name, age)<span class="hljs-operator">=</span>(Paul, <span class="hljs-number">42</span>) conflicts <span class="hljs-keyword">with</span> existing key (name, age)<span class="hljs-operator">=</span>(Paul, <span class="hljs-number">32</span>).<br></code></pre></td></tr></table></figure><h2 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> some_name;<br></code></pre></td></tr></table></figure><p>如果不知道名称可以使用\d + table_name来查询</p><h1 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h1><h2 id="常见JOIN类型"><a href="#常见JOIN类型" class="headerlink" title="常见JOIN类型"></a>常见JOIN类型</h2><ul><li>CROSS JOIN </li><li>INNER JOIN</li><li>LEFT OUTER JOIN</li><li>RIGHT OUTER JOIN</li><li>FULL OUTER JOIN</li></ul><h2 id="预先准备"><a href="#预先准备" class="headerlink" title="预先准备"></a>预先准备</h2><p>导入数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> COMPANY(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   NAME           TEXT    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   AGE            <span class="hljs-type">INT</span>     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   ADDRESS        <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>   SALARY         <span class="hljs-type">REAL</span><br>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Paul&#x27;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;California&#x27;</span>, <span class="hljs-number">20000.00</span> );<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Allen&#x27;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;Texas&#x27;</span>, <span class="hljs-number">15000.00</span> );<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Teddy&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;Norway&#x27;</span>, <span class="hljs-number">20000.00</span> );<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;Mark&#x27;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;Rich-Mond &#x27;</span>, <span class="hljs-number">65000.00</span> );<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;David&#x27;</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&#x27;Texas&#x27;</span>, <span class="hljs-number">85000.00</span> );<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;Kim&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;South-Hall&#x27;</span>, <span class="hljs-number">45000.00</span> );<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;James&#x27;</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&#x27;Houston&#x27;</span>, <span class="hljs-number">10000.00</span> );<br></code></pre></td></tr></table></figure><p>然后用SELECT查看一下是否建立成功，结果如下</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coq"> id | <span class="hljs-type">name</span>  | <span class="hljs-type">age</span> | <span class="hljs-type">address</span>   | <span class="hljs-type">salary</span><br>----+-------+-----+-----------+--------<br>  <span class="hljs-number">1</span> | <span class="hljs-type">Paul</span>  |  <span class="hljs-type">32</span> | <span class="hljs-type">California</span>|  <span class="hljs-type">20000</span><br>  <span class="hljs-number">2</span> | <span class="hljs-type">Allen</span> |  <span class="hljs-type">25</span> | <span class="hljs-type">Texas</span>     |  <span class="hljs-type">15000</span><br>  <span class="hljs-number">3</span> | <span class="hljs-type">Teddy</span> |  <span class="hljs-type">23</span> | <span class="hljs-type">Norway</span>    |  <span class="hljs-type">20000</span><br>  <span class="hljs-number">4</span> | <span class="hljs-type">Mark</span>  |  <span class="hljs-type">25</span> | <span class="hljs-type">Rich</span>-Mond |  <span class="hljs-type">65000</span><br>  <span class="hljs-number">5</span> | <span class="hljs-type">David</span> |  <span class="hljs-type">27</span> | <span class="hljs-type">Texas</span>     |  <span class="hljs-type">85000</span><br>  <span class="hljs-number">6</span> | <span class="hljs-type">Kim</span>   |  <span class="hljs-type">22</span> | <span class="hljs-type">South</span>-Hall|  <span class="hljs-type">45000</span><br>  <span class="hljs-number">7</span> | <span class="hljs-type">James</span> |  <span class="hljs-type">24</span> | <span class="hljs-type">Houston</span>   |  <span class="hljs-type">10000</span><br>(<span class="hljs-number">7</span> rows)<br></code></pre></td></tr></table></figure><p>接下来插入几条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;Paul&#x27;</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&#x27;Houston&#x27;</span>, <span class="hljs-number">20000.00</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;James&#x27;</span>, <span class="hljs-number">44</span>, <span class="hljs-string">&#x27;Norway&#x27;</span>, <span class="hljs-number">5000.00</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> COMPANY <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;James&#x27;</span>, <span class="hljs-number">45</span>, <span class="hljs-string">&#x27;Texas&#x27;</span>, <span class="hljs-number">5000.00</span>);<br></code></pre></td></tr></table></figure><p>这时的结果为</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coq"> id | <span class="hljs-type">name</span>  | <span class="hljs-type">age</span> | <span class="hljs-type">address</span>      | <span class="hljs-type">salary</span><br> ----+-------+-----+--------------+--------<br>   <span class="hljs-number">1</span> | <span class="hljs-type">Paul</span>  |  <span class="hljs-type">32</span> | <span class="hljs-type">California</span>   |  <span class="hljs-type">20000</span><br>   <span class="hljs-number">2</span> | <span class="hljs-type">Allen</span> |  <span class="hljs-type">25</span> | <span class="hljs-type">Texas</span>        |  <span class="hljs-type">15000</span><br>   <span class="hljs-number">3</span> | <span class="hljs-type">Teddy</span> |  <span class="hljs-type">23</span> | <span class="hljs-type">Norway</span>       |  <span class="hljs-type">20000</span><br>   <span class="hljs-number">4</span> | <span class="hljs-type">Mark</span>  |  <span class="hljs-type">25</span> | <span class="hljs-type">Rich</span>-Mond    |  <span class="hljs-type">65000</span><br>   <span class="hljs-number">5</span> | <span class="hljs-type">David</span> |  <span class="hljs-type">27</span> | <span class="hljs-type">Texas</span>        |  <span class="hljs-type">85000</span><br>   <span class="hljs-number">6</span> | <span class="hljs-type">Kim</span>   |  <span class="hljs-type">22</span> | <span class="hljs-type">South</span>-Hall   |  <span class="hljs-type">45000</span><br>   <span class="hljs-number">7</span> | <span class="hljs-type">James</span> |  <span class="hljs-type">24</span> | <span class="hljs-type">Houston</span>      |  <span class="hljs-type">10000</span><br>   <span class="hljs-number">8</span> | <span class="hljs-type">Paul</span>  |  <span class="hljs-type">24</span> | <span class="hljs-type">Houston</span>      |  <span class="hljs-type">20000</span><br>   <span class="hljs-number">9</span> | <span class="hljs-type">James</span> |  <span class="hljs-type">44</span> | <span class="hljs-type">Norway</span>       |   <span class="hljs-type">5000</span><br>  <span class="hljs-number">10</span> | <span class="hljs-type">James</span> |  <span class="hljs-type">45</span> | <span class="hljs-type">Texas</span>        |   <span class="hljs-type">5000</span><br>(<span class="hljs-number">10</span> rows)<br></code></pre></td></tr></table></figure><p>然后创建表DEPARTMENT</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> DEPARTMENT(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   DEPT           <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   EMP_ID         <span class="hljs-type">INT</span>      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>);<br></code></pre></td></tr></table></figure><p>插入三条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> DEPARTMENT (ID, DEPT, EMP_ID) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;IT Billing&#x27;</span>, <span class="hljs-number">1</span> );<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> DEPARTMENT (ID, DEPT, EMP_ID) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Engineering&#x27;</span>, <span class="hljs-number">2</span> );<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> DEPARTMENT (ID, DEPT, EMP_ID) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Finance&#x27;</span>, <span class="hljs-number">7</span> );<br></code></pre></td></tr></table></figure><p>这时DEPARTMENT表中的记录为</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section"> id | dept        | emp_id</span><br><span class="hljs-section">----+-------------+--------</span><br><span class="hljs-code">  1 | IT Billing  |  1</span><br><span class="hljs-code">  2 | Engineering |  2</span><br><span class="hljs-code">  3 | Finance     |  7</span><br></code></pre></td></tr></table></figure><h2 id="CROSS-JOIN"><a href="#CROSS-JOIN" class="headerlink" title="CROSS JOIN"></a>CROSS JOIN</h2><p>交叉连接（CROSS JOIN），把第一个表中的每一行和第二个表中的每一行进行匹配，如果两个输入表分别有x和有行，则结果有x*y行。</p><p>提示：由于CROSS JOIN可能会产生很大的表，为安全起见还是需要在合适的时候去使用。</p><p>基础语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> table2 ...<br></code></pre></td></tr></table></figure><p>基于上面的两个表可以写下面的连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> DEPARTMENT;<br></code></pre></td></tr></table></figure><p>退出的时候按<code>q</code>就可以。</p><h2 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h2><p>内连接（INNER JOIN）根据连接谓词结合两个表（table1、table2）的列值来创建一个新的结果表。查询结果把table1的每一行和table2的每一行进行比较，找到满足条件的行进行匹配。</p><p>同时INNER JOIN也是默认的连接类型。</p><p>基本语法如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> table1.column1, table2.column2...<br><span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> table2<br><span class="hljs-keyword">ON</span> table1.common_filed = table2.common_field;<br></code></pre></td></tr></table></figure><p>基于上面的表可以写下面的连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> DEPARTMENT <span class="hljs-keyword">ON</span> COMPANY.ID <span class="hljs-operator">=</span> DEPARTMENT.EMP_ID;<br></code></pre></td></tr></table></figure><h2 id="LEFT-RIGHT-OUTER-JOIN"><a href="#LEFT-RIGHT-OUTER-JOIN" class="headerlink" title="LEFT&#x2F;RIGHT OUTER JOIN"></a>LEFT&#x2F;RIGHT OUTER JOIN</h2><p>这里熟悉MySQL中JOIN的一般会有一个疑问，通常我们会直接使用LEFT&#x2F;RIGHT JOIN来表示左右连接，这里为什么会有一个OUTER。都是SQL类型的命令为什么还会有差别？</p><p>实际上，通过查询相关资料发现，OUTER在这里添加是为了体现语句的可读性，因为从翻译角度看，左右连接是并不是官方名称。官方称作左右外连接，这个外就是用OUTER在语句中体现。</p><p>所以在使用过程中，我们可以直接忽略OUTER，熟悉MySQL的应该会直接忽略这个，毕竟操作没有任何影响，只是可读性的问题。</p><p>基本语法如下：</p><ul><li>左连接<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">ON</span> conditional_expression ...<br></code></pre></td></tr></table></figure></li><li>右连接<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">ON</span> conditional_expression ...<br></code></pre></td></tr></table></figure>基于上面的表可以写下面的两个连接<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">LEFT</span>  <span class="hljs-keyword">JOIN</span> DEPARTMENT <span class="hljs-keyword">ON</span> COMPANY.ID <span class="hljs-operator">=</span> DEPARTMENT.EMP_ID;<br><span class="hljs-keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">RIGHT</span>  <span class="hljs-keyword">JOIN</span> DEPARTMENT <span class="hljs-keyword">ON</span> COMPANY.ID <span class="hljs-operator">=</span> DEPARTMENT.EMP_ID;<br></code></pre></td></tr></table></figure></li></ul><h2 id="OUTER-JOIN"><a href="#OUTER-JOIN" class="headerlink" title="OUTER JOIN"></a>OUTER JOIN</h2><p>返回table1和table2中所有行，如果任意一表中没有匹配的行，对应的列将返回NULL。</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">FULL</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">ON</span> conditional_expression ...<br></code></pre></td></tr></table></figure><p>基于上面的表可以写下面的连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="hljs-keyword">FROM</span> COMPANY <span class="hljs-keyword">FULL</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> DEPARTMENT <span class="hljs-keyword">ON</span> COMPANY.ID <span class="hljs-operator">=</span> DEPARTMENT.EMP_ID;<br></code></pre></td></tr></table></figure><h1 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h1><p>UNION用于将两个或多个SELECT语句进行连接，合并输出其结果</p><p>UNION需要注意的是每个SELECT语句都必须有相同的列，列必须是相同的数据类型，每个SELECT语句的列顺序必须相同。</p><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1 [, column2 ]<br><span class="hljs-keyword">FROM</span> table1 [, table2 ]<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>]<br><br><span class="hljs-keyword">UNION</span><br><br><span class="hljs-keyword">SELECT</span> column1 [, column2 ]<br><span class="hljs-keyword">FROM</span> table1 [, table2 ]<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>]<br></code></pre></td></tr></table></figure><h2 id="UNION-ALL"><a href="#UNION-ALL" class="headerlink" title="UNION ALL"></a>UNION ALL</h2><p>如果需要取重复值的话，可以使用<code>UNION ALL</code>语句</p><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1 [, column2 ]<br><span class="hljs-keyword">FROM</span> table1 [, table2 ]<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>]<br><br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><br><span class="hljs-keyword">SELECT</span> column1 [, column2 ]<br><span class="hljs-keyword">FROM</span> table1 [, table2 ]<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>]<br></code></pre></td></tr></table></figure><p>好咯，今天就先学到这里吧~该去刷leetcode了，万恶的leetcode😒</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL学习记录——第一天</title>
    <link href="/2024/08/02/postgresql-study-first-day/"/>
    <url>/2024/08/02/postgresql-study-first-day/</url>
    
    <content type="html"><![CDATA[<p>昨天已经完成了PostgreSQL（后续和其他平台一样把这个简称为PG）的安装，今天就来逐步学吧。至于为什么从MySQL转移到PG，主要是因为以下几点：</p><ol><li>PG支持更多的数据类型</li><li>PG在所有配置上均支持ACID，而MySQL只能在部分情况下支持</li><li>PostgreSQL使用了多版本并发控制（MVCC）减少了出现死锁的概率</li><li>PostgreSQL支持更多的索引类型</li></ol><p>说完上面的就不得不提到简历上写了会MySQL然后被面试官无数次拷打的经历了（MongoDB我也写了，没人问，我还准备了蛮多的嘞）。</p><p>首先就是ACID是哪四个，莫名感觉是所有面试官都会想问。</p><p>其次是锁相关，S锁、X锁、IS锁、IX锁、未提交读、提交读、可重复读、串行化，呕。</p><p>然后就说索引B树B+树，前段时间面试才被问到过这个。</p><p>然后正式进入学习记录。</p><figure>  <img src="/2024/08/02/postgresql-study-first-day/start%20psql.png" class="" title="start PG">  <figcaption>start PG</figcaption></figure><p>在开启SQL Shell（psql）之前记得在cmd里打开PG服务。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>这部分内容太多太杂，就把比MySQL支持的更多的数据类型大概记一下吧（我自己按照资料写的，如果有缺少或者多了麻烦各位补充啊）</p><table><thead><tr><th>PostgreSQL数据类型</th><th>描述</th></tr></thead><tbody><tr><td>SERIAL</td><td>自增整数</td></tr><tr><td>BIGSERIAL</td><td>大范围自增整数</td></tr><tr><td>MONEY</td><td>货币金额</td></tr><tr><td>UUID</td><td>通用唯一标识符</td></tr><tr><td>CIDR</td><td>IPv4或IPv6网络地址</td></tr><tr><td>INET</td><td>IPv4或IPv6主机地址</td></tr><tr><td>MACADDR</td><td>MAC地址</td></tr><tr><td>BIT</td><td>定长位串</td></tr><tr><td>BIT VARYING</td><td>变长位串</td></tr><tr><td>BOX</td><td>平面中的矩形框</td></tr><tr><td>LINE</td><td>无限长的线</td></tr><tr><td>LSEG</td><td>线段</td></tr><tr><td>PATH</td><td>闭合路径</td></tr><tr><td>POINT</td><td>平面中的点</td></tr><tr><td>POLYGON</td><td>闭合的平面多边形</td></tr><tr><td>CIRCLE</td><td>平面中的圆</td></tr><tr><td>INTERVAL</td><td>时间间隔</td></tr><tr><td>TSVECTOR</td><td>文本搜索文档</td></tr><tr><td>TSQUERY</td><td>文本搜索查询</td></tr><tr><td>XML</td><td>XML数据</td></tr><tr><td>JSON</td><td>JSON数据</td></tr><tr><td>JSONB</td><td>二进制JSON数据，可索引</td></tr><tr><td>HSTORE</td><td>键值对存储</td></tr></tbody></table><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p><code>CREATE DATABASE dbname;</code></p><h2 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h2><p><code>\l</code> 查看数据库（莫名想到了Linux的ls -l）</p><p><code>\c</code> + <code>dbname</code> 进入数据库</p><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p><code>DROP DATABASE [IF EXISTS] name;</code></p><p>删除需要root权限，普通用户无法删除</p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h2 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name(<br>   column1 datatype,<br>   column2 datatype,<br>   column3 datatype,<br>   .....<br>   columnN datatype,<br>   <span class="hljs-keyword">PRIMARY</span> KEY( 一个或多个列 )<br>);<br></code></pre></td></tr></table></figure><p>例子</p><figure>  <img src="/2024/08/02/postgresql-study-first-day/table%20EX.png" class="" title="table EX">  <figcaption>table EX</figcaption></figure><p><code>\d</code>是查看当前已经存在的表格</p><p><code>\d tablename</code>是查看表格详情</p><figure>  <img src="/2024/08/02/postgresql-study-first-day/%E6%9F%A5%E7%9C%8B%E8%AF%A6%E6%83%85.png" class="" title="查看详情">  <figcaption>查看详情</figcaption></figure><h2 id="删除表格"><a href="#删除表格" class="headerlink" title="删除表格"></a>删除表格</h2><p><code>DROP TABLE table_name;</code></p><h1 id="PG模式（SCHEMA）"><a href="#PG模式（SCHEMA）" class="headerlink" title="PG模式（SCHEMA）"></a>PG模式（SCHEMA）</h1><p>第一眼看感觉有点像事务，但是事务是遵循ACID原则的并且通过MVCC来建立隔离，两者的逻辑不一样。</p><p>模式中可以包括视图、索引、数据类型、函数和操作等。</p><p>相同的名称可以运用于不同的模式而不报错，for example schema1和myschema都包含mytable的表。</p><p>模式的优势：</p><ul><li>允许多个用户操作数据库而不相互干扰</li><li>将数据库对象组织成逻辑便于管理（我的理解是我在做某个东西的时候我将一张表三个视图组织在一起，这个组织就可以一起被操作同时还可以单独操作，然后也可以对整个模式里的对象进行批量操作）</li><li>第三方应用的对象可以放在独立的模式中，这样它们就不会与其他对象的名称发生冲突。</li></ul><h2 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h2><p>语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SCHEMA myschema (<br>...<br>);<br></code></pre></td></tr></table></figure><p>创建表的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> myschema.mytable (<br>    column1 datatype1,<br>    column2 datatype2,<br>    ...<br>);<br></code></pre></td></tr></table></figure><p>上述语法是在一个叫myschema的模式下创建了一个叫mytable的表</p><p>例子</p><figure>  <img src="/2024/08/02/postgresql-study-first-day/create%20schema.png" class="" title="create schema">  <figcaption>create schema</figcaption></figure><p>这里我们建立了一个模式和一个表，中间由于手误少了一个’,’。</p><h2 id="删除模式"><a href="#删除模式" class="headerlink" title="删除模式"></a>删除模式</h2><p>删除一个空的模式（里面的对象已经全部被删除了）</p><p><code>DROP SCHEMA myschema;</code></p><p>删除一个模式及其下面的对象</p><p><code>DROP SCHEMA myschema CASSADE;</code></p><h1 id="INSERT-INTO-语句"><a href="#INSERT-INTO-语句" class="headerlink" title="INSERT INTO 语句"></a>INSERT INTO 语句</h1><p>语法如下</p><p><code>INSERT INTO TABLE_NAME (column1, column2, column3,...columnN) VALUES (value1, value2, value3,...valueN);</code></p><p>需要注意的是column和value需要数量一样，一一对应</p><p>对所有字段均添加值的语法如下</p><p><code>INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);</code></p><table><thead><tr><th>序号</th><th>输出信息&amp;描述</th></tr></thead><tbody><tr><td>1</td><td>INSERT oid 1 直插入一行且表中具备OID的返回信息，那么oid就分配给被插入行</td></tr><tr><td>2</td><td>INSERT 0 # 插入多行，#为插入行数</td></tr></tbody></table><p>例子</p><p>这里先创建一个表</p><figure>  <img src="/2024/08/02/postgresql-study-first-day/create%20company.png" class="" title="create table">  <figcaption>create table</figcaption></figure><figure>  <img src="/2024/08/02/postgresql-study-first-day/insert%20into.png" class="" title="insert into">  <figcaption>insert into</figcaption></figure><p>这里我们从上到下分别来看</p><ul><li>给表里插入数据</li><li>给表里插入忽略SALARY的数据</li><li>插入语句 JOIN_DATE 字段使用 DEFAULT 子句来设置默认值，而不是指定值</li><li>插入多行</li><li>查询数据</li></ul><h1 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h1><p>这里就不多说了，不会的拖出去乱棍打死。和MySQL之类的一摸一样。</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>PG的运算符一般用在<code>WHERE</code>中<br>有四个</p><ul><li>算术运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>按位运算符</li></ul><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><figure>  <img src="/2024/08/02/postgresql-study-first-day/%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6.png" class="" title="算术运算符">  <figcaption>算术运算符</figcaption></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td><td>(a &#x3D; b) 为 false。</td></tr><tr><td>!&#x3D;</td><td>不等于</td><td>(a !&#x3D; b) 为 true。</td></tr><tr><td>&lt;&gt;</td><td>不等于</td><td>(a &lt;&gt; b) 为 true。</td></tr><tr><td>&gt;</td><td>大于</td><td>(a &gt; b) 为 false。</td></tr><tr><td>&lt;</td><td>小于</td><td>(a &lt; b) 为 true。</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td><td>(a &gt;&#x3D; b) 为 false。</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td><td>(a &lt;&#x3D; b) 为 true。</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th>序号</th><th>运算符 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>AND</strong></td></tr><tr><td></td><td>逻辑与运算符。如果两个操作数都非零，则条件为真。</td></tr><tr><td></td><td>PostgresSQL 中的 WHERE 语句可以用 AND 包含多个过滤条件。</td></tr><tr><td>2</td><td><strong>NOT</strong></td></tr><tr><td></td><td>逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td></tr><tr><td></td><td>PostgresSQL 有 NOT EXISTS, NOT BETWEEN, NOT IN 等运算符。</td></tr><tr><td>3</td><td><strong>OR</strong></td></tr><tr><td></td><td>逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td></tr><tr><td></td><td>PostgresSQL 中的 WHERE 语句可以用 OR 包含多个过滤条件。</td></tr></tbody></table><h3 id="三值逻辑系统"><a href="#三值逻辑系统" class="headerlink" title="三值逻辑系统"></a>三值逻辑系统</h3><table><thead><tr><th>a</th><th>b</th><th>a AND b</th><th>a OR b</th></tr></thead><tbody><tr><td>TRUE</td><td>TRUE</td><td>TRUE</td><td>TRUE</td></tr><tr><td>TRUE</td><td>FALSE</td><td>FALSE</td><td>TRUE</td></tr><tr><td>TRUE</td><td>NULL</td><td>NULL</td><td>TRUE</td></tr><tr><td>FALSE</td><td>FALSE</td><td>FALSE</td><td>FALSE</td></tr><tr><td>FALSE</td><td>NULL</td><td>FALSE</td><td>NULL</td></tr><tr><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr></tbody></table><table><thead><tr><th>a</th><th>NOT a</th></tr></thead><tbody><tr><td>TRUE</td><td>FALSE</td></tr><tr><td>FALSE</td><td>TRUE</td></tr><tr><td>NULL</td><td>NULL</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><figure>  <img src="/2024/08/02/postgresql-study-first-day/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.png" class="" title="位运算符">  <figcaption>位运算符</figcaption></figure><h3 id="按位运算符"><a href="#按位运算符" class="headerlink" title="按位运算符"></a>按位运算符</h3><figure>  <img src="/2024/08/02/postgresql-study-first-day/%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.png" class="" title="按位运算符">  <figcaption>按位运算符</figcaption></figure><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>基本语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, columnN<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">CONDITION</span> <span class="hljs-operator">|</span> EXPRESSION];<br></code></pre></td></tr></table></figure><h2 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h2><p>根据一个指定条件来读取数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, columnN<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> SINGLE <span class="hljs-keyword">VALUE</span> MATCHTING EXPRESSION;<br></code></pre></td></tr></table></figure><h2 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> numerical_expression <span class="hljs-keyword">as</span>  OPERATION_NAME<br>[<span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">CONDITION</span>] ;<br></code></pre></td></tr></table></figure><p>PG还有内置计算函数（这个好像都有吧sum、avg这些）</p><h2 id="日期表达式"><a href="#日期表达式" class="headerlink" title="日期表达式"></a>日期表达式</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>;<br></code></pre></td></tr></table></figure><p>返回当前日期</p><h1 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h1><p>这部分内容和MySQL差不多<br>WHERE的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, columnN<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> [condition1]<br></code></pre></td></tr></table></figure><p>还可以使用比较运算符或逻辑运算符<br>AND, OR, NOT NULL, LIKE, NOT IN, BETWEEN, 子查询</p><h1 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h1><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> table_name<br><span class="hljs-keyword">SET</span> column1 <span class="hljs-operator">=</span> value1, column2 <span class="hljs-operator">=</span> value2...., columnN <span class="hljs-operator">=</span> valueN<br><span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">condition</span>];<br></code></pre></td></tr></table></figure><h1 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h1><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">condition</span>];<br></code></pre></td></tr></table></figure><h1 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h1><p>和MySQL一样，都是进行匹配<br>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;XXXX%&#x27;</span>;<br>或者<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%XXXX%&#x27;</span>;<br>或者<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;XXXX_&#x27;</span>;<br>或者<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_XXXX&#x27;</span>;<br>或者<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_XXXX_&#x27;</span>;<br></code></pre></td></tr></table></figure><h1 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h1><p>作用就是限制查询条数</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, columnN<br><span class="hljs-keyword">FROM</span> table_name<br>LIMIT [<span class="hljs-keyword">no</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">rows</span>]<br></code></pre></td></tr></table></figure><p>和OFFSET一起用的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, columnN <br><span class="hljs-keyword">FROM</span> table_name<br>LIMIT [<span class="hljs-keyword">no</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">rows</span>] <span class="hljs-keyword">OFFSET</span> [<span class="hljs-type">row</span> num]<br></code></pre></td></tr></table></figure><h1 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h1><p><code>ORDER BY</code>是用来对一列或多列进行排序的（升序或降序）</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span><span class="hljs-operator">-</span>list<br><span class="hljs-keyword">FROM</span> table_name<br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>]<br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column1, column2, .. columnN] [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>];<br></code></pre></td></tr></table></figure><p>ASC 表示升序，DESC 表示降序。</p><h1 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h1><p><code>GROUP BY</code>用来和<code>SELECT</code>语句一起使用，对数据进行分组。</p><p><code>GROUP BY</code> 在一个 <code>SELECT</code> 语句中，放在 <code>WHERE</code> 子句的后面，<code>ORDER BY</code> 子句的前面。</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span><span class="hljs-operator">-</span>list<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> [ conditions ]<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> column1, column2....columnN<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column1, column2....columnN<br></code></pre></td></tr></table></figure><h1 id="WITH"><a href="#WITH" class="headerlink" title="WITH"></a>WITH</h1><p>WITH主要用来辅助将复杂的查询拆分成简单的表单，便于阅读，也可以当作为查询存在的临时表。</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span><br>   name_for_summary_data <span class="hljs-keyword">AS</span> (<br>      <span class="hljs-keyword">SELECT</span> Statement)<br>   <span class="hljs-keyword">SELECT</span> columns<br>   <span class="hljs-keyword">FROM</span> name_for_summary_data<br>   <span class="hljs-keyword">WHERE</span> conditions <span class="hljs-operator">&lt;=&gt;</span> (<br>      <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span><br>      <span class="hljs-keyword">FROM</span> name_for_summary_data)<br>   [<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> columns]<br></code></pre></td></tr></table></figure><p><code>name_for_summary_data</code> 是 WITH 子句的名称，<code>name_for_summary_data</code> 可以与现有的表名相同，并且具有优先级。</p><p>可以在 WITH 中使用数据 INSERT, UPDATE 或 DELETE 语句，允许您在同一个查询中执行多个不同的操作。</p><h2 id="WITH-递归"><a href="#WITH-递归" class="headerlink" title="WITH 递归"></a>WITH 递归</h2><p>在 WITH 子句中可以使用自身输出的数据。</p><p>公用表表达式 (CTE) 具有一个重要的优点，那就是能够引用其自身，从而创建递归 CTE。递归 CTE 是一个重复执行初始 CTE 以返回数据子集直到获取完整结果集的公用表表达式。</p><h1 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h1><p>HAVING子句用来筛选分组后的各组数据。</p><p>WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。</p><p>HAVING在SELECT语句中的位置</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">FROM</span><br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br><span class="hljs-keyword">HAVING</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br></code></pre></td></tr></table></figure><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2<br><span class="hljs-keyword">FROM</span> table1, table2<br><span class="hljs-keyword">WHERE</span> [ conditions ]<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> column1, column2<br><span class="hljs-keyword">HAVING</span> [ conditions ]<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column1, column2<br></code></pre></td></tr></table></figure><h1 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h1><p>和<code>SELECT</code>一起用，用于去重</p><p>基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> column1, column2,.....columnN<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> [<span class="hljs-keyword">condition</span>]<br></code></pre></td></tr></table></figure><p>好了，基本的操作到这里也就结束了，完结撒花~</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL安装记录及集群初始化失败问题解决</title>
    <link href="/2024/08/01/install-postgreSQL/"/>
    <url>/2024/08/01/install-postgreSQL/</url>
    
    <content type="html"><![CDATA[<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>Windows 11</p><p>PostgreSQL 16.3</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>下载PostgreSQL可以直接通过官网<a href="https://www.postgresql.org/">https://www.postgresql.org/</a></p><p>进入官网后点击图片中的Download，也可以通过Navbar中的Download直接进入对应页面。由于网络不稳定图片中的链接可能会不稳定，所以可以通过第二种方法进入对应页面，两种方法所到达的是同一页面。</p><p>![Download Page](&#x2F;img&#x2F;Download Page.png)</p><p>选择对应的系统进行下载，我这边选择的是Windows，所以直接进入Windows的页面。</p><p>进入后直接点击Download the Installer，进去后再次选择对应的系统和你想要的版本。</p><p><img src="/../img/System%20choice.png" alt="Choice your System"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>这里必须要注意一个事情，如果说遇到了在快要完成的时候出现<br>Problem running post-install step. Installation may not complete correctly. The database cluster initialisation failed.<br>这时切记去看后面的说明，我会把我这么解决的说清楚。</p><p>打开下载好的exe文件后就是这个页面</p><p><img src="/../img/postSQL%20first%20setup.png" alt="First Pic"><br>在这一步记得改一下安装地址，最好别放在C盘（当然只有C盘的话当我没说）</p><p><img src="/../img/PostSQL%20second%20page.png" alt="Second Pic"></p><p><img src="/../img/Select%20Components.png" alt="Third Pic"><br>该图中四个模块我们一一来介绍一下：</p><ol><li><p>PostgreSQL Server</p><p> 该部分属于数据库系统的核心部分，负责处理数据库的存储、检索和管理操作。所有操作都是通过这个部分来进行的（谁不选头拧下来当球踢）。</p></li><li><p>pgAdmin 4</p><p> 一个功能强大的开源管理工具，提供了一个GUI来辅助用户进行各种操作。</p></li><li><p>Stack Builder</p><p> 这部分属于附加组件，为用户外提供了一些可以安装的模块，如PostGIS（地理信息系统扩展）、pgAgent（调度工具）、pgBouncer（连接池管理器）。</p></li><li><p>Command Line Tools</p><p> 这个是PostgreSQL提供的命令行工具，有多个工具组成</p><ul><li>psql：交互式SQL命令行工具，允许用户执行SQL查询和脚本。</li><li>pg_dump：用于备份数据库。</li><li>pg_restore：用于恢复数据库。</li><li>pg_ctl：用于启动、停止和重启PostgreSQL服务器。</li></ul><p> 这些工具适用于脚本化和自动化数据库管理任务，特别是在没有图形界面的环境中。</p></li></ol><p>这里的Data Directory是和我们前面设置的安装地址是捆绑的，如果改为其他盘会直接被修改。不过为了保险起见先查看一下再点Next。</p><p><img src="/../img/Data%20Directory.png" alt="alt text"><br>在这里我们需要注意的是这个密码是我们数据库管理员的密码，也有就是root用户密码。</p><p><img src="/img/Password.png" alt="Fifth Pic"></p><p>这里的端口直接默认然后继续。</p><p><img src="/img/Port.png" alt="Sixth Pic"></p><p>这里选好自己需要的语言</p><p><img src="/../img/Advanced%20Options.png" alt="Seventh Pic"><br>最后确定好安装信息就可以开始安装了。</p><p>这个如果不需要可以不打勾</p><p><img src="/../img/Stack%20Builder.png" alt="Eight Pic"></p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>用<code>Win</code> + <code>s</code>打开搜索找到这个软件。</p><p><img src="/../img/Open%20PgAdmin4.png" alt="First Pic"></p><p>成功安装的话这里会弹出让我们去填写密码的弹窗，如果没有点一下侧边栏的Servers。这里推荐重新创建一个密码，如果实在懒也可以使用我们root用户的</p><p><img src="/../img/Connect%20to%20Server.png" alt="Second Pic"></p><p>最后成功安装并检验成功就会得到这个页面</p><p><img src="/img/Finish.png" alt="Finish"></p><h1 id="后记——解决问题"><a href="#后记——解决问题" class="headerlink" title="后记——解决问题"></a>后记——解决问题</h1><p>在我查找资料过程中发现，国内外无数人在安装过程中都遇到了集群初始化失败的问题。这里我们需要明白一个事情，单纯的卸载重装没有用处（我重装两次都一样！气死我了！）</p><p>接下来我们就需要来完整的说明我们需要怎么去做。</p><ol><li>首先在我们卸载后需要清除我们的注册表win+r ，输入regedit.exe 回车，编辑&gt;查找&gt;输入postgresql&gt;删除相关内容（应该是两个）</li><li>关闭防火墙，如果用的火绒开启免打扰</li><li>输入<code>win</code>+<code>R</code>然后输入cmd，使用<code>Ctrl</code>+<code>Shift</code>+<code>Enter</code>通过管理员打开命令窗口</li><li>使用<code>net user postgres /delete</code>来删除可能已经存在的postgres</li><li>使用<code>net user /add postgres &lt;password&gt;</code>来建立用户，这里记得换成自己的password</li><li>使用<code>net localgroup administrators postgres /add</code>将 postgres 用户添加到管理员组</li><li>用<code>net localgroup &quot;power users&quot; postgres /add</code>将 postgres 用户添加到 Power Users 组</li><li>接下来直接找到我们前面下载的exe文件，右键然后选择<em><strong>以管理员身份运行</strong></em>。这里必须再次强调一点，使用这个方法的原因是因为直接使用命令行去运行exe文件依旧存在问题，所以选择跳出命令行去执行。这样理论上是可以完成安装，后续可以按照正常安装顺序去安装。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——Hash</title>
    <link href="/2024/08/01/Hash/"/>
    <url>/2024/08/01/Hash/</url>
    
    <content type="html"><![CDATA[<p>今天来说一下leetcode面试经典150题中哈希表部分的题</p><h1 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383 赎金信"></a>383 赎金信</h1><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code>，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p>示例 1：</p><p>输入：ransomNote &#x3D; “a”, magazine &#x3D; “b”</p><p>输出：false</p><p>示例 2：</p><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “ab”</p><p>输出：false</p><p>示例 3：</p><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “aab”</p><p>输出：true</p><p>提示：</p><p><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></p><p><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>看到题目第一眼，需要用hash来对元素进行统计</li><li>可以利用Counter()函数来实现统计</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canConstruct</span>(<span class="hljs-params">self, ransomNote: <span class="hljs-built_in">str</span>, magazine: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        cnt = Counter(magazine)<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> ransomNote:<br>            <span class="hljs-keyword">if</span> c <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> cnt <span class="hljs-keyword">or</span> cnt[c] == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            cnt[c] -= <span class="hljs-number">1</span><br>            <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(m + n)，执行时间54ms，消耗内存16.4MB</p><h1 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205 同构字符串"></a>205 同构字符串</h1><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，判断它们是否是同构的。</p><p>如果 <code>s</code> 中的字符可以按某种映射关系替换得到 <code>t</code> ，那么这两个字符串是同构的。</p><p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p><p>示例 1:</p><p>输入：s &#x3D; <code>&quot;egg&quot;</code>, t &#x3D; <code>&quot;add&quot;</code></p><p>输出：true</p><p>示例 2：</p><p>输入：s &#x3D; <code>&quot;foo&quot;</code>, t &#x3D; <code>&quot;bar&quot;</code></p><p>输出：false</p><p>示例 3：</p><p>输入：s &#x3D; <code>&quot;paper&quot;</code>, t &#x3D; <code>&quot;title&quot;</code></p><p>输出：true</p><p>提示：</p><p><code>1 &lt;= s.length &lt;= 5 * 104</code></p><p><code>t.length == s.length</code></p><p><code>s</code> 和 <code>t</code> 由任意有效的 ASCII 字符组成</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li>首先明确每个字符是需要和自己当前位置所对应的索引直接对应到另一字符串，说人话就是<code>i[1]</code>的对应到<code>j[1]</code>上。</li><li>在前面的基础上，需要一一对应也就可以转换为s的和t的两个交换位置后所形成的字符串并不会和原本的字符串不同，只是平移了</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isIsomorphic</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        h1 = &#123;&#125;<br>        h2 = &#123;&#125;<br>        <span class="hljs-keyword">for</span> sc, tc <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(s, t):<br>            <span class="hljs-keyword">if</span> (sc <span class="hljs-keyword">in</span> h1 <span class="hljs-keyword">and</span> h1[sc] != tc) <span class="hljs-keyword">or</span> (tc <span class="hljs-keyword">in</span> h2 <span class="hljs-keyword">and</span> h2[tc] != sc):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            h1[sc] = tc<br>            h2[tc] = sc<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间49ms，消耗内存16.4MB</p><h1 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290 单词规律"></a>290 单词规律</h1><p>给定一种规律 <code>pattern</code> 和一个字符串 <code>s</code> ，判断 <code>s</code> 是否遵循相同的规律。</p><p>这里的 遵循 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>s</code> 中的每个非空单词之间存在着双向连接的对应规律。</p><p>示例1:</p><p>输入: pattern &#x3D; <code>&quot;abba&quot;</code>, s &#x3D; <code>&quot;dog cat cat dog&quot;</code></p><p>输出: true</p><p>示例 2:</p><p>输入:pattern &#x3D; <code>&quot;abba&quot;</code>, s &#x3D; <code>&quot;dog cat cat fish&quot;</code></p><p>输出: false</p><p>示例 3:</p><p>输入: pattern &#x3D; <code>&quot;aaaa&quot;</code>, s &#x3D; <code>&quot;dog cat cat dog&quot;</code></p><p>输出: false</p><p>提示:</p><p><code>1 &lt;= pattern.length &lt;= 300</code></p><p><code>pattern</code> 只包含小写英文字母</p><p><code>1 &lt;= s.length &lt;= 3000</code></p><p><code>s</code> 只包含小写英文字母和 <code>&#39; &#39;</code></p><p><code>s</code> <strong>不包含</strong> 任何前导或尾随对空格</p><p><code>s</code> 中每个单词都被 <strong>单个空格</strong> 分隔</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ol><li>首先我们需要将我们s中的单词进行分割，然后再开始匹配</li><li>后续匹配思路和前一题一样</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordPattern</span>(<span class="hljs-params">self, pattern: <span class="hljs-built_in">str</span>, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        words = s.split(<span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pattern) != <span class="hljs-built_in">len</span>(words):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        h1 = &#123;&#125;<br>        h2 = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, word <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(pattern, words):<br>            <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> h1 <span class="hljs-keyword">and</span> h1[i] != word) <span class="hljs-keyword">or</span> (word <span class="hljs-keyword">in</span> h2 <span class="hljs-keyword">and</span> h2[word] != i):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            h1[i] = word<br>            h2[word] = i<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(m + n)，执行时间45ms，消耗内存16.3MB</p><h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242 有效的字母异位词"></a>242 有效的字母异位词</h1><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。</p><p>注意：若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code> 互为字母异位词。</p><p>示例 1:</p><p>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”</p><p>输出: true</p><p>示例 2:</p><p>输入: s &#x3D; “rat”, t &#x3D; “car”</p><p>输出: false</p><p>提示:</p><p><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></p><p><code>s</code> 和 <code>t</code> 仅包含小写字母</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><p>用一个defaultdict存储s中的数量，如果t中存在就减少一个，逐个匹配</p><h3 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h3><p>用一个hash表来存储所有的字符和数量，一一匹配，存在就-1。最后记得delete我们的hash并输出结果</p><h3 id="第一版代码"><a href="#第一版代码" class="headerlink" title="第一版代码"></a>第一版代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAnagram</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) != <span class="hljs-built_in">len</span>(t):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        dic = defaultdict(<span class="hljs-built_in">int</span>)<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>            dic[c] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> t:<br>            dic[c] -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> dic.values():<br>            <span class="hljs-keyword">if</span> val != <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="第二版代码"><a href="#第二版代码" class="headerlink" title="第二版代码"></a>第二版代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isAnagram</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) != <span class="hljs-built_in">len</span>(t):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        char_count = &#123;&#125;<br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:<br>            char_count[char] = char_count.get(char, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> t:<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> char_count:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            char_count[char] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> char_count[char] == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">del</span> char_count[char]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(char_count) == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="第一版-1"><a href="#第一版-1" class="headerlink" title="第一版"></a>第一版</h3><p>时间复杂度O(n)，执行时间44ms，消耗内存16.4MB</p><h3 id="第二版-1"><a href="#第二版-1" class="headerlink" title="第二版"></a>第二版</h3><p>时间复杂度O(n)，执行时间50ms，消耗内存16.3MB</p><h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49 字母异位词分组"></a>49 字母异位词分组</h1><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p>示例 1:</p><p>输入: strs &#x3D; <code>[&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code></p><p>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</p><p>示例 2:</p><p>输入: strs &#x3D; <code>[&quot;&quot;]</code></p><p>输出: [[“”]]</p><p>示例 3:</p><p>输入: strs &#x3D; <code>[&quot;a&quot;]</code></p><p>输出: [[“a”]]</p><p>提示：</p><p><code>1 &lt;= strs.length &lt;= 104</code></p><p><code>0 &lt;= strs[i].length &lt;= 100</code></p><p><code>strs[i]</code> 仅包含小写字母</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><ol><li>见到题目第一时间想到两件事情，第一用hash存储键值对，和前面的题类似用值来进行匹配；第二字母异构意味着两个“单词”之间的字母都是一样的，也就是说经过排序可以得到相同的东西</li><li>通过sorted进行排序后，该字符将之间转换为按照字母顺序排序的字符。这时后续如果还存在和他一样字符就会被加入到hash中，最后我们直接忽略key，输出values就可以得到预期结果</li></ol><p>提示：这里我们使用defaultdict(list)是需要利用list作为默认值，会在不存在的键上初始化一个默认值。而我们使用{}字典则不会这样做，会造成测试样例中strs为空的情况下运行失败。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]:<br>        <span class="hljs-built_in">dict</span> = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> strs:<br>            tmp = <span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">sorted</span>(s))<br>            <span class="hljs-keyword">if</span> tmp <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>:<br>                <span class="hljs-built_in">dict</span>[tmp].append(s)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">dict</span>[tmp] = [s]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>.values())<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(m * n log n)，执行时间58ms，消耗内存19.1MB</p><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1 两数之和"></a>1 两数之和</h1><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <code>target</code>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</p><p>输出：[0,1]</p><p>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</p><p>示例 2：</p><p>输入：nums &#x3D; [3,2,4], target &#x3D; 6</p><p>输出：[1,2]</p><p>示例 3：</p><p>输入：nums &#x3D; [3,3], target &#x3D; 6</p><p>输出：[0,1]</p><p>提示：</p><p><code>2 &lt;= nums.length &lt;= 104</code></p><p><code>-109 &lt;= nums[i] &lt;= 109</code></p><p><code>-109 &lt;= target &lt;= 109</code></p><p><strong>只会存在一个有效答案</strong></p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>需要两个数也就是两个指针，当i指向的和j指向的加和能够等于target就直接输出</p><p>提示：用hash去做更快，该思路是用两个循环去做的。后续也会附上用hash去做的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] == target:<br>                    <span class="hljs-keyword">return</span> [i, j]<br></code></pre></td></tr></table></figure><p>用hash去做的代码如下，这个代码整体会比前面的按照题目直译去做快很多，如果只是为了对付笔试可以用前一个，但是面试最好还是用hash，毕竟面试官看你做leetcode第一题都只会用循环去硬怼印象分肯定大打折扣。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pyhton">class Solution:<br>    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:<br>        dic = &#123;&#125;<br>        for i, num in enumerate(nums):<br>            if target - num in dic:<br>                return [dic[target-num], i]<br>            dic[num] = i<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="双循环"><a href="#双循环" class="headerlink" title="双循环"></a>双循环</h3><p>时间复杂度$O(n^2)$，执行时间1824ms，消耗内存17MB</p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>时间复杂度O(n)，执行时间42ms，消耗内存17.6MB</p><h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202 快乐数"></a>202 快乐数</h1><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</p><p>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</p><p>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</p><p>如果 <code>n</code> 是 快乐数 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p>示例 1：</p><p>输入：n &#x3D; 19</p><p>输出：true</p><p>解释：</p><p>12 + 92 &#x3D; 82</p><p>82 + 22 &#x3D; 68</p><p>62 + 82 &#x3D; 100</p><p>12 + 02 + 02 &#x3D; 1</p><p>示例 2：</p><p>输入：n &#x3D; 2</p><p>输出：false</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 231 - 1</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><ol><li>一个函数用set去存储已经出现过的数字，每次循环时将n加入到这个set中</li><li>循环的停止条件为等于1和在seen中</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isHappy</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        seen = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">while</span> n != <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> n <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:<br>            seen.add(n)<br>            n = <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">int</span>(i)**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(n))<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间44ms，消耗内存16.3MB</p><h1 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219 存在重复元素 II"></a>219 存在重复元素 II</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，判断数组中是否存在两个 <strong>不同的索引</strong> <code>i</code> 和 <code>j</code> ，满足 <code>nums[i] == nums[j]</code> 且 <code>abs(i - j) &lt;= k</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3,1], k &#x3D; 3</p><p>输出：true</p><p>示例 2：</p><p>输入：nums &#x3D; [1,0,1,1], k &#x3D; 1</p><p>输出：true</p><p>示例 3：</p><p>输入：nums &#x3D; [1,2,3,1,2,3], k &#x3D; 2</p><p>输出：false</p><p>提示：</p><p><code>1 &lt;= nums.length &lt;= 105</code></p><p><code>-109 &lt;= nums[i] &lt;= 109</code></p><p><code>0 &lt;= k &lt;= 105</code></p><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>用哈希表存索引和值，只要然后按照题目所给的True判断条件写代码。不要忽略最后需要一个False，不然会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">containsNearbyDuplicate</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        dic = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> num <span class="hljs-keyword">in</span> dic <span class="hljs-keyword">and</span> i - dic[num] &lt;= k:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            dic[num] = i<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间91ms，消耗内存29.3MB</p><h1 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128 最长连续序列"></a>128 最长连续序列</h1><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>明确一点，当我们当前num的前一个数不在我们的hash中，我们就默认当前序列从num开始。那么结束便是当前num的后一个数不在hash中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestConsecutive</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        res = <span class="hljs-number">0</span><br>        num_count = <span class="hljs-built_in">set</span>(nums)<br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> num_count:<br>            <span class="hljs-keyword">if</span> (num - <span class="hljs-number">1</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> num_count:<br>                num_len = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">while</span> (num + <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> num_count:<br>                    num_len += <span class="hljs-number">1</span><br>                    num += <span class="hljs-number">1</span><br>                res = <span class="hljs-built_in">max</span>(res, num_len)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(n)，执行时间104ms，消耗内存32.6MB</p><p>根据这个集合给出的题目来看，hash这部分的题目已简单题或中等题考察居多，核心逻辑都是一个——利用hash特有的键值对去进行匹配等操作，所以把握好本质就比较简单了。不过真的不想遇到hash，脑子一转不过来就完犊子。</p><p>最后附上封面的猫猫图片（在这里还是要夸一下iPhone的微距，拍出来真的不错  ）<br><img src="/../img/hash%20blog%20cover.jpg" alt="hash cover"></p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题记录——矩阵</title>
    <link href="/2024/07/30/my-fourth-blog/"/>
    <url>/2024/07/30/my-fourth-blog/</url>
    
    <content type="html"><![CDATA[<p>这篇Blog将分享我在做leetcode面试经典150题中矩阵部分几道题的做题思路和代码。</p><h1 id="36-有效的数组"><a href="#36-有效的数组" class="headerlink" title="36 有效的数组"></a>36 有效的数组</h1><p>请你判断一个 <code>9 x 9</code> 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p><p>数字 <code>1-9</code> 在每一行只能出现一次。<br>数字 <code>1-9</code> 在每一列只能出现一次。<br>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</p><p>注意：</p><p>一个有效的数独（部分已被填充）不一定是可解的。</p><p>只需要根据以上规则，验证已经填入的数字是否有效即可。</p><p>空白格用 <code>&#39;.&#39;</code> 表示。</p><p>示例 1：</p><p><img src="/../img/%E6%9C%89%E6%95%88%E6%95%B0%E7%8B%AC_%E7%A4%BA%E4%BE%8B1.png" alt="示例 1"></p><p>输入：board &#x3D; </p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">[[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>]<br>,[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>,[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br></code></pre></td></tr></table></figure><p>输出：true</p><p>示例 2：</p><p>输入：board &#x3D; </p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">[[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>]<br>,[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>,[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br></code></pre></td></tr></table></figure><p>输出：false</p><p>解释：除了第一行的第一个数字从 <strong>5</strong> 改为 <strong>8</strong> 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</p><p>提示：</p><p><code>board.length == 9</code></p><p><code>board[i].length == 9</code></p><p><code>board[i][j]</code> 是一位数字<code>（1-9）</code>或者 <code>&#39;.&#39;</code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>核心条件就是每行每列每3*3的区域内不能重复</li><li>设置一个索引b来表示该数字在3*3区域内的索引<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidSudoku</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-comment"># 初始化三个二维列表来跟踪三个维度的数字情况</span><br>        row = [[<span class="hljs-number">0</span>] * <span class="hljs-number">9</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]<br>        col = [[<span class="hljs-number">0</span>] * <span class="hljs-number">9</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]<br>        block = [[<span class="hljs-number">0</span>] * <span class="hljs-number">9</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>                <span class="hljs-keyword">if</span> board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>:<br>                    num = <span class="hljs-built_in">int</span>(board[i][j]) - <span class="hljs-number">1</span> <span class="hljs-comment"># 将数字字符转化为整数并调整为0索引</span><br>                    b = (i // <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + j // <span class="hljs-number">3</span> <span class="hljs-comment"># 建立b索引</span><br>                    <span class="hljs-keyword">if</span> row[i][num] <span class="hljs-keyword">or</span> col[j][num] <span class="hljs-keyword">or</span> block[b][num]:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                    row[i][num] = col[j][num] = block[b][num] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(1)，执行时间56ms，消耗内存16.2MB</p><h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54 螺旋矩阵"></a>54 螺旋矩阵</h1><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong>，返回矩阵中的所有元素。</p><p>示例 1：</p><p><img src="/../img/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5_%E7%A4%BA%E4%BE%8B1.jpg" alt="示例 1"></p><p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</p><p>输出：[1,2,3,6,9,8,7,4,5]</p><p>示例 2：</p><p><img src="/../img/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5_%E7%A4%BA%E4%BE%8B2.jpg" alt="示例 2"></p><p>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</p><p>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p><p>提示：</p><p><code>m == matrix.length</code></p><p><code>n == matrix[i].length</code></p><p><code>1 &lt;= m, n &lt;= 10</code></p><p><code>-100 &lt;= matrix[i][j] &lt;= 100</code></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>相当于走格子，第一行走完走最后一列，最后一列走完走最后一行，最后一行走完走第一列，最后各自缩小一格然后走内侧。</p><p>提示：这里需要注意，从左到右遍历顶部行的时候不能用<code>[0]</code>来表示，会影响后续。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spiralOrder</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> matrix: <span class="hljs-keyword">return</span> []<br>        left, right, top, bottom = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(matrix) - <span class="hljs-number">1</span><br>        res = []<br>        <span class="hljs-keyword">while</span> left &lt;= right <span class="hljs-keyword">and</span> top &lt;= bottom:<br>            <span class="hljs-comment"># 从左到右遍历顶部行</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left, right + <span class="hljs-number">1</span>):<br>                res.append(matrix[top][i])<br>            <span class="hljs-comment"># 从上到下遍历右侧列</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(top + <span class="hljs-number">1</span>, bottom + <span class="hljs-number">1</span>):<br>                res.append(matrix[j][right])<br>            <span class="hljs-keyword">if</span> left &lt; right <span class="hljs-keyword">and</span> top &lt; bottom:<br>                <span class="hljs-comment"># 从右到左遍历底部行</span><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(right - <span class="hljs-number">1</span>, left, -<span class="hljs-number">1</span>):<br>                    res.append(matrix[bottom][i])<br>                <span class="hljs-comment"># 从下到上遍历左侧列</span><br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(bottom, top, -<span class="hljs-number">1</span>):<br>                    res.append(matrix[j][left])<br>            left, right, top, bottom = left + <span class="hljs-number">1</span>, right - <span class="hljs-number">1</span>, top + <span class="hljs-number">1</span>, bottom - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O(m*n)，执行用时55ms，消耗内存16.4MB</p><h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48 旋转图像"></a>48 旋转图像</h1><p>给定一个 n × n 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 <code>90</code> 度。</p><p>你必须在 <em><strong>原地</strong></em> 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p>示例 1：</p><p><img src="/../img/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F_%E7%A4%BA%E4%BE%8B1.jpg" alt="示例 1"></p><p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</p><p>输出：[[7,4,1],[8,5,2],[9,6,3]]</p><p>示例 2：</p><p><img src="/../img/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F_%E7%A4%BA%E4%BE%8B2.jpg" alt="示例 2"></p><p>输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</p><p>输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p><p>提示：</p><p><code>n == matrix.length == matrix[i].length</code></p><p><code>1 &lt;= n &lt;= 20</code></p><p><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ol><li>先明确题目要求是讲整个矩阵顺时针旋转90°</li><li>根据每个元素坐标来看，我们只需要将每个元素的坐标交换，最后将整个图像进行逐行反转就能直接完成</li></ol><p>下面有一个比较形象的图来演示一下过程</p><p><img src="/../img/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F_%E6%BC%94%E7%A4%BA.jpg" alt="演示"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        n = <span class="hljs-built_in">len</span>(matrix)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, n):<br>                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            matrix[i].reverse()<br>        <span class="hljs-keyword">return</span> matrix<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度O($n^2$)，执行时间36ms，消耗内存16.5MB</p><h1 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73 矩阵置零"></a>73 矩阵置零</h1><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <em><strong>原地</strong></em> 算法。</p><p>示例 1：</p><p><img src="/../img/%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6_%E7%A4%BA%E4%BE%8B1.jpg" alt="示例 1"></p><p>输入：matrix &#x3D; [[1,1,1],[1,0,1],[1,1,1]]</p><p>输出：[[1,0,1],[0,0,0],[1,0,1]]</p><p>示例 2：</p><p><img src="/../img/%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6_%E7%A4%BA%E4%BE%8B2.jpg" alt="示例 2"></p><p>输入：matrix &#x3D; [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</p><p>输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</p><p>提示：</p><p><code>m == matrix.length</code></p><p><code>n == matrix[0].length</code></p><p><code>1 &lt;= m, n &lt;= 200</code></p><p><code>-231 &lt;= matrix[i][j] &lt;= 231 - 1</code></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ol><li>设置两个集合来存储横纵坐标。</li><li>两次遍历，第一次遍历标记为0的元素横纵坐标并分别添加到set中，第二次遍历对元素进行修改。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setZeroes</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> matrix <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(matrix) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> matrix<br>        rows, cols = <span class="hljs-built_in">set</span>(), <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span>:<br>                    rows.add(i)<br>                    cols.add(j)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> rows <span class="hljs-keyword">or</span> j <span class="hljs-keyword">in</span> cols:<br>                    matrix[i][j] = <span class="hljs-number">0</span>    <br>        <span class="hljs-keyword">return</span> matrix<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度$O(m*n)$，执行时间38ms，消耗内存17.1MB</p><h1 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289 生命游戏"></a>289 生命游戏</h1><p>根据 <a href="https://baike.baidu.com/item/%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/22668799?fromtitle=%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F&fromid=2926434">百度百科</a> ，<strong>生命游戏</strong> ，简称为 <strong>生命</strong> ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p><p>给定一个包含 <code>m × n </code>个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： <code>1</code> 即为 活细胞 （live），或 <code>0</code> 即为 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><p>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</p><p>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</p><p>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</p><p>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</p><p>下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 <code>m x n</code> 网格面板 <code>board</code> 的当前状态，返回下一个状态。</p><p>示例 1：</p><p><img src="/../img/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F_%E7%A4%BA%E4%BE%8B1.jpg" alt="示例 1"></p><p>输入：board &#x3D; [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]</p><p>输出：[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]</p><p>示例 2：</p><p><img src="/../img/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F_%E7%A4%BA%E4%BE%8B2.jpg" alt="示例 2"></p><p>输入：board &#x3D; [[1,1],[1,0]]</p><p>输出：[[1,1],[1,1]]</p><p>提示：</p><p><code>m == board.length</code></p><p><code>n == board[i].length</code></p><p><code>1 &lt;= m, n &lt;= 25</code></p><p><code>board[i][j]</code> 为 <code>0</code> 或 <code>1</code></p><h2 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gameOfLife</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board: <span class="hljs-keyword">return</span> <br>        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-built_in">dict</span> = [(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">for</span> dx, dy <span class="hljs-keyword">in</span> <span class="hljs-built_in">dict</span>:<br>                    x, y = i + dx, j + dy<br>                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= x &lt; m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= y &lt; n:<br>                        cnt += board[x][y] &amp; <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (cnt &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> cnt &gt; <span class="hljs-number">3</span>):<br>                    board[i][j] = <span class="hljs-number">3</span><br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> cnt == <span class="hljs-number">3</span>:<br>                    board[i][j] = <span class="hljs-number">2</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                board[i][j] &gt;&gt;= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这个版本的代码直接报错，而后根据相似的思路重新写了一个版本的代码，先讲一下思路。</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ol><li>设置好八个位置的坐标</li><li>设置一个函数用于对某个位置的细胞周围的活细胞进行标记</li><li>根据题目所给出的情况进行处理</li><li>最后对所有位置的细胞进行遍历</li><li>-1表示当前细胞是从活变死，2表示当前细胞是从死变活</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gameOfLife</span>(<span class="hljs-params">self, board: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> board <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> board[<span class="hljs-number">0</span>]:<br>            <span class="hljs-keyword">return</span><br>    <br>        m, n = <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>        directions = [(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)]<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">count_live_neighbors</span>(<span class="hljs-params">x, y</span>):<br>            count = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> dx, dy <span class="hljs-keyword">in</span> directions:<br>                nx, ny = x + dx, y + dy<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; n <span class="hljs-keyword">and</span> <span class="hljs-built_in">abs</span>(board[nx][ny]) == <span class="hljs-number">1</span>:<br>                    count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> count<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                live_neighbors = count_live_neighbors(i, j)<br>                <br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (live_neighbors &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> live_neighbors &gt; <span class="hljs-number">3</span>):<br>                    board[i][j] = -<span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> live_neighbors == <span class="hljs-number">3</span>:<br>                    board[i][j] = <span class="hljs-number">2</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> board[i][j] == -<span class="hljs-number">1</span>:<br>                    board[i][j] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">elif</span> board[i][j] == <span class="hljs-number">2</span>:<br>                    board[i][j] = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度$O(m * n)$，执行时间36ms，消耗内存16.5MB</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode刷题——滑动窗口</title>
    <link href="/2024/07/21/my-third-post/"/>
    <url>/2024/07/21/my-third-post/</url>
    
    <content type="html"><![CDATA[<p>这篇Blog将分享我自己在做Leetcode面试经典150题中滑动窗口部分几道题的思路，let’s go。</p><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> 。</p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的子数组 [$nums_l$, $nums_{l+1}$, …, $nums_{r - 1}$, $nums_r$] ，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p>示例 1：</p><pre><code class="hljs">输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 `[4,3]` 是该条件下的长度最小的子数组。</code></pre><p>示例 2：</p><pre><code class="hljs">输入：target = 4, nums = [1,4,4]输出：1</code></pre><p>示例 3：</p><pre><code class="hljs">输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0</code></pre><p>提示：</p><p><code>1 &lt;= target &lt;= 109</code></p><p><code>1 &lt;= nums.length &lt;= 105</code></p><p><code>1 &lt;= nums[i] &lt;= 105</code></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>第一个while循环中total不断累加end位置上的值</li><li>第二个循环判断total &gt;&#x3D; target，这时满足了条件中所说的大于等于</li><li>用ans来存储数组，并对其进行最小值比较</li><li>total和start都后移，窗口滑动一位</li></ol><p>提示：</p><p>这里的窗口并不是一成不变的，而是不断累加到满足条件，期间窗口可能包含一个两个三个数。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSubArrayLen</span>(<span class="hljs-params">self, target:<span class="hljs-built_in">int</span>, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        ans = n + <span class="hljs-number">1</span><br>        start, end = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        total = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> end &lt; n:<br>            total += nums[end]<br>            <span class="hljs-keyword">while</span> total &gt;= target:<br>                ans = <span class="hljs-built_in">min</span>(ans, end - start + <span class="hljs-number">1</span>)<br>                total -= nums[start]<br>                start += <span class="hljs-number">1</span><br>            end += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> ans == n + <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> ans<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度O(n)，执行用时60ms，消耗内存26.9MB</p><h2 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p><p>示例 1:</p><pre><code class="hljs">输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 `&quot;abc&quot;`，所以其长度为 3。</code></pre><p>示例 2:</p><pre><code class="hljs">输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 `&quot;b&quot;`，所以其长度为 1。</code></pre><p>示例 3:</p><pre><code class="hljs">输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 `&quot;wke&quot;`，所以其长度为 3。请注意，你的答案必须是**子串**的长度，`&quot;pwke&quot;` 是一个子序列，不是子串。</code></pre><p>提示：</p><p><code>0 &lt;= s.length &lt;= 5 * 104</code></p><p><code>s</code> 由英文字母、数字、符号和空格组成</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>首先确定需要使用滑动窗口和哈希表</li><li>哈希表用于存储字符和其对应的索引</li><li>当字符已经存在于哈希表中，对应的滑动窗口左边界移到该字符存储于哈希表中的索引位置</li><li>涉及到四个初始变量。<code>n</code>表示s的长度，<code>ans</code>用于存储结果，哈希表<code>mp</code>，指针<code>j</code>表示左边界</li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        ans = <span class="hljs-number">0</span><br>        mp = &#123;&#125;<br>        j = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">in</span> mp:<br>                j = <span class="hljs-built_in">max</span>(mp[s[i]], j)<br>            ans = <span class="hljs-built_in">max</span>(ans, i - j + <span class="hljs-number">1</span>)<br>            mp[s[i]] = i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度O(n)，执行用时52ms，消耗内存16.5MB</p><h2 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30.串联所有单词的子串"></a>30.串联所有单词的子串</h2><p>给定一个字符串 <code>s</code> 和一个字符串数组 <code>words</code>。 <code>words</code> 中所有字符串 <strong>长度相同</strong>。</p><p><code>s</code> 中的 <strong>串联子串</strong> 是指一个包含  <code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p><ul><li>例如，如果 <code>words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>， 那么 <code>&quot;abcdef&quot;</code>， <code>&quot;abefcd&quot;</code>，<code>&quot;cdabef&quot;</code>， <code>&quot;cdefab&quot;</code>，<code>&quot;efabcd&quot;</code>， 和 <code>&quot;efcdab&quot;</code> 都是串联子串。 <code>&quot;acdbef&quot;</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li></ul><p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p><p>示例1：</p><pre><code class="hljs">输入：s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]输出：`[0,9]`解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。子串 &quot;barfoo&quot; 开始位置是 0。它是 words 中以 [&quot;bar&quot;,&quot;foo&quot;] 顺序排列的连接。子串 &quot;foobar&quot; 开始位置是 9。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。输出顺序无关紧要。返回 [9,0] 也是可以的。</code></pre><p>示例2：</p><pre><code class="hljs">输入：s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]输出：`[]`解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。所以我们返回一个空数组。</code></pre><p>示例 3：</p><pre><code class="hljs">输入：s = &quot;barfoofoobarthefoobarman&quot;, words = [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]输出：`[6,9,12]`解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。子串 &quot;foobarthe&quot; 开始位置是 6。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;] 顺序排列的连接。子串 &quot;barthefoo&quot; 开始位置是 9。它是 words 中以 [&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;] 顺序排列的连接。子串 &quot;thefoobar&quot; 开始位置是 12。它是 words 中以 [&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。</code></pre><p>提示：</p><p><code>1 &lt;= s.length &lt;= 104</code></p><p><code>1 &lt;= words.length &lt;= 5000</code></p><p><code>1 &lt;= words[i].length &lt;= 30</code></p><p><code>words[i]</code> 和 <code>s</code> 由小写英文字母组成</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>最开始初始化五个变量，<code>word_len</code>单词长度，<code>total_len</code>单词长度之和，<code>word_map</code>用Counter记录每个单词出现的次数，<code>ans</code>用于存储结果</li><li>滑动窗口每次滑动一个单词长度，当我们窗口内的单词出现次数和原本的不匹配就移动右边界，直到窗口内单词计数不超过原始计数</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> words:<br>            <span class="hljs-keyword">return</span> []<br><br>        word_len = <span class="hljs-built_in">len</span>(words[<span class="hljs-number">0</span>])<br>        word_count = <span class="hljs-built_in">len</span>(words)<br>        total_len = word_len * word_count<br>        word_map = Counter(words)<br>        ans = []<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(word_len):<br>            left = i<br>            right = i<br>            cur_map = Counter()<br>            <span class="hljs-keyword">while</span> right + word_len &lt;= <span class="hljs-built_in">len</span>(s):<br>                word = s[right:right + word_len]<br>                right += word_len<br>                <span class="hljs-keyword">if</span> word <span class="hljs-keyword">in</span> word_map:<br>                    cur_map[word] += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> cur_map[word] &gt; word_map[word]:<br>                        cur_map[s[left:left + word_len]] -= <span class="hljs-number">1</span><br>                        left += word_len<br>                    <span class="hljs-keyword">if</span> right - left == total_len:<br>                        ans.append(left)<br>                <span class="hljs-keyword">else</span>:<br>                    cur_map.clear()<br>                    left = right<br><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度O(n * m)，执行时间72ms，消耗内存17.1MB</p><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76 最小覆盖子串"></a>76 最小覆盖子串</h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p>注意：</p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p>示例1：</p><pre><code class="hljs">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;输出：&quot;BANC&quot;解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#39;A&#39;、&#39;B&#39; 和 &#39;C&#39;。</code></pre><p>示例 2：</p><pre><code class="hljs">输入：s = &quot;a&quot;, t = &quot;a&quot;输出：&quot;a&quot;解释：整个字符串 s 是最小覆盖子串。</code></pre><p>示例 3:</p><pre><code class="hljs">输入: s = &quot;a&quot;, t = &quot;aa&quot;输出: &quot;&quot;解释: t 中两个字符 &#39;a&#39; 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</code></pre><p>提示：</p><p><code>m == s.length</code><br><code>n == t.length</code><br><code>1 &lt;= m, n &lt;= 105</code><br><code>s</code> 和 <code>t</code> 由英文字母组成</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>初始化五个变量，<code>need</code>用于记录<code>t</code>每个字符的需求数量，<code>missing</code>用于记录还需要匹配的字符数量，<code>left</code>左边界，<code>start</code>起始位置，<code>min_len</code>长度，<code>ans</code>存储结果</li><li>滑动窗口使用right指针遍历字符串<code>s</code>，如果当前字符在<code>need</code>中数量大于0则减少<code>missing</code>表示需求字符少一个</li><li>当<code>missing</code>为0即窗口内包含所有所需字符，移动left继续遍历直到 <code>need[s[left]]</code> 不再小于 0。</li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minWindow</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> t: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>        need = Counter(t)<br>        missing = <span class="hljs-built_in">len</span>(t)<br>        left = start = <span class="hljs-number">0</span><br>        min_len = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        ans = <span class="hljs-string">&quot;&quot;</span><br>        <br>        <span class="hljs-keyword">for</span> right, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s, <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> need[char] &gt; <span class="hljs-number">0</span>:<br>                missing -= <span class="hljs-number">1</span><br>            need[char] -= <span class="hljs-number">1</span><br>            <br>            <span class="hljs-keyword">if</span> missing == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> need[s[left]] &lt; <span class="hljs-number">0</span>:<br>                    need[s[left]] += <span class="hljs-number">1</span><br>                    left += <span class="hljs-number">1</span><br>                    <br>                <span class="hljs-keyword">if</span> right - left &lt; min_len:<br>                    min_len = right - left<br>                    ans = s[left:right]<br>                    <br>                need[s[left]] += <span class="hljs-number">1</span><br>                left += <span class="hljs-number">1</span><br>                missing += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度O(n)，执行用时108ms，消耗内存16.8MB</p><p>好的，滑动窗口部分的题目就四个，到这里就结束了。滑动窗口的核心思路就在于不断移动窗口去匹配题设所给出的条件，之前刷2024春招100题那会还没特别明白这部分，现在也是彻底会了🤣不过还是不想笔试或面试遇到，这个真的好烦。</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>刷题</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卧推训练过程中发现的一个小问题</title>
    <link href="/2024/07/20/My-Second-Blog/"/>
    <url>/2024/07/20/My-Second-Blog/</url>
    
    <content type="html"><![CDATA[<p>满打满算健身也快一年了，身材也有了极其明显的变化。虽然因为长时间坐着不动外加kuku吃碳水导致腰上肉长得飞快，也正因此上半身感觉上下没啥分别。说回正题，这篇Blog主要是想聊一下我自己最近遇到的也是我这么长时间以来完全忽略的一点，还是两个健身房里的大佬一块换着练的时候被指出来的。</p><h1 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h1><p>这个问题说起来也不是很大，实际上就是很多健身博主都在说的卧推的时候手腕的位置。我自己刚开始是听了那些博主的话，乖乖的每次都强行让手腕保持中立位，但每次都感觉非常的别扭。由于是自己练再加上原本就很瘦，我的卧推重量现在也只是60KG做组，之前30、40KG时每次练完胸回来手腕倒是没有不舒服，到45+就开始不对劲了。每次练完胸回来都感觉手腕非常难受，有的时候还需要用云南白药喷雾。自打我开始健身就听说过TFCC，我自己当时也有点担心会不会是，也做了下自测什么的，但最后的结果都是没问题。到这里我已经产生奇怪的念头了，为什么我每次明明戴了护腕还是会不舒服呢？</p><h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><p>直到那天和两个大佬一起练，我才知道我自己的手腕是非常塌的，基本上可以说完美符合网上所说的全靠手腕支撑杠铃。在这里我画了个简图。<br><img src="/../img/second%20blog%20pic.jpg" alt="alt text"><br>可以看到左侧是正常的手腕处于中立位，如果用正常视角来看杠铃杆就是靠我们虎口下面的部分来支持，说到这里还需要提到掰杠，不过这个问题我们后面再说。而右边就是我之前的卧推姿势，手腕非常塌，通过受力分析可以得到一个结论。除了杠铃在手上的重力、我们给杠铃的推力，还有一个向斜下方的力。由于我们以这种姿势卧推是靠手掌托住杠铃，手腕收到的力等于我们的重力。而斜向下的力属于对抗我们重力过程中的副产物，同样作用于手腕。故而我们可以得出结论，斜向下的力和重力双重叠加导致我们的手腕受到了大于杠铃本身的重力。</p><p>那么为什么说当保持中立位的时候我们的手腕不会受到那么大的力呢？这里我们需要了解到一个事情。当我们的手腕在中立位时，我们的手腕、手肘、小臂处于同一条线，力线垂直向下，重力垂直作用于前臂，相当于我们整个前臂来对抗重力。反观塌腕时我们单纯用手腕来对抗，很明显保持中立位是对我们的手腕很友好的。</p><h1 id="掰杠"><a href="#掰杠" class="headerlink" title="掰杠"></a>掰杠</h1><p>再说会掰杠，为什么很多博主会刻意提到掰杠中整个操作。这里我们来观察下，当我们不使用掰杠，单纯用正常的卧推姿势去卧推，我们杠铃位于我们的大鱼际上，这时我们可以发现，杠铃的重心是略微偏离我们的小臂垂直线的，这样可能会造成手腕略微压力增大。而我们手腕微微外旋我们就能发现，大鱼际和小鱼际近似处于一个平面，而平面和我们的小臂垂直线属于垂直。这时我们就可以达到我们前面所说的手腕中立位的“完美”卧推上臂姿势。</p><p>当然并不是说不掰杠就不好，掰杠的作用并不是单纯的为了减弱那么一丢丢力，而是我们的手腕本身就非常脆弱，软组织一旦损伤可以说这辈子都可能健身和say goodbye，毕竟这个软组织恢复慢、影响大，为了我们的日常生活和训练生活，我们一定要在动作标准的情况下尽最大可能避免受伤。</p><p>接下来就要说到掰杠最大的作用了——增加稳定性。健身的人通常都会熟悉一个名词叫做肩胛骨，可以说得肩胛骨者得天下（这话怎么和高中那会的得语文者得天下一模一样，不会提出这句话的人是语文老师吧）。肩胛骨负责了我们上半身非常多的作用，而卧推的准备过程中我们需要沉肩、稳定肩胛骨、稳定下半身、背部肌肉绷紧。这些无一例外都是为了稳定二字。而我们的掰杠，很大程度上是为了辅助我们去稳定肩胛骨，根据我微不足道的观察发现，现代人因为长时间伏案工作、滑手机已经导致我们的肩胛骨很容易形成翼状肩胛。翼状肩胛不仅难看而且非常影响我们的卧推稳定性（本次不讨论翼状肩胛对背部的影响，这个后续会写我自己背部训练还是有一定心得的）。也正因此掰杠提供的额外增加就很好的进行了补充。可以试一试先沉肩然后空手外旋，这时会发现我们的肩胛骨位置有明显的感觉。也正因此换到卧推当中，掰杠可以提供给我们额外的稳定性，让我们不至于把卧推做成诺克萨斯断头台🤣</p><h1 id="结束咯😝"><a href="#结束咯😝" class="headerlink" title="结束咯😝"></a>结束咯😝</h1><p>好的，相信看到这里的朋友已经明白为什么我会写这篇Blog了。从我自身角度来说，被指出问题后我对手腕姿势进行了修改，后续我卧推后也没有再出现特别难受的情况。同时我也去学习了掰杠技巧，进一步增强了卧推（虽然重量依旧没变化，大夏天真的吃啥都掉体重）。所以，我这一年中不断的磨合我的动作，不断上重量，不断学习。之前看到有人说过一句话“健身就是一年增重一年减重改动作的不断循环”，从我个人角度而言，我并不反对这句话，因为我自己这一年也是这么走过来的，从哑铃卧推6KG到现在的杠铃卧推60KG，从辅助引体需要50KG（那会我体重不到60）到现在轻松自重引体。但在这过程中我自己也在不断的反思学习，任何事情都是需要不断学习打磨，不断完善，世间并无一蹴而就的事情。</p><p>好咯，这次的Blog就到这里结束啦，有兴趣的朋友可以去我的IG看我拍的健身照片，不过应该看不出来啥区别，毕竟我发的时候已经有了一些变化了，最早很瘦的应该是没有的。</p>]]></content>
    
    
    <categories>
      
      <category>健身记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>健身</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>360技术综合H卷笔试——编程题记录</title>
    <link href="/2024/07/20/My-First-Blog/"/>
    <url>/2024/07/20/My-First-Blog/</url>
    
    <content type="html"><![CDATA[<p>360是我七月初就已经投的公司，同时也是我今年秋招第一个拿到笔试的公司。在考前按照往年的试卷估计题目应该是40道客观题2道编程题。实际结果也如预期一般，30多道的单选题，为数不多的多选题（每个卷子的题型不一样，maybe我这个卷子的少）以及2个编程题。接下来我将尽可能完整的复刻题目并阐述我自己的做法，同时也会附加我自己的代码，望各位看官满意。</p><h2 id="第一题-加密算法"><a href="#第一题-加密算法" class="headerlink" title="第一题 加密算法"></a><strong>第一题 加密算法</strong></h2><p>有两个人在研究加密算法，一个人提出对只包含小写英文字母的字符串，将 ’a’替换成 ’1’，将 ’b’;替换成 ’2’……，将 ’z’替换成 ’26’。比如一个字符串 ’aabac’（想不起来了，我编的），加密后变成了 ’11213’，但另外一个人提出困难会造成多个结果，就比如 ’11213’也可能是 ’kbm’，会产生多个结果。所以我们要做的就是计算某个加密后的字符串可能对应的原字符串个数，要求取模10^9+7。</p><p>输入：</p><p>第一行n是加密后的字符串长度</p><p>第二行是加密后的字符串</p><p>输出：</p><p>一个正整数表示原字符串个数</p><p>样例输入：</p><p>5</p><p>11213</p><p>样例输出：</p><p>8</p><p>在做题的时候我就感觉这题怎么这么熟悉，考完一看才发现这不就是leetcode 91 解码方法。</p><p>既然提到了那就顺便说一下这道题的思路吧，如果实在需要代码可以直接用笔试题的代码稍微改改应该maybe也能行？</p><p>首先这道题需要对一个问题进行多次匹配求解出多个情况。也就是说字符串’11213’可能被分为’1’和’1213’也可能被分为’11’和’213’类似于这样的不断进行。故而就想到了动态规划来解决。<br>接下来就需要具体构建：</p><ol><li>定义一个数组dp，其中dp[i]表示长度为i的加密字符串可能解码出的原字符串个数。</li><li>设置初始条件dp[0] &#x3D; 1，即空字符串有一种解码方式。</li><li>状态转移：<ul><li>如果当前字符可以作为有效的单字符解码(1 &lt;&#x3D; s[i - 1] &lt;&#x3D; 9)，则dp[i] +&#x3D; dp[i - 1]</li><li>如果当前字符和前一个字符可以作为一个有效的双字符解码(10 &lt;&#x3D; s[i - 2:i] &lt;&#x3D; 26)，则dp[i] +&#x3D; dp[i - 2]</li></ul></li><li>最终结果为dp[n]</li></ol><p>好的，接下来回到笔试的考题加密算法本身。</p><p>首先分析问题，我们需要给每个字母进行一一对应；加密后的字符串可能对应多个原字符串；我们需要对结果进行取模。<br>接下来来说说具体的思路：</p><ol><li>使用动态规划来解决</li><li>创建一个数组dp，其中dp[i]表示前i个数字可能对应的原字符串</li><li>对每个位置i，我们需要考虑单独解码和组合解码</li></ol><p>借助这个大致思路得到了下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_possible_string</span>(<span class="hljs-params">encoded</span>):<br>    MOD = <span class="hljs-number">1000000007</span><br>    n = <span class="hljs-built_in">len</span>(encoded)<br>    dp = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> encoded[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 单独解码</span><br>        <span class="hljs-keyword">if</span> encoded[i - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;0&#x27;</span>:<br>            dp[i] = dp[i - <span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 组合解码</span><br>        two_digit = <span class="hljs-built_in">int</span>(encoded[i - <span class="hljs-number">2</span>:i])<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">10</span> &lt;= two_digit &lt;= <span class="hljs-number">26</span>:<br>            dp[i] = (dp[i] + dp[i - <span class="hljs-number">2</span>]) % MOD<br><br>    <span class="hljs-keyword">return</span> dp[n]<br><br><span class="hljs-comment"># 输入</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>encoded = <span class="hljs-built_in">input</span>()<br><br><span class="hljs-comment"># 输出</span><br>result = count_possible_string(encoded)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>到这里第一题就结束了，不过我需要说明一点的是，我的代码并不是最优代码，只是能AC这道题，这里也只是提供一种代码和一种思路。</p><h2 id="第二题-传染病防控"><a href="#第二题-传染病防控" class="headerlink" title="第二题 传染病防控"></a>第二题 传染病防控</h2><p>某市正在进行传染病防控，某市有n个人，每个人有一个位置$(x_{i},y_{i})$。现在已知有一个是高风险人员，但不知道是谁。同时我们定义一个安全距离k，如果某个人和这个高风险人员的距离不超过k，那么这个人也将被列为高风险人员。所以我们现在需要帮工作人员得到最多的高风险人员数量。两个人$(x_1,y_1),(x_2,y_2)$的距离公式为$|x_1-x_2| + |y_1 - y_2|$。</p><p>输入描述：</p><p>一行两个整数n，k</p><p>接下来一行n个整数分别表示$x_1$到$x_n$</p><p>接下来一行n个整数分别表示$y_1$到$y_n$</p><p>输出描述：</p><p>输出一个整数表示最多的高风险人员数量</p><p>样例输入：（这里因为debug了好几遍输了好几遍所以还有记录，可以用原本的数）</p><p>5 2</p><p>8 6 1 5 1</p><p>4 4 3 4 6</p><p>样例输出：</p><p>3</p><p>首先明确一点，这个距离公式就是常用的曼哈顿距离，所以在正式写算法前需要先把这个距离公式给写了。</p><p>接下来说一下我的大致思路：</p><ol><li>首先构建图，根据输入的坐标和距离构建邻接矩阵<code>ajd</code></li><li>图的遍历：这里根据惯例选择DFS或BFS来遍历图，我选的是BFS，以此计算出某一点出发的最大连通节点数。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">max_high_risk</span>(<span class="hljs-params">n, k, x, y</span>):<br>    <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br>    <span class="hljs-comment"># 曼哈顿距离公式</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">manhatten_distance</span>(<span class="hljs-params">x1, y1, x2, y2</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(x1 - x2) + <span class="hljs-built_in">abs</span>(y1 - y2)<br><br>    <span class="hljs-comment"># 构建邻接表，adj[i]表示与第i个人相邻的所有人</span><br>    adj = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">if</span> manhatten_distance(x[i], y[i], x[j], y[j]) &lt;= k:<br>                adj[i].append(j)<br>                adj[j].append(i)<br><br>    <span class="hljs-comment"># 构建BFS            </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">start</span>):<br>        queue = deque([start])<br>        visited = <span class="hljs-built_in">set</span>([start])<br>        count = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> queue:<br>            current = queue.popleft()<br>            <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> adj[current]:<br>                <span class="hljs-keyword">if</span> neighbor <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>                    queue.append(neighbor)<br>                    visited.add(neighbor)<br>                    count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> count<br><br>    max_count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        max_count = <span class="hljs-built_in">max</span>(max_count, bfs(i))<br>    <span class="hljs-keyword">return</span> max_count<br><br><span class="hljs-comment"># 输入</span><br>n, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>x = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>y = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br><span class="hljs-comment"># 输出</span><br><span class="hljs-built_in">print</span>(max_high_risk(n, k, x, y))<br></code></pre></td></tr></table></figure><p>到这里第二题也就结束了，我当时这道题debug了好几遍，第一次是输入不对，第二次是邻接矩阵出问题，到第三次才成功AC。再次说明我的代码仅仅只能通过所有样例完成这道题，并不是最优解。</p><p>最后附上一张在食堂吃饭的时候拍到的学长，超乖的一只猫咪，就是动作有那么一丝丝不文雅。</p><p><img src="/../img/first%20blog%20cover.jpg" alt="alt text"></p>]]></content>
    
    
    <categories>
      
      <category>笔试记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔试</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
